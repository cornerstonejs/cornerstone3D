import {
  ToolSpecificToolData,
  ToolSpecificToolState,
  FrameOfReferenceSpecificToolState,
  ToolState,
} from '../../types/toolStateTypes'
import cloneDeep from 'lodash.clonedeep'

import {
  EVENTS as RENDERING_EVENTS,
  eventTarget,
  Types,
  Utilities,
} from '@precisionmetrics/cornerstone-render'

import {
  setToolDataLocked,
  checkAndDefineIsLockedProperty,
} from './toolDataLocking'

interface FilterInterface {
  FrameOfReferenceUID?: string
  toolName?: string
}

/**
 * This class stores toolState in per FrameOfReference. Tool coordinates are
 * in the world coordinates for the viewports, which is the patient coordinate system for DICOM.
 *
 * Each FrameOfReferenceSpecificToolStateManager is separate, so it is be possible
 * to render different annotations of the same tool on different viewports that share
 * the same FrameOfReferenceUID, however no core tool in this library currently does this.
 * This could be useful for e.g. viewing two different reads of the same data side-by-side.
 *
 * Note that this class is a singleton and should not be instantiated directly.
 *
 */
export default class FrameOfReferenceSpecificToolStateManager {
  private toolState: ToolState
  public readonly uid: string

  /**
   * @param uid - The uid of the state manager. If omitted it is autogenerated.
   */
  constructor(uid?: string) {
    if (!uid) {
      uid = Utilities.uuidv4()
    }
    this.toolState = {}
    this.uid = uid

    // Listen to the IMAGE_VOLUME_MODIFIED event to invalidate data.
    eventTarget.addEventListener(
      RENDERING_EVENTS.IMAGE_VOLUME_MODIFIED,
      this._imageVolumeModifiedHandler
    )
  }

  /**
   * When a volume is modified we invalidate all of the `toolState` on the
   * volume's `FrameOfReferenceUID`. This is mainly to update statistics calculations
   * when an annotation is drawn whilst data is still loading.
   *
   * @param evt - The IMAGE_VOLUME_MODIFIED rendering event.
   */
  _imageVolumeModifiedHandler = (
    evt: Types.EventTypes.ImageVolumeModifiedEvent
  ) => {
    const eventData = evt.detail
    const { FrameOfReferenceUID } = eventData

    const toolState = this.toolState
    const frameOfReferenceSpecificToolState = toolState[FrameOfReferenceUID]

    if (!frameOfReferenceSpecificToolState) {
      return
    }

    Object.keys(frameOfReferenceSpecificToolState).forEach((toolName) => {
      const toolSpecificToolState = frameOfReferenceSpecificToolState[toolName]

      toolSpecificToolState.forEach((toolData) => {
        const data: { invalidated?: boolean } = toolData.data

        if (data && data.invalidated !== undefined) {
          data.invalidated = true
        }
      })
    })
  }

  /**
   * Returns all the available frameOfReferences inside the state manager
   * @returns - All the registered frame of references inside the manager
   */
  getFramesOfReference = (): Array<string> => {
    return Object.keys(this.toolState)
  }

  /**
   * get all tools `ToolSpecificToolState` for the provided FrameOfReference
   *
   * @param FrameOfReferenceUID - The UID of the FrameOfReference to retrieve data for.
   * @returns FrameOfReferenceSpecificToolState
   */
  getFrameOfReferenceToolState = (
    FrameOfReferenceUID: string
  ): FrameOfReferenceSpecificToolState => {
    return this.toolState[FrameOfReferenceUID]
  }

  /**
   * Get `ToolSpecificToolState` from the the manager given the `FrameOfReferenceUID` and `toolName`.
   *
   * @param FrameOfReferenceUID - The UID of the FrameOfReference to retrieve data for.
   * @param toolName - The name of the tool to retrieve data for.
   */
  get = (
    FrameOfReferenceUID: string,
    toolName: string
  ): ToolSpecificToolState | undefined => {
    const frameOfReferenceSpecificToolState =
      this.toolState[FrameOfReferenceUID]

    if (!frameOfReferenceSpecificToolState) {
      return
    }

    return frameOfReferenceSpecificToolState[toolName]
  }

  /**
   * Given the unique identified for the some `toolData`, returns the `toolData`
   * from the `toolState`. Searches are more efficient if either/both of
   * the `FrameOfReferenceUID` and the `toolName` are given by the `filter`.
   *
   * @param toolDataUID - The unique identifier of the `toolData`.
   * @param filter - A `filter` which reduces the scope of the search.
   *
   * @returns The retrieved `toolData`.
   */
  getToolStateByToolDataUID = (
    toolDataUID: string,
    filter: FilterInterface = {}
  ): ToolSpecificToolData | undefined => {
    const toolSpecificToolStateAndIndex =
      this._getToolSpecificToolStateAndIndex(toolDataUID, filter)

    if (!toolSpecificToolStateAndIndex) {
      return
    }

    const { toolSpecificToolState, index } = toolSpecificToolStateAndIndex

    return toolSpecificToolState[index]
  }

  /**
   * Adds an instance of `ToolSpecificToolData` to the `toolState`.
   *
   * @param toolData - The toolData to add.
   */
  addToolState = (toolData: ToolSpecificToolData): void => {
    const { metadata } = toolData
    const { FrameOfReferenceUID, toolName } = metadata

    const toolState = this.toolState

    let frameOfReferenceSpecificToolState = toolState[FrameOfReferenceUID]

    if (!frameOfReferenceSpecificToolState) {
      toolState[FrameOfReferenceUID] = {}

      frameOfReferenceSpecificToolState = toolState[FrameOfReferenceUID]
    }

    let toolSpecificToolState = frameOfReferenceSpecificToolState[toolName]

    if (!toolSpecificToolState) {
      frameOfReferenceSpecificToolState[toolName] = []

      toolSpecificToolState = frameOfReferenceSpecificToolState[toolName]
    }

    toolSpecificToolState.push(toolData)
    checkAndDefineIsLockedProperty(toolData)
  }

  /**
   * Removes an instance of `ToolSpecificToolData` from the `toolState`.
   *
   * @param toolData - The toolData to remove.
   */
  removeToolState = (toolData: ToolSpecificToolData): void => {
    const { metadata } = toolData
    const { FrameOfReferenceUID, toolName, toolDataUID } = metadata
    const toolState = this.toolState

    const frameOfReferenceSpecificToolState = toolState[FrameOfReferenceUID]

    if (!frameOfReferenceSpecificToolState) {
      throw new Error(
        `frameOfReferenceSpecificToolState with FrameOfReferenceUID ${FrameOfReferenceUID} does not exist.`
      )
    }

    const toolSpecificToolState = frameOfReferenceSpecificToolState[toolName]
    if (!toolSpecificToolState) {
      throw new Error(
        `toolSpecificToolState for toolName ${toolName} on FrameOfReferenceUID ${FrameOfReferenceUID} does not exist.`
      )
    }

    const index = toolSpecificToolState.findIndex(
      (toolData) => toolData.metadata.toolDataUID === toolDataUID
    )

    toolSpecificToolState.splice(index, 1)

    // remove tool specific tool state if no tool data is left
    if (!toolSpecificToolState.length) {
      delete frameOfReferenceSpecificToolState[toolName]
    }

    // Make sure it is not held in the global set of locked instances
    setToolDataLocked(toolData, false)
  }

  /**
   * Given the unique identified for the some `toolData`, removes the `toolData`
   * from the `toolState`. Searches are more efficient if either/both of
   * the `FrameOfReferenceUID` and the `toolName` are given by the `filter`.
   *
   * @param toolDataUID - The unique identifier of the `toolData` to remove.
   * @param filter - A `filter` which reduces the scope of the search.
   */
  removeToolStateByToolDataUID = (
    toolDataUID: string,
    filter: FilterInterface = {}
  ) => {
    const toolSpecificToolStateAndIndex =
      this._getToolSpecificToolStateAndIndex(toolDataUID, filter)

    if (!toolSpecificToolStateAndIndex) {
      return
    }

    const { toolSpecificToolState, index } = toolSpecificToolStateAndIndex
    const { metadata } = toolSpecificToolState[0]

    toolSpecificToolState.splice(index, 1)

    // remove tool specific tool state if no tool data is left
    if (!toolSpecificToolState.length) {
      const { toolName } = metadata
      delete this.toolState[metadata.FrameOfReferenceUID][toolName]
    }
  }

  /**
   * Returns a section of the toolState. Useful for serialization.
   *
   * - If no arguments are given, the entire `ToolState` instance is returned.
   * - If the `FrameOfReferenceUID` is given, the corresponding
   * `FrameOfReferenceSpecificToolState` instance is returned.
   * - If both the `FrameOfReferenceUID` and the `toolName` are are given, the
   * corresponding `ToolSpecificToolState` instance is returned.
   *
   * @param FrameOfReferenceUID - A filter string for returning the `toolState` of a specific frame of reference.
   * @param toolName - A filter string for returning `toolState` for a specific tool on a specific frame of reference.
   *
   * @returns The retrieved `toolData`.
   */
  saveToolState = (
    FrameOfReferenceUID?: string,
    toolName?: string
  ): ToolState | FrameOfReferenceSpecificToolState | ToolSpecificToolState => {
    const toolState = this.toolState

    if (FrameOfReferenceUID && toolName) {
      const frameOfReferenceSpecificToolState = toolState[FrameOfReferenceUID]

      if (!frameOfReferenceSpecificToolState) {
        return
      }

      const toolSpecificToolState = frameOfReferenceSpecificToolState[toolName]

      return cloneDeep(toolSpecificToolState)
    } else if (FrameOfReferenceUID) {
      const frameOfReferenceSpecificToolState = toolState[FrameOfReferenceUID]

      return cloneDeep(frameOfReferenceSpecificToolState)
    }

    return cloneDeep(toolState)
  }

  /**
   * Restores a section of the `toolState`. Useful for loading in serialized data.
   *
   * - If no arguments are given, the entire `ToolState` instance is restored.
   * - If the `FrameOfReferenceUID` is given, the corresponding
   * `FrameOfReferenceSpecificToolState` instance is restored.
   * - If both the `FrameOfReferenceUID` and the `toolName` are are given, the
   * corresponding `ToolSpecificToolState` instance is restored.
   *
   * @param FrameOfReferenceUID - A filter string for restoring only the `toolState` of a specific frame of reference.
   * @param toolName - A filter string for restoring `toolData` for a specific tool on a specific frame of reference.
   */
  restoreToolState = (
    state:
      | ToolState
      | FrameOfReferenceSpecificToolState
      | ToolSpecificToolState,
    FrameOfReferenceUID?: string,
    toolName?: string
  ): void => {
    const toolState = this.toolState

    if (FrameOfReferenceUID && toolName) {
      // Set ToolSpecificToolState for FrameOfReferenceUID and toolName.

      let frameOfReferenceSpecificToolState = toolState[FrameOfReferenceUID]

      if (!frameOfReferenceSpecificToolState) {
        toolState[FrameOfReferenceUID] = {}

        frameOfReferenceSpecificToolState = toolState[FrameOfReferenceUID]
      }

      frameOfReferenceSpecificToolState[toolName] = <ToolSpecificToolState>state
    } else if (FrameOfReferenceUID) {
      // Set FrameOfReferenceSpecificToolState for FrameOfReferenceUID.

      toolState[FrameOfReferenceUID] = <FrameOfReferenceSpecificToolState>state
    } else {
      // Set entire toolState

      this.toolState = <ToolState>cloneDeep(state)
    }
  }

  /**
   * Given the unique identifier for a tool, returns the `ToolSpecificToolState`
   * it belongs to, and the `index` of its position in that array.
   *
   * @param toolDataUID - The unique identifier of the `toolData`.
   * @param filter - A `filter` which reduces the scope of the search.
   *
   * @returns {object}
   * @returns {object.toolSpecificToolState} The `ToolSpecificToolState` instance containing the `toolData`.
   * @returns {object.index} The `index` of the `toolData` in the `toolSpecificToolState` array.
   *
   * @internal
   */
  private _getToolSpecificToolStateAndIndex(
    toolDataUID: string,
    filter: FilterInterface
  ): { toolSpecificToolState: ToolSpecificToolState; index: number } {
    const { toolName, FrameOfReferenceUID } = filter
    const toolState = this.toolState

    let frameOfReferenceUIDKeys

    if (FrameOfReferenceUID) {
      frameOfReferenceUIDKeys = [FrameOfReferenceUID]
    } else {
      frameOfReferenceUIDKeys = Object.keys(toolState)
    }

    const numFrameOfReferenceUIDKeys = frameOfReferenceUIDKeys.length

    for (let i = 0; i < numFrameOfReferenceUIDKeys; i++) {
      const frameOfReferenceUID = frameOfReferenceUIDKeys[i]
      const frameOfReferenceSpecificToolState = toolState[frameOfReferenceUID]

      let toolNameKeys

      if (toolName) {
        toolNameKeys = [toolName]
      } else {
        toolNameKeys = Object.keys(frameOfReferenceSpecificToolState)
      }

      const numToolNameKeys = toolNameKeys.length

      for (let j = 0; j < numToolNameKeys; j++) {
        const toolName = toolNameKeys[j]

        const toolSpecificToolState =
          frameOfReferenceSpecificToolState[toolName]

        const index = toolSpecificToolState.findIndex(
          (toolData) => toolData.metadata.toolDataUID === toolDataUID
        )

        if (index !== -1) {
          return { toolSpecificToolState, index }
        }
      }
    }
  }
}

const defaultFrameOfReferenceSpecificToolStateManager =
  new FrameOfReferenceSpecificToolStateManager('DEFAULT')

export { defaultFrameOfReferenceSpecificToolStateManager }

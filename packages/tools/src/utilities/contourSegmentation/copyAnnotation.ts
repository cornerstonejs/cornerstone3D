import { utilities } from '@cornerstonejs/core';
import type {
  ContourSegmentationAnnotation,
  ContourSegmentationData,
} from '../../types';
import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';
import { addAnnotation, getAnnotation } from '../../stateManagement';
import { getViewportAssociatedToSegmentation } from './getViewportAssociatedToSegmentation';
import { getToolGroupForViewport } from '../../store/ToolGroupManager';

export function copyAnnotation(
  annotation: ContourSegmentationAnnotation,
  segmentationId: string,
  segmentIndex: number
): ContourSegmentationAnnotation {
  const newAnnotation: ContourSegmentationAnnotation = {
    annotationUID: utilities.uuidv4(),
    data: {
      contour: {
        closed: true,
        polyline: [],
      },
      segmentation: {
        segmentationId,
        segmentIndex,
      },
      handles: {},
    },
    handles: {},
    highlighted: false,
    autoGenerated: false,
    invalidated: false,
    isLocked: false,
    isVisible: true,
    metadata: {
      ...annotation.metadata,
      toolName: annotation.metadata.toolName,
    },
  };
  newAnnotation.data.segmentation.segmentationId = segmentationId;
  newAnnotation.data.segmentation.segmentIndex = segmentIndex;

  // Copy specific attributes
  if (annotation.data.contour?.polyline) {
    newAnnotation.data.contour.polyline = [...annotation.data.contour.polyline];
  }

  if (annotation.data.handles?.points) {
    newAnnotation.data.handles.points = annotation.data.handles.points.map(
      (point) => [...point]
    );
  }

  return newAnnotation;
}

function getAnnotationsMap(segmentationId: string) {
  const segmentation = getSegmentation(segmentationId);
  if (!segmentation) {
    return;
  }

  const contourRepresentationData = segmentation.representationData
    ?.Contour as ContourSegmentationData;

  if (!contourRepresentationData) {
    return;
  }

  const { annotationUIDsMap } = contourRepresentationData;
  if (!annotationUIDsMap) {
    return;
  }
  return annotationUIDsMap;
}

export function copyContourSegment(
  segmentationId: string,
  segmentIndex: number,
  targetSegmentationId: string,
  targetSegmentIndex: number
) {
  const annotationUIDsMap = getAnnotationsMap(segmentationId);
  const targetAnnotationUIDsMap = getAnnotationsMap(targetSegmentationId);
  if (!annotationUIDsMap || !targetAnnotationUIDsMap) {
    return;
  }

  if (!annotationUIDsMap?.has(segmentIndex)) {
    return;
  }

  const annotationUIDs = annotationUIDsMap.get(segmentIndex);

  const viewport = getViewportAssociatedToSegmentation(targetSegmentationId);
  if (!viewport) {
    return;
  }
  const toolGroup = getToolGroupForViewport(viewport.id);

  const copyContourAnnotation = (annotation: ContourSegmentationAnnotation) => {
    const newAnnotation = copyAnnotation(
      annotation,
      targetSegmentationId,
      targetSegmentIndex
    );
    if (toolGroup) {
      const instance = toolGroup.getToolInstance(annotation.metadata.toolName);
      if (instance) {
        // Properly test if the function isSplineAnnotation exists in instance
        if (
          typeof instance.isSplineAnnotation === 'function' &&
          instance.isSplineAnnotation(annotation)
        ) {
          instance.createSplineObjectFromType(
            newAnnotation,
            (annotation.data.spline as { type: string }).type
          );
        }
      }
    }
    addAnnotation(newAnnotation, viewport.element);
    newAnnotationsUID.add(newAnnotation.annotationUID);
    return newAnnotation;
  };

  const newAnnotationsUID = new Set<string>();
  for (const annotationUID of annotationUIDs) {
    const annotation = getAnnotation(
      annotationUID
    ) as ContourSegmentationAnnotation;
    const newAnnotation = copyContourAnnotation(annotation);
    if (annotation?.childAnnotationUIDs) {
      newAnnotation.childAnnotationUIDs = [];
      for (const childAnnotationUID of annotation.childAnnotationUIDs) {
        const childAnnotation = getAnnotation(
          childAnnotationUID
        ) as ContourSegmentationAnnotation;
        const newChildAnnotation = copyContourAnnotation(childAnnotation);
        newChildAnnotation.parentAnnotationUID = newAnnotation.annotationUID;
        newAnnotation.childAnnotationUIDs.push(
          newChildAnnotation.annotationUID
        );
      }
    }
  }

  targetAnnotationUIDsMap.set(targetSegmentIndex, newAnnotationsUID);
}

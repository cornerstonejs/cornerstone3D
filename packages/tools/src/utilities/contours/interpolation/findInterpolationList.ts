import getInterpolationData from './getInterpolationData';
import type { InterpolationViewportData } from '../../../types/InterpolationTypes';

/**
 * findInterpolationList - Finds the list of contours to interpolate,
 * including whether they are new contours, or auto generated contours that need
 * to be updated.
 *
 * @param toolData - object, The tool data of the roi contour.
 * @returns object, An object containing the ROIContourData and the
 * interpolationList.
 */

function generateInterpolationData(
  toolData,
  viewportData: InterpolationViewportData
) {
  const interpolationData = getInterpolationData(viewportData, [
    {
      key: 'interpolationUID',
      value: viewportData.interpolationUID,
    },
  ]);
  const extent = _getExtentOfRegion(interpolationData);
  const sliceEdited = _getSlicePositionOfToolData(
    interpolationData,
    toolData.annotationUID
  );
  const interpolationList = [];

  // Check if contours between the extent can be interpolated.
  for (let i = extent[0] + 1; i <= extent[1] - 1; i++) {
    if (_sliceNeedsInterpolating(interpolationData, i)) {
      const contourPair = _getBoundingPair(i, extent, interpolationData);

      if (
        contourPair &&
        (contourPair[0] === sliceEdited || contourPair[1] === sliceEdited)
      ) {
        _appendInterpolationList(contourPair, interpolationList, i);
      }
    }
  }

  return {
    interpolationData,
    interpolationList,
  };
}

/**
 * _getExtentOfRegion - Returns a 2 element array with the slice locations of
 * top and bottom polygon of the ROIContour.
 *
 * @param ROIContourData - object, Data on the slice location of contours
 *                                  for the ROIContour.
 * @returns Number[], The slice locations of the top and bottom polygon of the ROIContour.
 */

function _getExtentOfRegion(interpolationData) {
  const extent = [];

  for (let i = 0; i < interpolationData.length; i++) {
    if (interpolationData[i].annotations) {
      extent.push(i);
      break;
    }
  }

  for (let i = interpolationData.length - 1; i >= 0; i--) {
    if (interpolationData[i].annotations) {
      extent.push(i);
      break;
    }
  }

  return extent;
}

/**
 * _getSlicePositionOfToolData - Finds the slice that was edited.
 *
 * @param ROIContourData - description
 * @param polygonUid - description
 * @returns description
 */
function _getSlicePositionOfToolData(interpolationData, annotationUID) {
  for (let i = 0; i < interpolationData.length; i++) {
    if (interpolationData[i].annotations) {
      const annotations = interpolationData[i].annotations;

      for (let j = 0; j < annotations.length; j++) {
        if (annotations[j].annotationUID === annotationUID) {
          return i;
        }
      }
    }
  }

  return;
}

/**
 * _sliceNeedsInterpolating - Check whether there are no contours on this
 * slice, or one which is an interpolated contour.
 *
 * @param ROIContourData - object, Data on the slice location of contours
 *                                  for the ROIContour.
 * @param sliceIndex - Number, The slice index.
 * @returns boolean, Whether or not the slice needs interpolating.
 */
function _sliceNeedsInterpolating(interpolationData, sliceIndex) {
  return (
    !interpolationData[sliceIndex].annotations ||
    (interpolationData[sliceIndex].annotations.length === 1 &&
      interpolationData[sliceIndex].annotations[0].autoGenerated)
  );
}

/**
 * _appendInterpolationList - If the contour on slice i can be updated, add it to the
 * interpolationList.
 *
 * @param sliceIndex - Number, The slice index.
 * @param extent - Number[], The extent of slice occupancy of the
 *                                  ROIContour.
 * @param ROIContourData - object[],  Data for the slice location of contours
 *                                  for the ROIContour.
 * @param interpolationList - object[],  The list of contours to be interpolated.
 * @returns null
 */
function _appendInterpolationList(contourPair, interpolationList, i) {
  if (!interpolationList[contourPair[0]]) {
    interpolationList[contourPair[0]] = {
      pair: contourPair,
      list: [],
    };
  }

  interpolationList[contourPair[0]].list.push(i);
}

/**
 * _getBoundingPair - Given the slice index and extent of the ROIContour,
 * get the pair of polygons to use for interpolation of the slice. Returns
 * undefined if there is an ambiguity and interpolation can't take place.
 *
 * @param sliceIndex - Number, The slice index.
 * @param extent - Number[], The extent of slice occupancy of the ROIContour.
 * @param ROIContourData - object[], Data for the slice location of contours for the ROIContour.
 * @returns Number[] || undefined, The pair of slice indices, or undefined if
 * the contours to use for interpolation is ambiguous.
 */

function _getBoundingPair(sliceIndex, extent, interpolationData) {
  const annotationPair = [];
  let canInterpolate = true;

  // Check for nearest lowest sliceIndex containing contours.
  for (let i = sliceIndex - 1; i >= extent[0]; i--) {
    if (interpolationData[i].annotations) {
      const annotations = interpolationData[i].annotations;

      if (annotations[0].autoGenerated) {
        // This contour is interpolated. We need to
        // Find a solid contour to interpolate from.
        continue;
      }

      if (annotations.length > 1) {
        canInterpolate = false;
      }

      // Found single, non interpolated contour to interpolate from.
      annotationPair.push(i);
      break;
    }
  }

  if (!canInterpolate || !annotationPair.length) {
    return;
  }

  // Check for nearest upper sliceIndex containing contours.
  for (let i = sliceIndex + 1; i <= extent[1]; i++) {
    if (interpolationData[i].annotations) {
      const annotations = interpolationData[i].annotations;

      if (annotations[0].autoGenerated) {
        // This contour is interpolated. We need to
        // Find a solid contour to interpolate from.
        continue;
      }

      if (annotations.length > 1) {
        canInterpolate = false;
      }

      annotationPair.push(i);
      break;
    }
  }

  if (!canInterpolate || annotationPair.length < 2) {
    return;
  }

  return annotationPair;
}

export default generateInterpolationData;

import { utilities as csUtils } from '@cornerstonejs/core';
import type { Types } from '@cornerstonejs/core';
import {
  AnnotationCompletedEventType,
  AnnotationModifiedEventType,
  AnnotationRemovedEventType,
} from '../../../types/EventTypes';
import { state as annotationState } from '../../../stateManagement/annotation';
import type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';
import getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';
import type {
  InterpolationViewportData,
  AcceptInterpolationSelector,
} from '../../../types/InterpolationTypes';
import interpolate from '../../contours/interpolation/interpolate';
import deleteRelatedAnnotations from './deleteRelatedAnnotations';
import { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';
import ChangeTypes from '../../../enums/ChangeTypes';
import getViewportForAnnotation from '../../getViewportForAnnotation';

const { uuidv4 } = csUtils;

export default class InterpolationManager {
  static toolNames = [];

  static addTool(toolName: string) {
    if (!this.toolNames.includes(toolName)) {
      this.toolNames.push(toolName);
    }
  }

  /**
   * Accepts the autogenerated interpolations, marking them as non-autogenerated.
   * Can provide a selector to choose which ones to accept
   */
  static acceptAutoGenerated(
    annotationGroupSelector: AnnotationGroupSelector,
    selector: AcceptInterpolationSelector = {}
  ) {
    const { toolNames, segmentationId, segmentIndex } = selector;
    for (const toolName of toolNames || InterpolationManager.toolNames) {
      const annotations = annotationState.getAnnotations(
        toolName,
        annotationGroupSelector
      );
      if (!annotations?.length) {
        continue;
      }
      for (const annotation of annotations) {
        const { data, autoGenerated } = annotation;
        if (!autoGenerated) {
          continue;
        }
        if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {
          continue;
        }
        if (
          segmentationId &&
          segmentationId !== data.segmentation.segmentationId
        ) {
          continue;
        }
        annotation.autoGenerated = false;
      }
    }
  }

  static handleAnnotationCompleted = (evt: AnnotationCompletedEventType) => {
    const annotation = evt.detail.annotation as InterpolationROIAnnotation;
    if (!annotation?.metadata) {
      return;
    }
    const { toolName } = annotation.metadata;

    if (!this.toolNames.includes(toolName)) {
      return;
    }

    const viewport = getViewportForAnnotation(annotation);
    if (!viewport) {
      console.warn('Unable to find viewport for', annotation);
      return;
    }
    const sliceData: Types.ImageSliceData = getSliceData(viewport);
    const viewportData: InterpolationViewportData = {
      viewport,
      sliceData,
      annotation,
      interpolationUID: annotation.interpolationUID,
    };
    const hasInterpolationUID = !!annotation.interpolationUID;
    // If any update, triggered on an annotation, then it will be treated as non-autogenerated.
    annotation.autoGenerated = false;
    if (hasInterpolationUID) {
      // This has already been configured with matching details, so just run
      //  the interpolation again.
      deleteRelatedAnnotations(viewportData);
      interpolate(viewportData);
      return;
    }
    const filterData = [
      {
        key: 'segmentIndex',
        value: annotation.data.segmentation.segmentIndex,
        parentKey: (annotation) => annotation.data.segmentation,
      },
      {
        key: 'viewPlaneNormal',
        value: annotation.metadata.viewPlaneNormal,
        parentKey: (annotation) => annotation.metadata,
      },
      {
        key: 'viewUp',
        value: annotation.metadata.viewUp,
        parentKey: (annotation) => annotation.metadata,
      },
    ];
    let interpolationAnnotations = getInterpolationDataCollection(
      viewportData,
      filterData
    );
    // Skip other type of annotations with same location
    interpolationAnnotations = interpolationAnnotations.filter(
      (interpolationAnnotation) => interpolationAnnotation.interpolationUID
    );
    if (!annotation.interpolationUID) {
      annotation.interpolationUID =
        interpolationAnnotations[0]?.interpolationUID || uuidv4();
      viewportData.interpolationUID = annotation.interpolationUID;
    }
    interpolate(viewportData);
  };

  static handleAnnotationUpdate = (evt: AnnotationModifiedEventType) => {
    const annotation = evt.detail.annotation as InterpolationROIAnnotation;
    const { changeType = ChangeTypes.HandlesUpdated } = evt.detail;
    if (!annotation?.metadata) {
      return;
    }
    const { toolName } = annotation.metadata;

    if (
      !this.toolNames.includes(toolName) ||
      changeType !== ChangeTypes.HandlesUpdated
    ) {
      return;
    }

    const viewport = getViewportForAnnotation(annotation);
    if (!viewport) {
      console.warn(
        'Unable to find matching viewport for annotation interpolation',
        annotation
      );
      return;
    }

    const sliceData: Types.ImageSliceData = getSliceData(viewport);
    const viewportData: InterpolationViewportData = {
      viewport,
      sliceData,
      annotation,
      interpolationUID: annotation.interpolationUID,
    };
    interpolate(viewportData);
  };

  static handleAnnotationDelete = (evt: AnnotationRemovedEventType) => {
    const annotation = evt.detail.annotation as InterpolationROIAnnotation;
    if (!annotation?.metadata) {
      return;
    }
    const { toolName } = annotation.metadata;

    if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {
      return;
    }
    const viewport = getViewportForAnnotation(annotation);

    if (!viewport) {
      console.warn(
        "No viewport, can't delete interpolated results",
        annotation
      );
      return;
    }

    const sliceData: Types.ImageSliceData = getSliceData(viewport);
    const viewportData: InterpolationViewportData = {
      viewport,
      sliceData,
      annotation,
      interpolationUID: annotation.interpolationUID,
    };
    // If any update, triggered on an annotation, then it will be treated as non-interpolated.
    annotation.autoGenerated = false;
    deleteRelatedAnnotations(viewportData);
  };
}

function getSliceData(viewport): Types.ImageSliceData {
  const sliceData: Types.ImageSliceData = {
    numberOfSlices: viewport.getNumberOfSlices(),
    imageIndex: viewport.getCurrentImageIdIndex(),
  };
  return sliceData;
}

import { triggerEvent } from '@cornerstonejs/core';
import * as annotationStateManagement from '../../../stateManagement/annotation';
import interpolate from '../../contours/interpolation/interpolate';
import type { InterpolationViewportData } from '../../../types/InterpolationTypes';
import getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';
import { AnnotationInterpolationRemovedEventDetail } from '../../../types/EventTypes';
import EventTypes from '../../../enums/Events';

/**
 * deleteRelatedAnnotations - Delete the same interpolation uid on deleting one of them.
 *
 * @param eventData - Object.
 * @returns null
 */
export default function deleteRelatedAnnotations(
  viewportData: InterpolationViewportData
) {
  const { annotation } = viewportData;
  const interpolationAnnotations = getInterpolationDataCollection(
    viewportData,
    [{ key: 'interpolationUID', value: viewportData.interpolationUID }],
    true
  );

  const referencedSliceIndex = annotation.metadata.referencedSliceIndex;
  let nextNonInterpolatedIndex = null;
  for (
    let i = referencedSliceIndex + 1, j = referencedSliceIndex - 1;
    i < interpolationAnnotations.length, j >= 0;
    i++, j--
  ) {
    let interpolationAnnIndex = interpolationAnnotations.findIndex(
      (ann) => ann.metadata.referencedSliceIndex === i
    );
    let interpolationAnn = interpolationAnnotations[interpolationAnnIndex];
    if (interpolationAnn && !interpolationAnn.autoGenerated) {
      nextNonInterpolatedIndex = interpolationAnnIndex;
      break;
    }

    interpolationAnnIndex = interpolationAnnotations.findIndex(
      (ann) => ann.metadata.referencedSliceIndex === j
    );
    interpolationAnn = interpolationAnnotations[interpolationAnnIndex];
    if (interpolationAnn && !interpolationAnn.autoGenerated) {
      nextNonInterpolatedIndex = interpolationAnnIndex;
      break;
    }
  }
  deleteInterpolatedAnnotation(
    interpolationAnnotations,
    referencedSliceIndex,
    viewportData
  );
  deleteInterpolatedAnnotation(
    interpolationAnnotations,
    referencedSliceIndex,
    viewportData,
    -1
  );
  const nextAnnotation = interpolationAnnotations[nextNonInterpolatedIndex];
  if (nextAnnotation) {
    // Trigger interpolation for the next non-interpolated annotation
    const viewportNewData: InterpolationViewportData = {
      viewport: viewportData.viewport,
      sliceData: {
        numberOfSlices: viewportData.sliceData.numberOfSlices,
        imageIndex: nextAnnotation.metadata.referencedSliceIndex,
      },
      annotation: nextAnnotation,
      interpolationUID: nextAnnotation.interpolationUID,
    };
    interpolate(viewportNewData);
  }
}

function deleteInterpolatedAnnotation(
  interpolationAnnotations,
  referencedSliceIndex,
  viewportData,
  direction = 1
) {
  const removedAnnotations = [];
  for (
    let i = referencedSliceIndex + direction;
    i < interpolationAnnotations.length && i > -1;
    i += direction
  ) {
    const interpolationAnnIndex = interpolationAnnotations.findIndex(
      (ann) => ann.metadata.referencedSliceIndex === i
    );
    const interpolationAnn = interpolationAnnotations[interpolationAnnIndex];
    if (interpolationAnn) {
      if (!interpolationAnn.autoGenerated) {
        break;
      }
      removedAnnotations.push(interpolationAnn);
      annotationStateManagement.state.removeAnnotation(
        interpolationAnn.annotationUID
      );
    }
  }

  const { id, renderingEngineId, element } = viewportData.viewport;

  const eventDetails: AnnotationInterpolationRemovedEventDetail = {
    annotations: removedAnnotations,
    element,
    viewportId: id,
    renderingEngineId,
  };

  if (removedAnnotations.length) {
    triggerEvent(
      viewportData.viewport.element,
      EventTypes.INTERPOLATED_ANNOTATIONS_REMOVED,
      eventDetails
    );
  }
}

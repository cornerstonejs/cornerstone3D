## API Report File for "@cornerstonejs/tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Corners } from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget/Constants';
import type { GetGPUTier } from 'detect-gpu';
import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';
import { IStackViewport as IStackViewport_2 } from 'packages/core/dist/types/types';
import { IVolumeViewport as IVolumeViewport_2 } from 'packages/core/dist/types/types';
import { mat3 } from 'gl-matrix';
import { mat4 } from 'gl-matrix';
import type { TierResult } from 'detect-gpu';
import { vec3 } from 'gl-matrix';
import type vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';
import vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';
import { vtkColorTransferFunction } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';
import { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';
import vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import type { vtkPiecewiseFunction } from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';
import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';
import type vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';

declare namespace aabb {
    export {
        intersectAABB,
        distanceToPoint,
        distanceToPointSquared
    }
}

// @public (undocumented)
function acceptAutogeneratedInterpolations(annotationGroupSelector: AnnotationGroupSelector, selector: AcceptInterpolationSelector): void;

declare namespace activeSegmentation {
    export {
        getActiveSegmentationRepresentation,
        getActiveSegmentation,
        setActiveSegmentationRepresentation
    }
}

// @public (undocumented)
function addAnnotation(annotation: Annotation, annotationGroupSelector: AnnotationGroupSelector): string;

// @public (undocumented)
const addCanvasPointsToArray: (element: HTMLDivElement, canvasPoints: Types_2.Point2[], newCanvasPoint: Types_2.Point2, commonData: PlanarFreehandROICommonData) => number;

// @public (undocumented)
function addChildAnnotation(parentAnnotation: Annotation, childAnnotation: Annotation): void;

// @public (undocumented)
function addColorLUT(colorLUT: Types_2.ColorLUT, index: number): void;

// @public (undocumented)
function addColorLUT_2(colorLUT: Types_2.ColorLUT, colorLUTIndex: number): void;

// @public (undocumented)
function addContourSegmentationAnnotation(annotation: ContourSegmentationAnnotation): void;

// @public (undocumented)
function addRepresentationData({ segmentationId, type, data, }: AddRepresentationData): void;

// @public (undocumented)
function addSegmentation(segmentationInput: SegmentationPublicInput, suppressEvents?: boolean): void;

// @public (undocumented)
function addSegmentationRepresentation(toolGroupId: string, segmentationRepresentation: ToolGroupSpecificRepresentation, suppressEvents?: boolean): void;

// @public (undocumented)
function addSegmentationRepresentations(toolGroupId: string, representationInputArray: RepresentationPublicInput[], toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig): Promise<string[]>;

// @public (undocumented)
function addSegmentations(segmentationInputArray: SegmentationPublicInput[]): void;

// @public (undocumented)
export function addTool(ToolClass: any): void;

// @public (undocumented)
function addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void;

// @public (undocumented)
interface AdvancedMagnifyAnnotation extends Annotation {
    // (undocumented)
    data: {
        zoomFactor: number;
        sourceViewportId: string;
        magnifyViewportId: string;
        isCanvasAnnotation: boolean;
        handles: {
            points: [Types_2.Point3, Types_2.Point3, Types_2.Point3, Types_2.Point3];
            activeHandleIndex: number | null;
        };
    };
}

// @public (undocumented)
export class AdvancedMagnifyTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    static Actions: typeof AdvancedMagnifyToolActions;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => AdvancedMagnifyAnnotation;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragDrawCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragHandle: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: AdvancedMagnifyAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: AdvancedMagnifyAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    magnifyViewportManager: AdvancedMagnifyViewportManager;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    onSetToolDisabled: () => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    showZoomFactorsList(evt: EventTypes_2.InteractionEventType, annotation: AdvancedMagnifyAnnotation): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: AdvancedMagnifyAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
interface AngleAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                angle: number;
            };
        };
    };
}

// @public (undocumented)
export class AngleTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => AngleAnnotation;
    // (undocumented)
    angleStartedNotYetCompleted: boolean;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: AngleAnnotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: AngleAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: AngleAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
type Annotation = {
    annotationUID?: string;
    parentAnnotationUID?: string;
    childAnnotationUIDs?: string[];
    highlighted?: boolean;
    isLocked?: boolean;
    isVisible?: boolean;
    invalidated?: boolean;
    autoGenerated?: boolean;
    metadata: Types_2.ViewReference & {
        toolName: string;
        cameraPosition?: Types_2.Point3;
        viewUp?: Types_2.Point3;
    };
    data: {
        handles?: {
            points?: Types_2.Point3[];
            activeHandleIndex?: number | null;
            textBox?: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox?: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
            [key: string]: any;
        };
        [key: string]: any;
        cachedStats?: unknown;
    };
};

declare namespace annotation {
    export {
        config,
        locking,
        selection,
        state_2 as state,
        visibility,
        FrameOfReferenceSpecificAnnotationManager,
        AnnotationGroup
    }
}
export { annotation }

// @public (undocumented)
type AnnotationAddedEventDetail = {
    viewportId?: string;
    renderingEngineId?: string;
    annotation: Annotation;
};

// @public (undocumented)
type AnnotationAddedEventType = Types_2.CustomEventType<AnnotationAddedEventDetail>;

// @public (undocumented)
type AnnotationCompletedEventDetail = {
    annotation: Annotation;
    changeType?: ChangeTypes.Completed;
};

// @public (undocumented)
type AnnotationCompletedEventType = Types_2.CustomEventType<AnnotationCompletedEventDetail>;

// @public (undocumented)
export abstract class AnnotationDisplayTool extends BaseTool {
    // (undocumented)
    filterInteractableAnnotationsForElement(element: HTMLDivElement, annotations: Annotations): Annotations | undefined;
    // (undocumented)
    protected getReferencedImageId(viewport: Types_2.IViewport, worldPos: Types_2.Point3, viewPlaneNormal: Types_2.Point3, viewUp: Types_2.Point3): string;
    // (undocumented)
    getStyle(property: string, specifications: StyleSpecifier, annotation?: Annotation): unknown;
    // (undocumented)
    onImageSpacingCalibrated: (evt: Types_2.EventTypes.ImageSpacingCalibratedEvent) => void;
    // (undocumented)
    abstract renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): any;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
class AnnotationFrameRange {
    // (undocumented)
    protected static frameRangeExtractor: RegExp;
    // (undocumented)
    protected static framesToImageId(imageId: string, range: FramesRange | string): string;
    // (undocumented)
    static framesToString(range: any): string;
    // (undocumented)
    static getFrameRange(annotation: Annotation): number | [number, number];
    // (undocumented)
    protected static imageIdToFrames(imageId: string): FramesRange;
    // (undocumented)
    static setFrameRange(annotation: Annotation, range: FramesRange | string, eventBase?: {
        viewportId: any;
        renderingEngineId: any;
    }): void;
}

// @public (undocumented)
class AnnotationGroup {
    constructor();
    // (undocumented)
    add(...annotationUIDs: string[]): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    findNearby(uid: string, direction: 1): string;
    // (undocumented)
    has(uid: string): boolean;
    // (undocumented)
    get isVisible(): boolean;
    // (undocumented)
    remove(...annotationUIDs: string[]): void;
    // (undocumented)
    setVisible(isVisible: boolean, baseEvent: BaseEventDetail, filter?: (annotationUID: string) => boolean): void;
    // (undocumented)
    protected unboundVisibleFilter(uid: string): boolean;
    // (undocumented)
    visibleFilter: (uid: string) => boolean;
}

// @public (undocumented)
type AnnotationGroupSelector = HTMLDivElement | string;

// @public (undocumented)
type AnnotationHandle = Types_2.Point3;

// @public (undocumented)
type AnnotationInterpolationCompletedEventDetail = {
    annotation: InterpolationROIAnnotation;
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type AnnotationInterpolationCompletedEventType = Types_2.CustomEventType<AnnotationInterpolationCompletedEventDetail>;

// @public (undocumented)
type AnnotationInterpolationRemovedEventDetail = {
    annotations: Array<InterpolationROIAnnotation>;
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type AnnotationInterpolationRemovedEventType = Types_2.CustomEventType<AnnotationInterpolationRemovedEventDetail>;

// @public (undocumented)
type AnnotationLockChangeEventDetail = {
    added: Array<Annotation>;
    removed: Array<Annotation>;
    locked: Array<Annotation>;
};

// @public (undocumented)
type AnnotationLockChangeEventType = Types_2.CustomEventType<AnnotationLockChangeEventDetail>;

// @public (undocumented)
type AnnotationModifiedEventDetail = {
    viewportId: string;
    renderingEngineId: string;
    annotation: Annotation;
    changeType?: ChangeTypes;
};

// @public (undocumented)
type AnnotationModifiedEventType = Types_2.CustomEventType<AnnotationModifiedEventDetail>;

// @public (undocumented)
type AnnotationRemovedEventDetail = {
    annotation: Annotation;
    annotationManagerUID: string;
};

// @public (undocumented)
type AnnotationRemovedEventType = Types_2.CustomEventType<AnnotationRemovedEventDetail>;

// @public (undocumented)
type AnnotationRenderContext = {
    enabledElement: Types_2.IEnabledElement;
    targetId: string;
    annotation: Annotation;
    annotationStyle: Record<string, any>;
    svgDrawingHelper: SVGDrawingHelper;
};

// @public (undocumented)
type AnnotationRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type AnnotationRenderedEventType = Types_2.CustomEventType<AnnotationRenderedEventDetail>;

// @public (undocumented)
type Annotations = Array<Annotation>;

// @public (undocumented)
type AnnotationSelectionChangeEventDetail = {
    added: Array<string>;
    removed: Array<string>;
    selection: Array<string>;
};

// @public (undocumented)
type AnnotationSelectionChangeEventType = Types_2.CustomEventType<AnnotationSelectionChangeEventDetail>;

// @public (undocumented)
type AnnotationState = {
    [key: string]: GroupSpecificAnnotations;
};

declare namespace AnnotationStyle {
    export {
        AnnotationStyle_2 as AnnotationStyle,
        ToolStyleConfig,
        StyleConfig,
        StyleSpecifier
    }
}

// @public (undocumented)
type AnnotationStyle_2 = {
    [key in `${Properties}${States}${Modes}`]?: string;
};

// @public (undocumented)
enum AnnotationStyleStates {
    // (undocumented)
    AutoGenerated = "AutoGenerated",
    // (undocumented)
    Default = "",
    // (undocumented)
    Highlighted = "Highlighted",
    // (undocumented)
    Locked = "Locked",
    // (undocumented)
    Selected = "Selected"
}

// @public (undocumented)
export abstract class AnnotationTool extends AnnotationDisplayTool {
    constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps);
    // (undocumented)
    abstract addNewAnnotation(evt: EventTypes_2.InteractionEventType, interactionType: InteractionTypes): Annotation;
    // (undocumented)
    abstract cancel(element: HTMLDivElement): any;
    // (undocumented)
    static createAndAddAnnotation(viewport: any, ...annotationBaseData: any[]): void;
    // (undocumented)
    static createAnnotation(...annotationBaseData: any[]): Annotation;
    // (undocumented)
    static createAnnotationForViewport(viewport: any, ...annotationBaseData: any[]): Annotation;
    // (undocumented)
    protected getAnnotationStyle(context: {
        annotation: Annotation;
        styleSpecifier: StyleSpecifier;
    }): {
        visibility: boolean;
        locked: boolean;
        color: string;
        lineWidth: number;
        lineDash: string;
        lineOpacity: number;
        fillColor: string;
        fillOpacity: number;
        shadow: boolean;
        textbox: Record<string, unknown>;
    };
    // (undocumented)
    getHandleNearImagePoint(element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    getLinkedTextBoxStyle(specifications: StyleSpecifier, annotation?: Annotation): Record<string, unknown>;
    // (undocumented)
    abstract handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: Annotation, handle: ToolHandle, interactionType: InteractionTypes): void;
    // (undocumented)
    abstract isPointNearTool(element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number, interactionType: string): boolean;
    // (undocumented)
    isSuvScaled(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, targetId: string, imageId?: string): boolean;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.MouseMoveEventType, filteredAnnotations?: Annotations) => boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    abstract toolSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: Annotation, interactionType: InteractionTypes, canvasCoords?: Types_2.Point2): void;
}

// @public (undocumented)
class AnnotationToPointData {
    constructor();
    // (undocumented)
    static convert(annotation: any, index: any, metadataProvider: any): {
        ReferencedROINumber: any;
        ROIDisplayColor: number[];
        ContourSequence: any;
    };
    // (undocumented)
    static register(toolClass: any): void;
    // (undocumented)
    static TOOL_NAMES: Record<string, any>;
}

// @public (undocumented)
type AnnotationVisibilityChangeEventDetail = {
    lastHidden: Array<string>;
    lastVisible: Array<string>;
    hidden: Array<string>;
};

// @public (undocumented)
type AnnotationVisibilityChangeEventType = Types_2.CustomEventType<AnnotationVisibilityChangeEventDetail>;

// @public (undocumented)
function areCoplanarContours(firstAnnotation: ContourAnnotation, secondAnnotation: ContourAnnotation): boolean;

// @public (undocumented)
function areSameSegment(firstAnnotation: ContourSegmentationAnnotation, secondAnnotation: ContourSegmentationAnnotation): boolean;

// @public (undocumented)
export class ArrowAnnotateTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => ArrowAnnotation;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _doneChangingTextCallback(element: any, annotation: any, updatedText: any): void;
    // (undocumented)
    doubleClickCallback: (evt: EventTypes_2.TouchTapEventType) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: ArrowAnnotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume(index1: any, index2: any, dimensions: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: ArrowAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: ArrowAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
    // (undocumented)
    touchTapCallback: (evt: EventTypes_2.TouchTapEventType) => void;
}

// @public (undocumented)
interface ArrowAnnotation extends Annotation {
    // (undocumented)
    data: {
        text: string;
        handles: {
            points: Types_2.Point3[];
            arrowFirst: boolean;
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
    };
}

// @public (undocumented)
export abstract class BaseTool implements IBaseTool {
    constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps);
    // (undocumented)
    applyActiveStrategy(enabledElement: Types_2.IEnabledElement, operationData: unknown): any;
    // (undocumented)
    applyActiveStrategyCallback(enabledElement: Types_2.IEnabledElement, operationData: unknown, callbackType: StrategyCallbacks | string): any;
    // (undocumented)
    configuration: Record<string, any>;
    // (undocumented)
    protected getTargetId(viewport: Types_2.IViewport): string | undefined;
    // (undocumented)
    protected getTargetIdImage(targetId: string, renderingEngine: Types_2.IRenderingEngine): Types_2.IImageData | Types_2.CPUIImageData | Types_2.IImageVolume;
    // (undocumented)
    getToolName(): string;
    // (undocumented)
    mode: ToolModes;
    // (undocumented)
    setActiveStrategy(strategyName: string): void;
    // (undocumented)
    setConfiguration(newConfiguration: Record<string, any>): void;
    // (undocumented)
    supportedInteractionTypes: InteractionTypes[];
    // (undocumented)
    toolGroupId: string;
    // (undocumented)
    static toolName: any;
}

declare namespace BasicStatsCalculator {
    export {
        BasicStatsCalculator_2 as BasicStatsCalculator,
        Calculator
    }
}

// @public (undocumented)
class BasicStatsCalculator_2 extends Calculator {
    // (undocumented)
    static getStatistics: () => NamedStatistics;
    // (undocumented)
    static statsCallback: ({ value: newValue }: {
        value: any;
    }) => void;
}

// @public (undocumented)
interface BidirectionalAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                length: number;
                width: number;
                unit: string;
            };
        };
    };
}

// @public (undocumented)
type BidirectionalData = {
    majorAxis: [Types_2.Point3, Types_2.Point3];
    minorAxis: [Types_2.Point3, Types_2.Point3];
    maxMajor: number;
    maxMinor: number;
    segmentIndex: number;
    label?: string;
    color?: string | number[];
    referencedImageId: string;
    sliceIndex: number;
};

// @public (undocumented)
export class BidirectionalTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation(evt: EventTypes_2.InteractionEventType): BidirectionalAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    _calculateLength(pos1: any, pos2: any): number;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragDrawCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyHandle: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getSignedAngle: (vector1: any, vector2: any) => number;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: BidirectionalAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, index3: any, index4: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: BidirectionalAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _movingLongAxisWouldPutItThroughShortAxis: (firstLineSegment: any, secondLineSegment: any) => boolean;
    // (undocumented)
    preventHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: BidirectionalAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace boundingBox {
    export {
        extend2DBoundingBoxInViewAxis,
        getBoundingBoxAroundShapeIJK,
        getBoundingBoxAroundShapeWorld,
        getBoundingBoxAroundShapeIJK as getBoundingBoxAroundShape
    }
}

// @public (undocumented)
type BoundsIJK_2 = Types_2.BoundsIJK;

// @public (undocumented)
export class BrushTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    acceptPreview(element?: HTMLDivElement): void;
    // (undocumented)
    createEditData(element: any): {
        volumeId: string;
        referencedVolumeId: any;
        segmentsLocked: number[] | [];
        segmentationRepresentationUID: string;
        imageIdReferenceMap?: undefined;
    } | {
        imageIdReferenceMap: Map<string, string>;
        segmentsLocked: number[] | [];
        segmentationRepresentationUID: string;
        volumeId?: undefined;
        referencedVolumeId?: undefined;
    };
    // (undocumented)
    protected getOperationData(element?: any): {
        points: any;
        segmentIndex: number;
        previewColors: any;
        viewPlaneNormal: any;
        toolGroupId: string;
        segmentationId: string;
        segmentationRepresentationUID: string;
        viewUp: any;
        strategySpecificConfiguration: any;
        preview: unknown;
        segmentsLocked: number[];
        imageIdReferenceMap?: Map<string, string>;
        volumeId?: string;
        referencedVolumeId?: string;
    } | {
        points: any;
        segmentIndex: number;
        previewColors: any;
        viewPlaneNormal: any;
        toolGroupId: string;
        segmentationId: string;
        segmentationRepresentationUID: string;
        viewUp: any;
        strategySpecificConfiguration: any;
        preview: unknown;
        volumeId: string;
        referencedVolumeId: any;
        segmentsLocked: number[] | [];
        imageIdReferenceMap?: undefined;
    };
    // (undocumented)
    invalidateBrushCursor(): void;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    onSetToolDisabled: (evt: any) => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    onSetToolPassive: (evt: any) => void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.MouseDownActivateEventType) => boolean;
    // (undocumented)
    previewCallback: () => void;
    // (undocumented)
    rejectPreview(element?: HTMLDivElement): void;
    // (undocumented)
    renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    protected updateCursor(evt: EventTypes_2.InteractionEventType): void;
}

// @public (undocumented)
function calculatePerimeter(polyline: number[][], closed: boolean): number;

// @public (undocumented)
abstract class Calculator {
    // (undocumented)
    static getStatistics: () => NamedStatistics;
    // (undocumented)
    static run: ({ value }: {
        value: any;
    }) => void;
}

// @public (undocumented)
function calibrateImageSpacing(imageId: string, renderingEngine: Types_2.IRenderingEngine, calibrationOrScale: Types_2.IImageCalibration | number): void;

// @public (undocumented)
export function cancelActiveManipulations(element: HTMLDivElement): string | undefined;

// @public (undocumented)
function canComputeRequestedRepresentation(segmentationRepresentationUID: string): boolean;

// @public (undocumented)
type CanvasCoordinates = [
Types_2.Point2,
Types_2.Point2,
Types_2.Point2,
Types_2.Point2
];

// @public (undocumented)
type CardinalSplineProps = SplineProps & {
    scale?: number;
    fixedScale?: boolean;
};

// @public (undocumented)
enum ChangeTypes {
    // (undocumented)
    Completed = "Completed",
    // (undocumented)
    HandlesUpdated = "HandlesUpdated",
    // (undocumented)
    InitialSetup = "InitialSetup",
    // (undocumented)
    Interaction = "Interaction",
    // (undocumented)
    InterpolationUpdated = "InterpolationUpdated",
    // (undocumented)
    StatsUpdated = "StatsUpdated"
}

// @public (undocumented)
enum ChangeTypes_2 {
    // (undocumented)
    POLYSEG_CONTOUR_TO_LABELMAP = "polySeg/convertContourToVolumeLabelmap",
    // (undocumented)
    POLYSEG_CONTOUR_TO_SURFACE = "polySeg/convertContourToSurface",
    // (undocumented)
    POLYSEG_LABELMAP_TO_SURFACE = "polySeg/convertLabelmapToSurface",
    // (undocumented)
    POLYSEG_SURFACE_TO_LABELMAP = "polySeg/convertSurfacesToVolumeLabelmap",
    // (undocumented)
    SURFACE_CLIPPING = "surfaceClipping"
}

// @public (undocumented)
function checkAndDefineIsLockedProperty(annotation: Annotation): void;

// @public (undocumented)
function checkAndDefineIsVisibleProperty(annotation: Annotation): void;

declare namespace cine {
    export {
        playClip,
        stopClip,
        Events_2 as Events,
        getToolState,
        addToolState
    }
}

// @public (undocumented)
type CinePlayContext = {
    get numScrollSteps(): number;
    get currentStepIndex(): number;
    get frameTimeVectorEnabled(): boolean;
    waitForRenderedCount?: number;
    scroll(delta: number): void;
};

declare namespace CINETypes {
    export {
        PlayClipOptions,
        ToolData,
        CinePlayContext
    }
}

// @public (undocumented)
interface CircleROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: [Types_2.Point3, Types_2.Point3];
            activeHandleIndex: number | null;
            textBox?: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats?: (ROICachedStats & {
            [targetId: string]: {
                radius: number;
                radiusUnit: string;
                perimeter: number;
            };
        }) | {
            pointsInVolume: Types_2.Point3[];
            projectionPoints: Types_2.Point3[][];
        };
    };
}

// @public (undocumented)
interface CircleROIStartEndThresholdAnnotation extends Annotation {
    // (undocumented)
    data: {
        label: string;
        startSlice: number;
        endSlice: number;
        cachedStats?: {
            pointsInVolume: Types_2.Point3[];
            projectionPoints: Types_2.Point3[][];
        };
        handles: {
            points: [Types_2.Point3, Types_2.Point3];
            activeHandleIndex: number | null;
        };
    };
    // (undocumented)
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        annotationUID?: string;
        FrameOfReferenceUID: string;
        referencedImageId?: string;
        toolName: string;
        enabledElement: any;
        volumeId: string;
        spacingInNormal: number;
    };
}

// @public (undocumented)
export class CircleROIStartEndThresholdTool extends CircleROITool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => {
        highlighted: boolean;
        invalidated: boolean;
        metadata: {
            toolName: string;
            viewPlaneNormal: Types_2.Point3;
            viewUp: Types_2.Point3;
            FrameOfReferenceUID: string;
            referencedImageId: any;
            volumeId: any;
            spacingInNormal: number;
            enabledElement: Types_2.IEnabledElement;
        };
        data: {
            label: string;
            startSlice: number;
            endSlice: number;
            handles: {
                textBox: {
                    hasMoved: boolean;
                    worldPosition: any;
                    worldBoundingBox: any;
                };
                points: [Types_2.Point3, Types_2.Point3];
                activeHandleIndex: any;
            };
            cachedStats: {
                pointsInVolume: any[];
                projectionPoints: any[];
            };
            labelmapUID: any;
        };
    };
    // (undocumented)
    _calculateCachedStatsTool(annotation: any, enabledElement: any): any;
    // (undocumented)
    _computePointsInsideVolume(annotation: any, imageVolume: any, enabledElement: any): void;
    // (undocumented)
    _computeProjectionPoints(annotation: CircleROIStartEndThresholdAnnotation, imageVolume: Types_2.IImageVolume): void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getEndSliceIndex(imageVolume: Types_2.IImageVolume, worldPos: Types_2.Point3, spacingInNormal: number, viewPlaneNormal: Types_2.Point3): number | undefined;
    // (undocumented)
    _getImageIdIndex(imageVolume: Types_2.IImageVolume, pos: vec3, spacingInNormal: number, viewPlaneNormal: Types_2.Point3): number | undefined;
    // (undocumented)
    _getStartSliceIndex(imageVolume: Types_2.IImageVolume, worldPos: Types_2.Point3, spacingInNormal: number, viewPlaneNormal: Types_2.Point3): number | undefined;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
export class CircleROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => CircleROIAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewport: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragDrawCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragHandle: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: CircleROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: CircleROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: CircleROIAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
export class CircleScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentIndex: number;
        volumeId: string;
        referencedVolumeId: string;
        imageIdReferenceMap: Map<string, string>;
        segmentsLocked: number[];
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        centerCanvas?: Array<number>;
        segmentationRepresentationUID?: string;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
function clearParentAnnotation(annotation: Annotation): void;

// @public (undocumented)
function clip(a: any, b: any, box: any, da?: any, db?: any): 1 | 0;

// @public (undocumented)
function clip_2(val: number, low: number, high: number): number;

// @public (undocumented)
type ClosestControlPoint = ClosestPoint & {
    index: number;
};

// @public (undocumented)
type ClosestPoint = {
    point: Types_2.Point2;
    distance: number;
};

// @public (undocumented)
type ClosestSplinePoint = ClosestPoint & {
    uValue: number;
};

// @public (undocumented)
interface CobbAngleAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                angle: number;
                arc1Angle: number;
                arc2Angle: number;
                points: {
                    world: {
                        arc1Start: Types_2.Point3;
                        arc1End: Types_2.Point3;
                        arc2Start: Types_2.Point3;
                        arc2End: Types_2.Point3;
                        arc1Angle: number;
                        arc2Angle: number;
                    };
                    canvas: {
                        arc1Start: Types_2.Point2;
                        arc1End: Types_2.Point2;
                        arc2Start: Types_2.Point2;
                        arc2End: Types_2.Point2;
                        arc1Angle: number;
                        arc2Angle: number;
                    };
                };
            };
        };
    };
}

// @public (undocumented)
export class CobbAngleTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => CobbAngleAnnotation;
    // (undocumented)
    angleStartedNotYetCompleted: boolean;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    distanceToLines: ({ viewport, points, canvasCoords, proximity }: {
        viewport: any;
        points: any;
        canvasCoords: any;
        proximity: any;
    }) => {
        distanceToPoint: number;
        distanceToPoint2: number;
        isNearFirstLine: boolean;
        isNearSecondLine: boolean;
    };
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        isNearFirstLine?: boolean;
        isNearSecondLine?: boolean;
    } | null;
    // (undocumented)
    getArcsStartEndPoints: ({ firstLine, secondLine, mid1, mid2, }: {
        firstLine: any;
        secondLine: any;
        mid1: any;
        mid2: any;
    }) => {
        arc1Start: Types_2.Point2;
        arc1End: Types_2.Point2;
        arc2Start: Types_2.Point2;
        arc2End: Types_2.Point2;
        arc1Angle: number;
        arc2Angle: number;
    };
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: CobbAngleAnnotation, handle: ToolHandle, interactionType?: string): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: CobbAngleAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    _mouseDownCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType | EventTypes_2.MouseMoveEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: CobbAngleAnnotation, interactionType: InteractionTypes, canvasCoords: Types_2.Point2, proximity?: number) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace color {
    export {
        getColorForSegmentIndex,
        addColorLUT_2 as addColorLUT,
        setColorLUT,
        setColorForSegmentIndex
    }
}

// @public (undocumented)
class Colorbar extends Widget {
    constructor(props: ColorbarProps);
    // (undocumented)
    get activeColormapName(): string;
    set activeColormapName(colormapName: string);
    // (undocumented)
    protected createRootElement(): HTMLElement;
    // (undocumented)
    _createTicksBar(props: ColorbarProps): ColorbarTicks;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    protected getVOIMultipliers(): [number, number];
    // (undocumented)
    protected hideTicks(): void;
    // (undocumented)
    get imageRange(): ColorbarVOIRange;
    set imageRange(imageRange: ColorbarVOIRange);
    // (undocumented)
    protected onContainerResize(): void;
    // (undocumented)
    protected onVoiChange(voiRange: ColorbarVOIRange): void;
    // (undocumented)
    get showFullImageRange(): boolean;
    set showFullImageRange(value: boolean);
    // (undocumented)
    protected showTicks(): void;
    // (undocumented)
    get voiRange(): ColorbarVOIRange;
    set voiRange(voiRange: ColorbarVOIRange);
}

declare namespace colorbar {
    export {
        Types_3 as Types,
        Enums_2 as Enums,
        Colorbar,
        ViewportColorbar
    }
}

// @public (undocumented)
type ColorbarCommonProps = {
    imageRange?: ColorbarImageRange;
    voiRange?: ColorbarVOIRange;
    ticks?: {
        position?: ColorbarRangeTextPosition;
        style?: ColorbarTicksStyle;
    };
    showFullPixelValueRange?: boolean;
};

// @public (undocumented)
type ColorbarImageRange = {
    lower: number;
    upper: number;
};

// @public (undocumented)
type ColorbarProps = (WidgetProps & ColorbarCommonProps) & {
    colormaps: IColorMapPreset[];
    activeColormapName?: string;
};

// @public (undocumented)
enum ColorbarRangeTextPosition {
    // (undocumented)
    Bottom = "bottom",
    // (undocumented)
    Left = "left",
    // (undocumented)
    Right = "right",
    // (undocumented)
    Top = "top"
}

// @public (undocumented)
type ColorbarSize = {
    width: number;
    height: number;
};

// @public (undocumented)
type ColorbarTicksProps = ColorbarCommonProps & {
    top?: number;
    left?: number;
    size?: ColorbarSize;
    container?: HTMLElement;
};

// @public (undocumented)
type ColorbarTicksStyle = {
    font?: string;
    color?: string;
    tickSize?: number;
    tickWidth?: number;
    labelMargin?: number;
    maxNumTicks?: number;
};

// @public (undocumented)
type ColorbarVOIRange = ColorbarImageRange;

// @public (undocumented)
function computeAndAddContourRepresentation(segmentationId: string, options?: PolySegConversionOptions): Promise<{
    annotationUIDsMap: Map<number, Set<string>>;
}>;

// @public (undocumented)
function computeAndAddLabelmapRepresentation(segmentationId: string, options?: PolySegConversionOptions): Promise<RawLabelmapData>;

// @public (undocumented)
function computeAndAddSurfaceRepresentation(segmentationId: string, options?: PolySegConversionOptions): Promise<{
    geometryIds: Map<number, string>;
}>;

declare namespace config {
    export {
        getState,
        getFont,
        toolStyle as style
    }
}

declare namespace config_2 {
    export {
        color,
        visibility_2 as visibility,
        getGlobalConfig_2 as getGlobalConfig,
        getGlobalRepresentationConfig,
        getToolGroupSpecificConfig_2 as getToolGroupSpecificConfig,
        setGlobalConfig_2 as setGlobalConfig,
        setGlobalRepresentationConfig,
        setToolGroupSpecificConfig_2 as setToolGroupSpecificConfig,
        setSegmentSpecificConfig,
        getSegmentSpecificConfig,
        setSegmentationRepresentationSpecificConfig_2 as setSegmentationRepresentationSpecificConfig,
        getSegmentationRepresentationSpecificConfig_2 as getSegmentationRepresentationSpecificConfig
    }
}

declare namespace CONSTANTS {
    export {
        CORNERSTONE_COLOR_LUT as COLOR_LUT
    }
}
export { CONSTANTS }

// @public (undocumented)
function containsPoint(polyline: Types_2.Point2[], point: Types_2.Point2, options?: {
    closed?: boolean;
    holes?: Types_2.Point2[][];
}): boolean;

// @public (undocumented)
function containsPoints(polyline: Types_2.Point2[], points: Types_2.Point2[]): boolean;

// @public (undocumented)
function contourAndFindLargestBidirectional(segmentation: any): any;

// @public (undocumented)
type ContourAnnotation = Annotation & ContourAnnotationData;

// @public (undocumented)
type ContourAnnotationCompletedEventDetail = AnnotationCompletedEventDetail & {
    contourHoleProcessingEnabled: boolean;
};

// @public (undocumented)
type ContourAnnotationData = {
    data: {
        contour: {
            polyline: Types_2.Point3[];
            closed: boolean;
            windingDirection?: ContourWindingDirection;
        };
    };
    onInterpolationComplete?: () => void;
};

declare namespace contours {
    export {
        areCoplanarContours,
        _default_2 as contourFinder,
        getDeduplicatedVTKPolyDataPoints,
        _default_3 as detectContourHoles,
        generateContourSetsFromLabelmap,
        AnnotationToPointData,
        getContourHolesDataWorld,
        getContourHolesDataCanvas,
        updateContourPolyline,
        interpolation,
        acceptAutogeneratedInterpolations,
        findHandlePolylineIndex,
        calculatePerimeter
    }
}

declare namespace contourSegmentation {
    export {
        areSameSegment,
        isContourSegmentationAnnotation,
        addContourSegmentationAnnotation,
        removeContourSegmentationAnnotation
    }
}

// @public (undocumented)
type ContourSegmentationAnnotation = ContourAnnotation & ContourSegmentationAnnotationData;

// @public (undocumented)
type ContourSegmentationAnnotationData = {
    autoGenerated?: boolean;
    interpolationUID?: string;
    interpolationCompleted?: boolean;
    data: {
        segmentation: {
            segmentationId: string;
            segmentIndex: number;
        };
        contour: {
            originalPolyline?: Types_2.Point3[];
        };
    };
    metadata?: {
        originalToolName?: string;
    };
    handles?: {
        interpolationSources?: Types_2.PointsManager<Types_2.Point3>[];
    };
    onInterpolationComplete?: (annotation: ContourSegmentationAnnotation) => unknown;
};

// @public (undocumented)
type ContourSegmentationData = {
    geometryIds?: string[];
    annotationUIDsMap?: Map<number, Set<string>>;
};

// @public (undocumented)
type ControlPointInfo = {
    index: number;
    point: Types_2.Point2;
};

// @public (undocumented)
function convertStackToVolumeSegmentation({ segmentationId, options, }: {
    segmentationId: string;
    options?: {
        toolGroupId: string;
        volumeId?: string;
        removeOriginal?: boolean;
    };
}): Promise<void>;

// @public (undocumented)
function convertVolumeToStackSegmentation({ segmentationId, options, }: {
    segmentationId: string;
    options?: {
        toolGroupId: string;
        newSegmentationId?: string;
        removeOriginal?: boolean;
    };
}): Promise<void>;

// @public (undocumented)
function copyPoints(points: ITouchPoints): ITouchPoints;

// @public (undocumented)
function copyPointsList(points: ITouchPoints[]): ITouchPoints[];

// @public (undocumented)
const CORNERSTONE_COLOR_LUT: number[][];

// @public (undocumented)
function createBidirectionalToolData(bidirectionalData: BidirectionalData, viewport: any): Annotation;

// @public (undocumented)
function createCameraPositionSynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
function createImageIdReferenceMap(imageIdsArray: string[], segmentationImageIds: string[]): Map<string, string>;

// @public (undocumented)
function createImageSliceSynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
function createLabelmapVolumeForViewport(input: {
    viewportId: string;
    renderingEngineId: string;
    segmentationId?: string;
    options?: {
        volumeId: string;
        scalarData: Float32Array | Uint8Array | Uint16Array | Int16Array;
        targetBuffer: {
            type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';
        };
        metadata: Types_2.Metadata;
        dimensions: Types_2.Point3;
        spacing: Types_2.Point3;
        origin: Types_2.Point3;
        direction: Types_2.Mat3;
    };
}): Promise<string>;

// @public (undocumented)
function createMergedLabelmapForIndex(labelmaps: Array<Types_2.IImageVolume>, segmentIndex?: number, volumeId?: string): Types_2.IImageVolume;

// @public (undocumented)
function createPresentationViewSynchronizer(synchronizerName: string, options?: Types_2.ViewPresentation): Synchronizer;

// @public (undocumented)
function createPresentationViewSynchronizer_2(synchronizerName: string): Synchronizer;

// @public (undocumented)
const createStackImageSynchronizer: typeof createImageSliceSynchronizer;

// @public (undocumented)
function createSynchronizer(synchronizerId: string, eventName: string, eventHandler: ISynchronizerEventHandler, options?: any): Synchronizer;

// @public (undocumented)
function createToolGroup(toolGroupId: string): ToolGroup | undefined;

// @public (undocumented)
function createVOISynchronizer(synchronizerName: string, options: VOISynchronizerOptions): Synchronizer;

// @public (undocumented)
function createZoomPanSynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
export class CrosshairsTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => CrosshairsAnnotation;
    // (undocumented)
    _applyDeltaShiftToSelectedViewportCameras(renderingEngine: any, viewportsAnnotationsToUpdate: any, delta: any): void;
    // (undocumented)
    _applyDeltaShiftToViewportCamera(renderingEngine: Types_2.IRenderingEngine, annotation: any, delta: any): void;
    // (undocumented)
    _areViewportIdArraysEqual: (viewportIdArrayOne: any, viewportIdArrayTwo: any) => boolean;
    // (undocumented)
    _autoPanViewportIfNecessary(viewportId: string, renderingEngine: Types_2.IRenderingEngine): void;
    // (undocumented)
    cancel: () => void;
    // (undocumented)
    _checkIfViewportsRenderingSameScene: (viewport: any, otherViewport: any) => boolean;
    // (undocumented)
    computeToolCenter: (viewportsInfo: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _filterAnnotationsByUniqueViewportOrientations: (enabledElement: any, annotations: any) => any[];
    // (undocumented)
    filterInteractableAnnotationsForElement: (element: any, annotations: any) => any;
    // (undocumented)
    _filterViewportWithSameOrientation: (enabledElement: any, referenceAnnotation: any, annotations: any) => any;
    // (undocumented)
    _getAnnotations: (enabledElement: Types_2.IEnabledElement) => Annotation[];
    // (undocumented)
    _getAnnotationsForViewportsWithDifferentCameras: (enabledElement: any, annotations: any) => any;
    // (undocumented)
    getHandleNearImagePoint(element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    _getReferenceLineColor?: (viewportId: string) => string;
    // (undocumented)
    _getReferenceLineControllable?: (viewportId: string) => boolean;
    // (undocumented)
    _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;
    // (undocumented)
    _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;
    // (undocumented)
    _getRotationHandleNearImagePoint(viewport: any, annotation: any, canvasCoords: any, proximity: any): any;
    // (undocumented)
    _getSlabThicknessHandleNearImagePoint(viewport: any, annotation: any, canvasCoords: any, proximity: any): any;
    // (undocumented)
    _getViewportsInfo: () => any[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: Annotation) => void;
    // (undocumented)
    initializeViewport: ({ renderingEngineId, viewportId, }: Types_2.IViewportId) => {
        normal: Types_2.Point3;
        point: Types_2.Point3;
    };
    // (undocumented)
    _isClockWise(a: any, b: any, c: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: CrosshairsAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    _jump: (enabledElement: any, jumpWorld: any) => boolean;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.MouseMoveEventType, filteredToolAnnotations: Annotations) => boolean;
    // (undocumented)
    onCameraModified: (evt: any) => void;
    // (undocumented)
    _onNewVolume: (e: any) => void;
    // (undocumented)
    onSetToolActive(): void;
    // (undocumented)
    onSetToolDisabled(): void;
    // (undocumented)
    onSetToolEnabled(): void;
    // (undocumented)
    onSetToolPassive(): void;
    // (undocumented)
    _pointNearReferenceLine: (annotation: any, canvasCoords: any, proximity: any, lineViewport: any) => boolean;
    // (undocumented)
    _pointNearTool(element: any, annotation: any, canvasCoords: any, proximity: any): boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    resetCrosshairs: () => void;
    // (undocumented)
    setSlabThickness(viewport: any, slabThickness: any): void;
    // (undocumented)
    _subscribeToViewportNewVolumeSet(viewports: any): void;
    // (undocumented)
    toolCenter: Types_2.Point3;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: Annotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    _unsubscribeToViewportNewVolumeSet(viewportsInfo: any): void;
}

// @public (undocumented)
const CursorNames: string[];

declare namespace cursors {
    export {
        MouseCursor,
        ImageMouseCursor,
        SVGMouseCursor,
        elementCursor,
        registerCursor,
        CursorNames,
        CursorSVG,
        setCursorForElement
    }
}
export { cursors }

// @public (undocumented)
const CursorSVG: Record<string, SVGCursorDescriptor>;

// @public (undocumented)
function debounce(func: Function, wait?: number, options?: {
    leading?: boolean;
    maxWait?: number;
    trailing?: boolean;
}): Function;

// @public (undocumented)
function decimate(polyline: Types_2.Point2[], epsilon?: number): Types_2.Point2[];

// @public (undocumented)
const _default: {
    filterAnnotationsWithinSlice: typeof filterAnnotationsWithinSlice;
    getWorldWidthAndHeightFromCorners: typeof getWorldWidthAndHeightFromCorners;
    filterAnnotationsForDisplay: typeof filterAnnotationsForDisplay;
    getPointInLineOfSightWithCriteria: typeof getPointInLineOfSightWithCriteria;
    isPlaneIntersectingAABB: (origin: any, normal: any, minX: any, minY: any, minZ: any, maxX: any, maxY: any, maxZ: any) => boolean;
};

// @public (undocumented)
const _default_2: {
    findContours: typeof findContours;
    findContoursFromReducedSet: typeof findContoursFromReducedSet;
};

// @public (undocumented)
const _default_3: {
    processContourHoles: typeof processContourHoles;
};

// @public (undocumented)
const _default_4: {
    smoothAnnotation: typeof smoothAnnotation;
};

// @public (undocumented)
function deselectAnnotation(annotationUID?: string): void;

// @public (undocumented)
export function destroy(): void;

// @public (undocumented)
function destroy_2(): void;

// @public (undocumented)
function destroy_3(): void;

// @public (undocumented)
function destroySynchronizer(synchronizerId: string): void;

// @public (undocumented)
function destroyToolGroup(toolGroupId: string): void;

// @public (undocumented)
function distanceToPoint(aabb: Types_2.AABB2, point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPoint_2(lineStart: Types_2.Point2, lineEnd: Types_2.Point2, point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPoint_3(p1: Point, p2: Point): number;

// @public (undocumented)
function distanceToPoint_4(rect: number[], point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPointSquared(aabb: Types_2.AABB2, point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPointSquared_2(lineStart: Types_2.Point2, lineEnd: Types_2.Point2, point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPointSquared_3(p1: Point_2, p2: Point_2): number;

// @public (undocumented)
function distanceToPointSquaredInfo(lineStart: Types_2.Point2, lineEnd: Types_2.Point2, point: Types_2.Point2): {
    point: Types_2.Point2;
    distanceSquared: number;
};

// @public (undocumented)
export class DragProbeTool extends ProbeTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        newAnnotation?: boolean;
    } | null;
    // (undocumented)
    eventDispatchDetail: {
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    postMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => ProbeAnnotation;
    // (undocumented)
    postTouchStartCallback: (evt: EventTypes_2.InteractionEventType) => ProbeAnnotation;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function draw(element: HTMLDivElement, fn: (svgDrawingElement: any) => any): void;

// @public (undocumented)
function drawArrow(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, arrowUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}): void;

// @public (undocumented)
function drawCircle(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, circleUID: string, center: Types_2.Point2, radius: number, options?: {}, dataId?: string): void;

// @public (undocumented)
function drawEllipse(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, ellipseUID: string, corner1: Types_2.Point2, corner2: Types_2.Point2, options?: {}, dataId?: string): void;

// @public (undocumented)
function drawEllipseByCoordinates(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, ellipseUID: string, canvasCoordinates: [Types_2.Point2, Types_2.Point2, Types_2.Point2, Types_2.Point2], options?: {}, dataId?: string): void;

// @public (undocumented)
function drawHandle(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, handleGroupUID: string, handle: Types_2.Point2, options: {}, uniqueIndex: any): void;

// @public (undocumented)
function drawHandles(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, handleGroupUID: string, handlePoints: Array<Types_2.Point2>, options?: {}): void;

declare namespace drawing {
    export {
        draw,
        drawCircle,
        drawEllipse,
        drawEllipseByCoordinates,
        drawHandles,
        drawHandle,
        drawLine,
        drawPolyline,
        drawPath,
        drawLinkedTextBox,
        drawRect,
        drawTextBox,
        drawArrow,
        drawRedactionRect,
        setAttributesIfNecessary,
        setNewAttributesIfValid
    }
}
export { drawing }

declare namespace drawing_2 {
    export {
        getTextBoxCoordsCanvas
    }
}

// @public (undocumented)
function drawLine(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, lineUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}, dataId?: string): void;

// @public (undocumented)
function drawLinkedTextBox(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, textBoxUID: string, textLines: Array<string>, textBoxPosition: Types_2.Point2, annotationAnchorPoints: Array<Types_2.Point2>, textBox: unknown, options?: {}): SVGRect;

// @public (undocumented)
function drawPath(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, pathUID: string, points: Types_2.Point2[] | Types_2.Point2[][], options: {
    color?: string;
    fillColor?: string;
    fillOpacity?: number;
    width?: number;
    lineWidth?: number;
    lineDash?: string;
    closePath?: boolean;
}): void;

// @public (undocumented)
function drawPolyline(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, polylineUID: string, points: Types_2.Point2[], options: {
    color?: string;
    fillColor?: string;
    fillOpacity?: number;
    width?: number;
    lineWidth?: number;
    lineDash?: string;
    closePath?: boolean;
}): void;

// @public (undocumented)
function drawRect(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, rectangleUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}, dataId?: string): void;

// @public (undocumented)
function drawRedactionRect(svgDrawingHelper: any, annotationUID: string, rectangleUID: string, start: any, end: any, options?: {}): void;

// @public (undocumented)
function drawTextBox(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, textUID: string, textLines: Array<string>, position: Types_2.Point2, options?: {}): SVGRect;

declare namespace dynamicVolume {
    export {
        getDataInTime,
        generateImageFromTimeData
    }
}

declare namespace elementCursor {
    export {
        initElementCursor,
        resetElementCursor,
        hideElementCursor,
        _setElementCursor as setElementCursor
    }
}

declare namespace ellipse {
    export {
        pointInEllipse,
        precalculatePointInEllipse,
        getCanvasEllipseCorners
    }
}

// @public (undocumented)
interface EllipticalROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: [Types_2.Point3, Types_2.Point3, Types_2.Point3, Types_2.Point3];
            activeHandleIndex: number | null;
            textBox?: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats?: ROICachedStats;
        initialRotation: number;
    };
}

// @public (undocumented)
export class EllipticalROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => EllipticalROIAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewport: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragDrawCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragHandle: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        movingTextBox?: boolean;
        centerWorld?: Array<number>;
        canvasWidth?: number;
        canvasHeight?: number;
        originalHandleCanvas?: Array<number>;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getCanvasEllipseCenter(ellipseCanvasPoints: Types_2.Point2[]): Types_2.Point2;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: EllipticalROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: EllipticalROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _pointInEllipseCanvas(ellipse: any, location: Types_2.Point2): boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: EllipticalROIAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace Enums {
    export {
        MouseBindings,
        KeyboardBindings,
        ToolModes,
        AnnotationStyleStates,
        Events,
        SegmentationRepresentations,
        Swipe,
        StrategyCallbacks,
        ChangeTypes,
        ChangeTypes_2 as WorkerTypes
    }
}
export { Enums }

declare namespace Enums_2 {
    export {
        ColorbarRangeTextPosition
    }
}

// @public (undocumented)
export class EraserTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _deleteNearbyAnnotations(evt: EventTypes_2.InteractionEventType, interactionType: string): boolean;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    preTouchStartCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
enum Events {
    // (undocumented)
    ANNOTATION_ADDED = "CORNERSTONE_TOOLS_ANNOTATION_ADDED",
    // (undocumented)
    ANNOTATION_COMPLETED = "CORNERSTONE_TOOLS_ANNOTATION_COMPLETED",
    // (undocumented)
    ANNOTATION_INTERPOLATION_PROCESS_COMPLETED = "CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED",
    // (undocumented)
    ANNOTATION_LOCK_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE",
    // (undocumented)
    ANNOTATION_MODIFIED = "CORNERSTONE_TOOLS_ANNOTATION_MODIFIED",
    // (undocumented)
    ANNOTATION_REMOVED = "CORNERSTONE_TOOLS_ANNOTATION_REMOVED",
    // (undocumented)
    ANNOTATION_RENDERED = "CORNERSTONE_TOOLS_ANNOTATION_RENDERED",
    // (undocumented)
    ANNOTATION_SELECTION_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE",
    // (undocumented)
    ANNOTATION_VISIBILITY_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE",
    // (undocumented)
    INTERPOLATED_ANNOTATIONS_REMOVED = "CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED",
    // (undocumented)
    KEY_DOWN = "CORNERSTONE_TOOLS_KEY_DOWN",
    // (undocumented)
    KEY_UP = "CORNERSTONE_TOOLS_KEY_UP",
    // (undocumented)
    MOUSE_CLICK = "CORNERSTONE_TOOLS_MOUSE_CLICK",
    // (undocumented)
    MOUSE_DOUBLE_CLICK = "CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK",
    // (undocumented)
    MOUSE_DOWN = "CORNERSTONE_TOOLS_MOUSE_DOWN",
    // (undocumented)
    MOUSE_DOWN_ACTIVATE = "CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE",
    // (undocumented)
    MOUSE_DRAG = "CORNERSTONE_TOOLS_MOUSE_DRAG",
    // (undocumented)
    MOUSE_MOVE = "CORNERSTONE_TOOLS_MOUSE_MOVE",
    // (undocumented)
    MOUSE_UP = "CORNERSTONE_TOOLS_MOUSE_UP",
    // (undocumented)
    MOUSE_WHEEL = "CORNERSTONE_TOOLS_MOUSE_WHEEL",
    // (undocumented)
    SEGMENTATION_DATA_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED",
    // (undocumented)
    SEGMENTATION_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED",
    // (undocumented)
    SEGMENTATION_REMOVED = "CORNERSTONE_TOOLS_SEGMENTATION_REMOVED",
    // (undocumented)
    SEGMENTATION_RENDERED = "CORNERSTONE_TOOLS_SEGMENTATION_RENDERED",
    // (undocumented)
    SEGMENTATION_REPRESENTATION_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED",
    // (undocumented)
    SEGMENTATION_REPRESENTATION_REMOVED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED",
    // (undocumented)
    TOOL_ACTIVATED = "CORNERSTONE_TOOLS_TOOL_ACTIVATED",
    // (undocumented)
    TOOL_MODE_CHANGED = "CORNERSTONE_TOOLS_TOOL_MODE_CHANGED",
    // (undocumented)
    TOUCH_DRAG = "CORNERSTONE_TOOLS_TOUCH_DRAG",
    // (undocumented)
    TOUCH_END = "CORNERSTONE_TOOLS_TOUCH_END",
    // (undocumented)
    TOUCH_PRESS = "CORNERSTONE_TOOLS_TOUCH_PRESS",
    // (undocumented)
    TOUCH_START = "CORNERSTONE_TOOLS_TOUCH_START",
    // (undocumented)
    TOUCH_START_ACTIVATE = "CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE",
    // (undocumented)
    TOUCH_SWIPE = "CORNERSTONE_TOOLS_SWIPE",
    // (undocumented)
    TOUCH_TAP = "CORNERSTONE_TOOLS_TAP"
}

// @public (undocumented)
enum Events_2 {
    // (undocumented)
    CLIP_STARTED = "CORNERSTONE_CINE_TOOL_STARTED",
    // (undocumented)
    CLIP_STOPPED = "CORNERSTONE_CINE_TOOL_STOPPED"
}

declare namespace EventTypes_2 {
    export {
        InteractionStartType,
        InteractionEndType,
        InteractionEventType,
        NormalizedInteractionEventDetail,
        NormalizedMouseEventType,
        NormalizedTouchEventType,
        ToolModeChangedEventDetail,
        ToolModeChangedEventType,
        ToolActivatedEventDetail,
        ToolActivatedEventType,
        AnnotationAddedEventDetail,
        AnnotationAddedEventType,
        AnnotationCompletedEventDetail,
        AnnotationCompletedEventType,
        AnnotationModifiedEventDetail,
        AnnotationModifiedEventType,
        AnnotationRemovedEventDetail,
        AnnotationRemovedEventType,
        AnnotationSelectionChangeEventDetail,
        AnnotationSelectionChangeEventType,
        AnnotationRenderedEventDetail,
        AnnotationRenderedEventType,
        AnnotationLockChangeEventDetail,
        AnnotationVisibilityChangeEventDetail,
        AnnotationLockChangeEventType,
        AnnotationVisibilityChangeEventType,
        AnnotationInterpolationCompletedEventDetail,
        AnnotationInterpolationCompletedEventType,
        AnnotationInterpolationRemovedEventDetail,
        AnnotationInterpolationRemovedEventType,
        ContourAnnotationCompletedEventDetail,
        SegmentationDataModifiedEventType,
        SegmentationRepresentationModifiedEventDetail,
        SegmentationRepresentationModifiedEventType,
        SegmentationRepresentationRemovedEventDetail,
        SegmentationRepresentationRemovedEventType,
        SegmentationRemovedEventType,
        SegmentationRemovedEventDetail,
        SegmentationDataModifiedEventDetail,
        SegmentationRenderedEventType,
        SegmentationRenderedEventDetail,
        SegmentationModifiedEventType,
        SegmentationModifiedEventDetail,
        KeyDownEventDetail,
        KeyDownEventType,
        KeyUpEventDetail,
        KeyUpEventType,
        MouseDownEventDetail,
        TouchStartEventDetail,
        MouseDownEventType,
        TouchStartEventType,
        MouseDownActivateEventDetail,
        TouchStartActivateEventDetail,
        MouseDownActivateEventType,
        TouchStartActivateEventType,
        MouseDragEventDetail,
        TouchDragEventDetail,
        MouseDragEventType,
        TouchDragEventType,
        MouseUpEventDetail,
        TouchEndEventDetail,
        MouseUpEventType,
        TouchEndEventType,
        MouseClickEventDetail,
        MouseClickEventType,
        TouchTapEventDetail,
        TouchTapEventType,
        TouchSwipeEventDetail,
        TouchSwipeEventType,
        TouchPressEventDetail,
        TouchPressEventType,
        MouseMoveEventDetail,
        MouseMoveEventType,
        MouseDoubleClickEventDetail,
        MouseDoubleClickEventType,
        MouseWheelEventDetail,
        MouseWheelEventType,
        VolumeScrollOutOfBoundsEventDetail,
        VolumeScrollOutOfBoundsEventType
    }
}

// @public (undocumented)
function extend2DBoundingBoxInViewAxis(boundsIJK: [Types_2.Point2, Types_2.Point2, Types_2.Point2], numSlicesToProject: number): [Types_2.Point2, Types_2.Point2, Types_2.Point2];

// @public (undocumented)
function filterAnnotationsForDisplay(viewport: Types_2.IViewport, annotations: Annotations, filterOptions?: Types_2.ReferenceCompatibleOptions): Annotations;

// @public (undocumented)
function filterAnnotationsWithinSlice(annotations: Annotations, camera: Types_2.ICamera, spacingInNormalDirection: number): Annotations;

// @public (undocumented)
function filterViewportsWithFrameOfReferenceUID(viewports: Array<Types_2.IViewport>, FrameOfReferenceUID: string): Array<Types_2.IStackViewport | Types_2.IVolumeViewport>;

// @public (undocumented)
function filterViewportsWithParallelNormals(viewports: any, camera: any, EPS?: number): any;

// @public (undocumented)
function filterViewportsWithToolEnabled(viewports: Array<Types_2.IViewport>, toolName: string): Array<Types_2.IStackViewport | Types_2.IVolumeViewport>;

// @public (undocumented)
function findClosestPoint(sourcePoints: Array<Types_2.Point2>, targetPoint: Types_2.Point2): Types_2.Point2;

// @public (undocumented)
function findHandlePolylineIndex(annotation: ContourAnnotation, handleIndex: number): number;

// @public (undocumented)
function findSegmentationRepresentationByUID(segmentationRepresentationUID: string): {
    toolGroupId: string;
    segmentationRepresentation: ToolGroupSpecificRepresentation;
};

// @public (undocumented)
function floodFill(getter: FloodFillGetter, seed: Types_2.Point2 | Types_2.Point3, options?: FloodFillOptions): FloodFillResult;

// @public (undocumented)
type FloodFillGetter = FloodFillGetter2D | FloodFillGetter3D;

// @public (undocumented)
type FloodFillOptions = {
    onFlood?: (x: number, y: number, z?: number) => void;
    onBoundary?: (x: number, y: number, z?: number) => void;
    equals?: (a: any, b: any) => boolean;
    diagonals?: boolean;
};

// @public (undocumented)
type FloodFillResult = {
    flooded: Types_2.Point2[] | Types_2.Point3[];
    boundaries: Types_2.Point2[] | Types_2.Point3[];
};

// @public (undocumented)
class FrameOfReferenceSpecificAnnotationManager implements IAnnotationManager {
    constructor(uid?: string);
    // (undocumented)
    addAnnotation: (annotation: Annotation, groupKey?: string) => void;
    // (undocumented)
    getAllAnnotations: () => Annotations;
    // (undocumented)
    getAnnotation: (annotationUID: string) => Annotation | undefined;
    // (undocumented)
    getAnnotations: (groupKey: string, toolName?: string) => GroupSpecificAnnotations | Annotations;
    // (undocumented)
    getFramesOfReference: () => Array<string>;
    // (undocumented)
    getGroupKey: (annotationGroupSelector: AnnotationGroupSelector) => string;
    // (undocumented)
    getNumberOfAllAnnotations: () => number;
    // (undocumented)
    getNumberOfAnnotations: (groupKey: string, toolName?: string) => number;
    // (undocumented)
    _imageVolumeModifiedHandler: (evt: Types_2.EventTypes.ImageVolumeModifiedEvent) => void;
    // (undocumented)
    removeAllAnnotations: () => void;
    // (undocumented)
    removeAnnotation: (annotationUID: string) => void;
    // (undocumented)
    removeAnnotations: (groupKey: string, toolName?: string) => void;
    // (undocumented)
    restoreAnnotations: (state: AnnotationState | GroupSpecificAnnotations | Annotations, groupKey?: string, toolName?: string) => void;
    // (undocumented)
    saveAnnotations: (groupKey?: string, toolName?: string) => AnnotationState | GroupSpecificAnnotations | Annotations;
    // (undocumented)
    readonly uid: string;
}

// @public (undocumented)
function generateContourSetsFromLabelmap({ segmentations }: {
    segmentations: any;
}): any[];

// @public (undocumented)
function generateImageFromTimeData(dynamicVolume: Types_2.IDynamicImageVolume, operation: string, frameNumbers?: number[]): Float32Array;

// @public (undocumented)
function getAABB(polyline: Types_2.Point2[] | Types_2.Point3[] | number[], options?: {
    numDimensions: number;
}): Types_2.AABB2 | Types_2.AABB3;

// @public (undocumented)
function getActiveSegmentation(toolGroupId: string): Segmentation;

// @public (undocumented)
function getActiveSegmentationRepresentation(toolGroupId: string): ToolGroupSpecificRepresentation;

// @public (undocumented)
function getActiveSegmentIndex(segmentationId: string): number | undefined;

// @public (undocumented)
function getAllAnnotations(): Annotations;

// @public (undocumented)
function getAllSegmentationRepresentations(): Record<string, ToolGroupSpecificRepresentation[]>;

// @public (undocumented)
function getAllSynchronizers(): Array<Synchronizer>;

// @public (undocumented)
function getAllToolGroups(): Array<ToolGroup>;

// @public (undocumented)
function getAnnotation(annotationUID: string): Annotation;

// @public (undocumented)
function getAnnotationManager(): FrameOfReferenceSpecificAnnotationManager;

// @public (undocumented)
function getAnnotationNearPoint(element: HTMLDivElement, canvasPoint: Types_2.Point2, proximity?: number): Annotation | null;

// @public (undocumented)
function getAnnotationNearPointOnEnabledElement(enabledElement: Types_2.IEnabledElement, point: Types_2.Point2, proximity: number): Annotation | null;

// @public (undocumented)
function getAnnotations(toolName: string, annotationGroupSelector: AnnotationGroupSelector): Annotations;

// @public (undocumented)
function getAnnotationsLocked(): Array<Annotation>;

// @public (undocumented)
function getAnnotationsLockedCount(): number;

// @public (undocumented)
function getAnnotationsSelected(): Array<string>;

// @public (undocumented)
function getAnnotationsSelectedByToolName(toolName: string): Array<string>;

// @public (undocumented)
function getAnnotationsSelectedCount(): number;

// @public (undocumented)
function getArea(points: Types_2.Point2[]): number;

// @public (undocumented)
function getBoundingBoxAroundShapeIJK(points: Types_2.Point2[] | Types_2.Point3[], dimensions?: Types_2.Point2 | Types_2.Point3): BoundingBox;

// @public (undocumented)
function getBoundingBoxAroundShapeWorld(points: Types_2.Point2[] | Types_2.Point3[], clipBounds?: Types_2.Point2 | Types_2.Point3): BoundingBox;

// @public (undocumented)
function getBoundsIJKFromRectangleAnnotations(annotations: any, referenceVolume: any, options?: Options_3): any;

// @public (undocumented)
function getBrushSizeForToolGroup(toolGroupId: string, toolName?: string): void;

// @public (undocumented)
function getBrushThresholdForToolGroup(toolGroupId: string): any;

// @public (undocumented)
function getBrushToolInstances(toolGroupId: string, toolName?: string): any[];

// @public (undocumented)
const getCalibratedAreaUnits: (handles: any, image: any) => string;

// @public (undocumented)
const getCalibratedLengthUnits: (handles: any, image: any) => string;

// @public (undocumented)
const getCalibratedScale: (image: any, handles?: any[]) => any;

// @public (undocumented)
function getCanvasEllipseCorners(ellipseCanvasPoints: CanvasCoordinates): Array<Types_2.Point2>;

// @public (undocumented)
function getChildAnnotations(annotation: Annotation): Annotation[];

// @public (undocumented)
function getClosestLineSegmentIntersection(points: Types_2.Point2[], p1: Types_2.Point2, q1: Types_2.Point2, closed?: boolean): {
    segment: Types_2.Point2;
    distance: number;
} | undefined;

// @public (undocumented)
function getColorForSegmentIndex(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number): Types_2.Color;

// @public (undocumented)
function getColorLUT(index: number): Types_2.ColorLUT | undefined;

// @public (undocumented)
function getContourHolesDataCanvas(annotation: Annotation, viewport: Types_2.IViewport): Types_2.Point2[][];

// @public (undocumented)
function getContourHolesDataWorld(annotation: Annotation): Types_2.Point3[][];

// @public (undocumented)
function getDataInTime(dynamicVolume: Types_2.IDynamicImageVolume, options: {
    frameNumbers?: any;
    maskVolumeId?: any;
    imageCoordinate?: any;
}): number[] | number[][];

// @public (undocumented)
function getDeduplicatedVTKPolyDataPoints(polyData: any, bypass?: boolean): {
    points: any[];
    lines: {
        a: any;
        b: any;
    }[];
};

// @public (undocumented)
function getDefaultRepresentationConfig(segmentation: Segmentation): LabelmapConfig;

// @public (undocumented)
function getDefaultSegmentationStateManager(): SegmentationStateManager;

// @public (undocumented)
function getDeltaDistance(currentPoints: IPoints[], lastPoints: IPoints[]): IDistance;

// @public (undocumented)
function getDeltaDistanceBetweenIPoints(currentPoints: IPoints[], lastPoints: IPoints[]): IDistance;

// @public (undocumented)
function getDeltaPoints(currentPoints: IPoints[], lastPoints: IPoints[]): IPoints;

// @public (undocumented)
function getDeltaRotation(currentPoints: ITouchPoints[], lastPoints: ITouchPoints[]): void;

// @public (undocumented)
function getFirstLineSegmentIntersectionIndexes(points: Types_2.Point2[], p1: Types_2.Point2, q1: Types_2.Point2, closed?: boolean): Types_2.Point2 | undefined;

// @public (undocumented)
function getFont(styleSpecifier: StyleSpecifier, state?: AnnotationStyleStates, mode?: ToolModes): string;

// @public (undocumented)
function getGlobalConfig(): SegmentationRepresentationConfig;

// @public (undocumented)
function getGlobalConfig_2(): SegmentationRepresentationConfig;

// @public (undocumented)
function getGlobalRepresentationConfig(representationType: SegmentationRepresentations): RepresentationConfig['LABELMAP'];

// @public (undocumented)
function getHoveredContourSegmentationAnnotation(segmentationId: any): number;

// @public (undocumented)
function getLineSegmentIntersectionsCoordinates(points: Types_2.Point2[], p1: Types_2.Point2, q1: Types_2.Point2, closed?: boolean): Types_2.Point2[];

// @public (undocumented)
function getLineSegmentIntersectionsIndexes(polyline: Types_2.Point2[], p1: Types_2.Point2, q1: Types_2.Point2, closed?: boolean): Types_2.Point2[];

// @public (undocumented)
function getLockedSegments(segmentationId: string): number[] | [];

// @public (undocumented)
function getMeanPoints(points: IPoints[]): IPoints;

// @public (undocumented)
function getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints;

// @public (undocumented)
function getNextColorLUTIndex(): number;

// @public (undocumented)
function getNormal2(polyline: Types_2.Point2[]): Types_2.Point3;

// @public (undocumented)
function getNormal3(polyline: Types_2.Point3[]): Types_2.Point3;

// @public (undocumented)
function getNumberOfAnnotations(toolName: string, annotationGroupSelector: AnnotationGroupSelector): number;

// @public (undocumented)
function getOrientationStringLPS(vector: Types_2.Point3): string;

// @public (undocumented)
function getParentAnnotation(annotation: Annotation): Annotation;

// @public (undocumented)
function getPoint(points: any, idx: any): Types_2.Point3;

// @public (undocumented)
function getPointInLineOfSightWithCriteria(viewport: Types_2.IVolumeViewport, worldPos: Types_2.Point3, targetVolumeId: string, criteriaFunction: (intensity: number, point: Types_2.Point3) => Types_2.Point3, stepSize?: number): Types_2.Point3;

// @public (undocumented)
function getPolyDataPointIndexes(polyData: vtkPolyData): any[];

// @public (undocumented)
function getPolyDataPoints(polyData: vtkPolyData): any[];

// @public (undocumented)
function getSegmentation(segmentationId: string): Segmentation | undefined;

// @public (undocumented)
function getSegmentationIdRepresentations(segmentationId: any): any[];

// @public (undocumented)
function getSegmentationRepresentationByUID(toolGroupId: string, segmentationRepresentationUID: string): ToolGroupSpecificRepresentation | undefined;

// @public (undocumented)
function getSegmentationRepresentations(toolGroupId: string): ToolGroupSpecificRepresentations | [];

// @public (undocumented)
function getSegmentationRepresentationSpecificConfig(toolGroupId: string, segmentationRepresentationUID: string): RepresentationConfig;

// @public (undocumented)
function getSegmentationRepresentationSpecificConfig_2(toolGroupId: string, segmentationRepresentationUID: string): RepresentationConfig;

// @public (undocumented)
function getSegmentations(): Segmentation[] | [];

// @public (undocumented)
function getSegmentationVisibility(toolGroupId: string, segmentationRepresentationUID: string): boolean | undefined;

// @public (undocumented)
function getSegmentAtLabelmapBorder(segmentationId: string, worldPoint: Types_2.Point3, { viewport, searchRadius }: Options_2): number;

// @public (undocumented)
function getSegmentAtWorldPoint(segmentationId: string, worldPoint: Types_2.Point3, options?: Options): number;

// @public (undocumented)
function getSegmentSpecificConfig(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number): RepresentationConfig;

// @public (undocumented)
function getSegmentSpecificRepresentationConfig(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number): RepresentationConfig;

// @public (undocumented)
function getSegmentVisibility(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number): boolean;

// @public (undocumented)
function getSignedArea(polyline: Types_2.Point2[]): number;

// @public (undocumented)
function getSphereBoundsInfo(circlePoints: [Types_2.Point3, Types_2.Point3], imageData: vtkImageData, viewport: any): {
    boundsIJK: BoundsIJK_2;
    centerWorld: Types_2.Point3;
    radiusWorld: number;
    topLeftWorld: Types_2.Point3;
    bottomRightWorld: Types_2.Point3;
};

// @public (undocumented)
function getState(annotation?: Annotation): AnnotationStyleStates;

// @public (undocumented)
const getSubPixelSpacingAndXYDirections: (viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, subPixelResolution: number) => {
    spacing: Types_2.Point2;
    xDir: Types_2.Point3;
    yDir: Types_2.Point3;
};

// @public (undocumented)
function getSynchronizer(synchronizerId: string): Synchronizer | void;

// @public (undocumented)
function getSynchronizersForViewport(viewportId: string, renderingEngineId: string): Array<Synchronizer>;

// @public (undocumented)
function getTextBoxCoordsCanvas(annotationCanvasPoints: Array<Types_2.Point2>): Types_2.Point2;

// @public (undocumented)
function getToolGroup(toolGroupId: string): ToolGroup | undefined;

// @public (undocumented)
function getToolGroupForViewport(viewportId: string, renderingEngineId?: string): ToolGroup | undefined;

// @public (undocumented)
function getToolGroupIdFromSegmentationRepresentationUID(segmentationRepresentationUID: string): string;

// @public (undocumented)
function getToolGroupIdsWithSegmentation(segmentationId: string): string[];

// @public (undocumented)
function getToolGroupSpecificConfig(toolGroupId: string): SegmentationRepresentationConfig;

// @public (undocumented)
function getToolGroupSpecificConfig_2(toolGroupId: string): SegmentationRepresentationConfig;

// @public (undocumented)
function getToolGroupsWithToolName(toolName: string): ToolGroup[] | [];

// @public (undocumented)
function getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined;

// @public (undocumented)
function getUniqueSegmentIndices(segmentationId: any): any;

// @public (undocumented)
function getViewportForAnnotation(annotation: Annotation): IVolumeViewport_2 | IStackViewport_2;

// @public (undocumented)
function getViewportIdsWithToolToRender(element: HTMLDivElement, toolName: string, requireParallelNormals?: boolean): string[];

// @public (undocumented)
function getWindingDirection(polyline: Types_2.Point2[]): number;

// @public (undocumented)
function getWorldWidthAndHeightFromCorners(viewPlaneNormal: Types_2.Point3, viewUp: Types_2.Point3, topLeftWorld: Types_2.Point3, bottomRightWorld: Types_2.Point3): {
    worldWidth: number;
    worldHeight: number;
};

// @public (undocumented)
type GroupSpecificAnnotations = {
    [toolName: string]: Annotations;
};

// @public (undocumented)
function hideElementCursor(element: HTMLDivElement): void;

// @public (undocumented)
interface IAnnotationManager {
    // (undocumented)
    addAnnotation: (annotation: Annotation, groupKey: string) => void;
    // (undocumented)
    getAnnotation: (annotationUID: string) => Annotation;
    // (undocumented)
    getAnnotations: (groupKey: string, toolName?: string) => GroupSpecificAnnotations | Annotations;
    // (undocumented)
    getGroupKey: (annotationGroupSelector: AnnotationGroupSelector) => string;
    // (undocumented)
    getNumberOfAllAnnotations: () => number;
    // (undocumented)
    getNumberOfAnnotations: (groupKey: string, toolName?: string) => number;
    // (undocumented)
    removeAllAnnotations: () => void;
    // (undocumented)
    removeAnnotation: (annotationUID: string) => void;
    // (undocumented)
    removeAnnotations: (groupKey: string) => void;
}

// @public (undocumented)
type IDistance = {
    page: number;
    client: number;
    canvas: number;
    world: number;
};

// @public (undocumented)
type ImageInterpolationData = {
    sliceIndex: number;
    annotations?: Annotation[];
};

// @public (undocumented)
class ImageMouseCursor extends MouseCursor {
    constructor(url: string, x?: number, y?: number, name?: string | undefined, fallback?: MouseCursor | undefined);
    // (undocumented)
    getStyleProperty(): string;
    // (undocumented)
    static getUniqueInstanceName(prefix: string): string;
}

// @public (undocumented)
export function init(defaultConfiguration?: {}): void;

// @public (undocumented)
function initElementCursor(element: HTMLDivElement, cursor: MouseCursor | null): void;

// @public (undocumented)
type InteractionEndType = Types_2.CustomEventType<InteractionEndEventDetail>;

// @public (undocumented)
type InteractionEventType = Types_2.CustomEventType<InteractionEventDetail>;

// @public (undocumented)
type InteractionStartType = Types_2.CustomEventType<InteractionStartEventDetail>;

// @public (undocumented)
type InteractionTypes = 'Mouse' | 'Touch';

declare namespace interpolation {
    export {
        InterpolationManager
    }
}

// @public (undocumented)
class InterpolationManager {
    // (undocumented)
    static acceptAutoGenerated(annotationGroupSelector: AnnotationGroupSelector, selector?: AcceptInterpolationSelector): void;
    // (undocumented)
    static addTool(toolName: string): void;
    // (undocumented)
    static handleAnnotationCompleted: (evt: AnnotationCompletedEventType) => void;
    // (undocumented)
    static handleAnnotationDelete: (evt: AnnotationRemovedEventType) => void;
    // (undocumented)
    static handleAnnotationUpdate: (evt: AnnotationModifiedEventType) => void;
    // (undocumented)
    static toolNames: any[];
}

// @public (undocumented)
type InterpolationROIAnnotation = ContourAnnotation & ContourSegmentationAnnotationData & {
    metadata: {
        annotationUID?: string;
    };
    interpolationUID?: string;
    interpolationCompleted?: boolean;
    isInterpolationUpdate?: boolean;
};

// @public (undocumented)
type InterpolationViewportData = {
    annotation: InterpolationROIAnnotation;
    interpolationUID: string;
    viewport: Types_2.IViewport;
    sliceData: Types_2.ImageSliceData;
    isInterpolationUpdate?: boolean;
};

// @public (undocumented)
function intersectAABB(aabb1: Types_2.AABB2, aabb2: Types_2.AABB2): boolean;

// @public (undocumented)
function intersectLine(line1Start: Types_2.Point2, line1End: Types_2.Point2, line2Start: Types_2.Point2, line2End: Types_2.Point2): number[];

// @public (undocumented)
function intersectPolyline(sourcePolyline: Types_2.Point2[], targetPolyline: Types_2.Point2[]): boolean;

// @public (undocumented)
function invalidateAnnotation(annotation: Annotation): void;

// @public (undocumented)
function invalidateBrushCursor(toolGroupId: string): void;

// @public (undocumented)
function invertOrientationStringLPS(orientationString: string): string;

// @public (undocumented)
type IPoints = {
    page: Types_2.Point2;
    client: Types_2.Point2;
    canvas: Types_2.Point2;
    world: Types_2.Point3;
};

// @public (undocumented)
function isAnnotationLocked(annotation: Annotation): boolean;

// @public (undocumented)
function isAnnotationSelected(annotationUID: string): boolean;

// @public (undocumented)
function isAnnotationVisible(annotationUID: string): boolean | undefined;

// @public (undocumented)
function isAxisAlignedRectangle(rectangleCornersIJK: any): boolean;

// @public (undocumented)
function isClosed(polyline: Types_2.Point2[]): boolean;

// @public (undocumented)
function isContourSegmentationAnnotation(annotation: Annotation): annotation is ContourSegmentationAnnotation;

// @public (undocumented)
function isObject(value: any): boolean;

// @public (undocumented)
const isPlaneIntersectingAABB: (origin: any, normal: any, minX: any, minY: any, minZ: any, maxX: any, maxY: any, maxZ: any) => boolean;

// @public (undocumented)
interface ISpline {
    // (undocumented)
    get aabb(): Types_2.AABB2;
    // (undocumented)
    addControlPoint(point: Types_2.Point2): void;
    // (undocumented)
    addControlPointAtU(u: number): ControlPointInfo;
    // (undocumented)
    addControlPoints(points: Types_2.Point2[]): void;
    // (undocumented)
    clearControlPoints(): void;
    // (undocumented)
    get closed(): boolean;
    set closed(closed: boolean);
    // (undocumented)
    containsPoint(point: Types_2.Point2): boolean;
    // (undocumented)
    deleteControlPointByIndex(index: number): boolean;
    // (undocumented)
    get fixedResolution(): boolean;
    // (undocumented)
    getClosestControlPoint(point: Types_2.Point2): ClosestControlPoint;
    // (undocumented)
    getClosestControlPointWithinDistance(point: Types_2.Point2, range: number): ClosestControlPoint;
    // (undocumented)
    getClosestPoint(point: Types_2.Point2): ClosestSplinePoint;
    // (undocumented)
    getClosestPointOnControlPointLines(point: Types_2.Point2): ClosestPoint;
    // (undocumented)
    getControlPoints(): Types_2.Point2[];
    // (undocumented)
    getPolylinePoints(): Types_2.Point2[];
    // (undocumented)
    getPreviewPolylinePoints(controlPointPreview: Types_2.Point2, closeDistance: number): Types_2.Point2[];
    // (undocumented)
    hasTangentPoints(): boolean;
    // (undocumented)
    get invalidated(): boolean;
    // (undocumented)
    isPointNearCurve(point: Types_2.Point2, maxDist: number): boolean;
    // (undocumented)
    get length(): number;
    // (undocumented)
    get numControlPoints(): number;
    // (undocumented)
    get resolution(): number;
    set resolution(resolution: number);
    // (undocumented)
    setControlPoints(points: Types_2.Point2[]): void;
    // (undocumented)
    updateControlPoint(index: number, newControlPoint: Types_2.Point2): void;
}

// @public (undocumented)
function isPointInsidePolyline3D(point: Types_2.Point3, polyline: Types_2.Point3[], options?: {
    holes?: Types_2.Point3[][];
}): boolean;

// @public (undocumented)
function isPointOnLineSegment(lineStart: Types_2.Point2, lineEnd: Types_2.Point2, point: Types_2.Point2): boolean;

// @public (undocumented)
function isSegmentIndexLocked(segmentationId: string, segmentIndex: number): boolean;

// @public (undocumented)
function isValidRepresentationConfig(representationType: string, config: RepresentationConfig): boolean;

// @public (undocumented)
function isViewportPreScaled(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, targetId: string): boolean;

// @public (undocumented)
interface ISynchronizerEventHandler {
    // (undocumented)
    (synchronizer: Synchronizer, sourceViewport: Types_2.IViewportId, targetViewport: Types_2.IViewportId, sourceEvent: any, options?: any): Promise<void> | void;
}

// @public (undocumented)
type IToolBinding = {
    mouseButton?: ToolBindingMouseType;
    modifierKey?: ToolBindingKeyboardType;
    numTouchPoints?: number;
};

// @public (undocumented)
type IToolClassReference = new <T extends BaseTool>(config: any) => T;

// @public (undocumented)
type ITouchPoints = IPoints & {
    touch: {
        identifier: string;
        radiusX: number;
        radiusY: number;
        force: number;
        rotationAngle: number;
    };
};

// @public (undocumented)
function jumpToSlice(element: HTMLDivElement, options?: JumpToSliceOptions): Promise<void>;

// @public (undocumented)
type JumpToSliceOptions = {
    imageIndex: number;
    debounceLoading?: boolean;
    volumeId?: string;
};

// @public (undocumented)
function jumpToWorld(viewport: Types_2.IVolumeViewport, jumpWorld: Types_2.Point3): true | undefined;

// @public (undocumented)
enum KeyboardBindings {
    // (undocumented)
    Alt = 18,
    // (undocumented)
    AltMeta = 1891,
    // (undocumented)
    Ctrl = 17,
    // (undocumented)
    CtrlAlt = 1718,
    // (undocumented)
    CtrlMeta = 1791,
    // (undocumented)
    Meta = 91,
    // (undocumented)
    Shift = 16,
    // (undocumented)
    ShiftAlt = 1618,
    // (undocumented)
    ShiftCtrl = 1617,
    // (undocumented)
    ShiftMeta = 1691
}

// @public (undocumented)
type KeyDownEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    key: string;
    keyCode: number;
};

// @public (undocumented)
type KeyDownEventType = Types_2.CustomEventType<KeyDownEventDetail>;

// @public (undocumented)
export class KeyImageTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => Annotation;
    // (undocumented)
    cancel(): void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _doneChangingTextCallback(element: any, annotation: any, updatedText: any): void;
    // (undocumented)
    doubleClickCallback: (evt: EventTypes_2.TouchTapEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: Annotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume(index1: any, index2: any, dimensions: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: Annotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
type KeyUpEventDetail = KeyDownEventDetail;

// @public (undocumented)
type KeyUpEventType = Types_2.CustomEventType<KeyUpEventDetail>;

// @public (undocumented)
type LabelmapConfig = {
    renderOutline?: boolean;
    outlineWidthActive?: number;
    outlineWidthInactive?: number;
    activeSegmentOutlineWidthDelta?: number;
    renderFill?: boolean;
    renderFillInactive?: boolean;
    fillAlpha?: number;
    fillAlphaInactive?: number;
    outlineOpacity?: number;
    outlineOpacityInactive?: number;
};

// @public (undocumented)
type LabelmapRenderingConfig = {
    cfun?: vtkColorTransferFunction;
    ofun?: vtkPiecewiseFunction;
};

// @public (undocumented)
type LabelmapSegmentationData = LabelmapSegmentationDataVolume | LabelmapSegmentationDataStack | {
    volumeId?: string;
    referencedVolumeId?: string;
    imageIdReferenceMap?: Map<string, string>;
};

// @public (undocumented)
type LabelmapSegmentationDataStack = {
    imageIdReferenceMap: Map<string, string>;
};

// @public (undocumented)
type LabelmapSegmentationDataVolume = {
    volumeId: string;
    referencedVolumeId?: string;
};

// @public (undocumented)
type LabelmapToolOperationData = {
    segmentationId: string;
    segmentIndex: number;
    previewColors?: Record<number, [number, number, number, number]>;
    segmentsLocked: number[];
    viewPlaneNormal: number[];
    viewUp: number[];
    strategySpecificConfiguration: any;
    segmentationRepresentationUID: string;
    points: Types_2.Point3[];
    preview: any;
    toolGroupId: string;
};

// @public (undocumented)
type LabelmapToolOperationDataStack = LabelmapToolOperationData & LabelmapSegmentationDataStack;

// @public (undocumented)
type LabelmapToolOperationDataVolume = LabelmapToolOperationData & LabelmapSegmentationDataVolume;

declare namespace LabelmapTypes {
    export {
        LabelmapConfig,
        LabelmapRenderingConfig,
        LabelmapSegmentationDataVolume,
        LabelmapSegmentationDataStack,
        LabelmapSegmentationData
    }
}

// @public (undocumented)
interface LengthAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                length: number;
                unit: string;
            };
        };
    };
}

// @public (undocumented)
export class LengthTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => LengthAnnotation;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    _calculateLength(pos1: any, pos2: any): number;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: LengthAnnotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume(index1: any, index2: any, dimensions: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: LengthAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: LengthAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace lineSegment {
    export {
        distanceToPoint_2 as distanceToPoint,
        distanceToPointSquared_2 as distanceToPointSquared,
        distanceToPointSquaredInfo,
        intersectLine,
        isPointOnLineSegment
    }
}

// @public (undocumented)
type LivewireContourAnnotation = ContourAnnotation;

// @public (undocumented)
type LivewireContourSegmentationAnnotation = LivewireContourAnnotation & ContourSegmentationAnnotationData;

// @public (undocumented)
export class LivewireContourSegmentationTool extends LivewireContourTool {
    // (undocumented)
    protected isContourSegmentationTool(): boolean;
    // (undocumented)
    protected renderAnnotationInstance(renderContext: any): boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    updateInterpolatedAnnotation(annotation: ContourSegmentationAnnotation, enabledElement: Types_2.IEnabledElement): void;
}

// @public (undocumented)
export class LivewireContourTool extends ContourSegmentationBaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation(evt: EventTypes_2.InteractionEventType): LivewireContourAnnotation;
    // (undocumented)
    cancel: (element: HTMLDivElement) => string;
    // (undocumented)
    protected clearEditData(): void;
    // (undocumented)
    protected createAnnotation(evt: EventTypes_2.InteractionEventType): ContourAnnotation;
    // (undocumented)
    editData: {
        annotation: LivewireContourAnnotation;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        lastCanvasPoint?: Types_2.Point2;
        confirmedPath?: LivewirePath;
        currentPath?: LivewirePath;
        confirmedPathRight?: LivewirePath;
        closed?: boolean;
        worldToSlice?: (point: Types_2.Point3) => Types_2.Point2;
        sliceToWorld?: (point: Types_2.Point2) => Types_2.Point3;
        originalPath?: Types_2.Point3[];
        contourHoleProcessingEnabled?: boolean;
    } | null;
    // (undocumented)
    editHandle(worldPos: Types_2.Point3, element: any, annotation: any, handleIndex: number): void;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType, clearAnnotation?: boolean) => void;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: LivewireContourAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    protected isContourSegmentationTool(): boolean;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: LivewireContourAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): boolean;
    // (undocumented)
    protected renderAnnotationInstance(renderContext: {
        enabledElement: Types_2.IEnabledElement;
        targetId: string;
        annotation: LivewireContourAnnotation;
        annotationStyle: Record<string, any>;
        svgDrawingHelper: SVGDrawingHelper;
    }): boolean;
    // (undocumented)
    protected scissors: LivewireScissors;
    // (undocumented)
    protected scissorsRight: LivewireScissors;
    // (undocumented)
    protected setupBaseEditData(worldPos: any, element: any, annotation: any, rightPos?: any, contourHoleProcessingEnabled?: any): void;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: LivewireContourAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
    // (undocumented)
    triggerChangeEvent: (annotation: LivewireContourAnnotation, enabledElement: Types_2.IEnabledElement, changeType?: ChangeTypes, contourHoleProcessingEnabled?: boolean) => void;
    // (undocumented)
    undo(element: any, config: any, evt: any): void;
    // (undocumented)
    protected updateAnnotation(livewirePath: LivewirePath): void;
}

declare namespace locking {
    export {
        setAnnotationLocked,
        getAnnotationsLocked,
        getAnnotationsLockedCount,
        unlockAllAnnotations,
        isAnnotationLocked,
        checkAndDefineIsLockedProperty
    }
}

// @public (undocumented)
export class MagnifyTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _bounds: any;
    // (undocumented)
    _createMagnificationViewport: () => void;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragEndCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        referencedImageId: string;
        viewportIdsToRender: string[];
        enabledElement: Types_2.IEnabledElement;
        renderingEngine: Types_2.IRenderingEngine;
        currentPoints: IPoints;
    } | null;
    // (undocumented)
    _getReferencedImageId(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport): string;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    preTouchStartCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    static toolName: any;
}

declare namespace math {
    export {
        aabb,
        BasicStatsCalculator,
        ellipse,
        lineSegment,
        point,
        polyline,
        rectangle,
        vec2
    }
}

// @public (undocumented)
function mergePolylines(targetPolyline: Types_2.Point2[], sourcePolyline: Types_2.Point2[]): Types_2.Point2[];

// @public (undocumented)
export class MIPJumpToClickTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _bounds: any;
    // (undocumented)
    mouseClickCallback(evt: any): void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
function mirror(mirrorPoint: Types_2.Point2, staticPoint: Types_2.Point2): Types_2.Point2;

// @public (undocumented)
enum MouseBindings {
    // (undocumented)
    Auxiliary = 4,
    // (undocumented)
    Fifth_Button = 16,
    // (undocumented)
    Fourth_Button = 8,
    // (undocumented)
    Primary = 1,
    // (undocumented)
    Primary_And_Auxiliary = 5,
    // (undocumented)
    Primary_And_Secondary = 3,
    // (undocumented)
    Primary_And_Secondary_And_Auxiliary = 7,
    // (undocumented)
    Secondary = 2,
    // (undocumented)
    Secondary_And_Auxiliary = 6
}

// @public (undocumented)
type MouseClickEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseClickEventType = Types_2.CustomEventType<MouseClickEventDetail>;

// @public (undocumented)
class MouseCursor {
    constructor(name: string, fallback?: MouseCursor | undefined);
    // (undocumented)
    addFallbackStyleProperty(style: string): string;
    // (undocumented)
    static getDefinedCursor(name: string): MouseCursor | undefined;
    // (undocumented)
    getName(): string;
    // (undocumented)
    getStyleProperty(): string;
    // (undocumented)
    static setDefinedCursor(name: string, cursor: MouseCursor): boolean;
}

// @public (undocumented)
type MouseDoubleClickEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail;

// @public (undocumented)
type MouseDoubleClickEventType = Types_2.CustomEventType<MouseDoubleClickEventDetail>;

// @public (undocumented)
type MouseDownActivateEventDetail = NormalizedInteractionEventDetail & MousePointsDetail & MouseCustomEventDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseDownActivateEventType = Types_2.CustomEventType<MouseDownActivateEventDetail>;

// @public (undocumented)
type MouseDownEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseDownEventType = Types_2.CustomEventType<MouseDownEventDetail>;

// @public (undocumented)
type MouseDragEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseDragEventType = Types_2.CustomEventType<MouseDragEventDetail>;

// @public (undocumented)
type MouseMoveEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & {
    currentPoints: IPoints;
};

// @public (undocumented)
type MouseMoveEventType = Types_2.CustomEventType<MouseMoveEventDetail>;

// @public (undocumented)
type MouseUpEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseUpEventType = Types_2.CustomEventType<MouseUpEventDetail>;

// @public (undocumented)
type MouseWheelEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & {
    detail: Record<string, any>;
    wheel: {
        spinX: number;
        spinY: number;
        pixelX: number;
        pixelY: number;
        direction: number;
    };
    points: IPoints;
};

// @public (undocumented)
type MouseWheelEventType = Types_2.CustomEventType<MouseWheelEventDetail>;

// @public (undocumented)
type NamedStatistics = {
    mean: Statistics & {
        name: 'mean';
    };
    max: Statistics & {
        name: 'max';
    };
    stdDev: Statistics & {
        name: 'stdDev';
    };
    stdDevWithSumSquare: Statistics & {
        name: 'stdDevWithSumSquare';
    };
    count: Statistics & {
        name: 'count';
    };
    area?: Statistics & {
        name: 'area';
    };
    volume?: Statistics & {
        name: 'volume';
    };
    circumferance?: Statistics & {
        name: 'circumferance';
    };
    array: Statistics[];
};

// @public (undocumented)
type NormalizedInteractionEventDetail = {
    eventName: string;
    renderingEngineId: string;
    viewportId: string;
    camera: Record<string, unknown>;
    element: HTMLDivElement;
};

// @public (undocumented)
type NormalizedMouseEventType = Types_2.CustomEventType<MouseCustomEventDetail>;

// @public (undocumented)
type NormalizedTouchEventType = Types_2.CustomEventType<TouchCustomEventDetail>;

declare namespace orientation_2 {
    export {
        getOrientationStringLPS,
        invertOrientationStringLPS
    }
}

// @public (undocumented)
export class OrientationMarkerTool extends BaseTool {
    constructor(toolProps?: {}, defaultToolProps?: {
        configuration: {
            orientationWidget: {
                enabled: boolean;
                viewportCorner: Corners;
                viewportSize: number;
                minPixelSize: number;
                maxPixelSize: number;
            };
            overlayMarkerType: number;
            overlayConfiguration: {
                [x: number]: {
                    faceProperties: {
                        xPlus: {
                            text: string;
                            faceColor: string;
                            faceRotation: number;
                        };
                        xMinus: {
                            text: string;
                            faceColor: string;
                            faceRotation: number;
                        };
                        yPlus: {
                            text: string;
                            faceColor: string;
                            fontColor: string;
                            faceRotation: number;
                        };
                        yMinus: {
                            text: string;
                            faceColor: string;
                            fontColor: string;
                        };
                        zPlus: {
                            text: string;
                        };
                        zMinus: {
                            text: string;
                        };
                    };
                    defaultStyle: {
                        fontStyle: string;
                        fontFamily: string;
                        fontColor: string;
                        fontSizeScale: (res: any) => number;
                        faceColor: string;
                        edgeThickness: number;
                        edgeColor: string;
                        resolution: number;
                    };
                    polyDataURL?: undefined;
                } | {
                    faceProperties?: undefined;
                    defaultStyle?: undefined;
                    polyDataURL?: undefined;
                } | {
                    polyDataURL: string;
                    faceProperties?: undefined;
                    defaultStyle?: undefined;
                };
            };
        };
    });
    // (undocumented)
    addAxisActorInViewport(viewport: any): Promise<void>;
    // (undocumented)
    static AXIS: number;
    // (undocumented)
    configuration_invalidated: boolean;
    // (undocumented)
    createAnnotatedCubeActor(): Promise<vtkAnnotatedCubeActor>;
    // (undocumented)
    static CUBE: number;
    // (undocumented)
    _getViewportsInfo: () => any[];
    // (undocumented)
    onSetToolActive: () => void;
    // (undocumented)
    onSetToolDisabled: () => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    orientationMarkers: any;
    // (undocumented)
    static OVERLAY_MARKER_TYPES: {
        ANNOTATED_CUBE: number;
        AXES: number;
        CUSTOM: number;
    };
    // (undocumented)
    polyDataURL: any;
    // (undocumented)
    reset: () => void;
    // (undocumented)
    resize: (viewportId: any) => void;
    // (undocumented)
    _resizeObservers: Map<any, any>;
    // (undocumented)
    _subscribeToViewportEvents(): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    _unsubscribeToViewportNewVolumeSet(): void;
    // (undocumented)
    static VTPFILE: number;
}

// @public (undocumented)
export class OverlayGridTool extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    calculateImageIdPointSets: (imageId: string) => {
        pointSet1: Types_2.Point3[];
        pointSet2: Types_2.Point3[];
    };
    // (undocumented)
    _init: () => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    onSetToolActive: () => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
export class PaintFillTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
export class PanTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    mouseDragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback(evt: EventTypes_2.InteractionEventType): void;
}

declare namespace planar {
    export {
        _default as default,
        filterAnnotationsWithinSlice,
        getWorldWidthAndHeightFromCorners,
        filterAnnotationsForDisplay,
        getPointInLineOfSightWithCriteria,
        isPlaneIntersectingAABB
    }
}

// @public (undocumented)
type PlanarBoundingBox = {
    x: number;
    y: number;
    width: number;
    height: number;
};

// @public (undocumented)
type PlanarFreehandContourSegmentationAnnotation = PlanarFreehandROIAnnotation & ContourSegmentationAnnotationData;

// @public (undocumented)
export class PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {
    constructor(toolProps: PublicToolProps);
    // (undocumented)
    protected isContourSegmentationTool(): boolean;
    // (undocumented)
    protected renderAnnotationInstance(renderContext: AnnotationRenderContext): boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
type PlanarFreehandROIAnnotation = ContourAnnotation & {
    data: {
        label?: string;
        isOpenUShapeContour?: boolean;
        openUShapeContourVectorToPeak?: Types_2.Point3[];
        cachedStats?: ROICachedStats;
    };
};

// @public (undocumented)
export class PlanarFreehandROITool extends ContourSegmentationBaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    protected activateDraw: (evt: EventTypes_2.InteractionEventType, annotation: PlanarFreehandROIAnnotation, viewportIdsToRender: string[]) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => PlanarFreehandROIAnnotation;
    // (undocumented)
    _calculateStatsIfActive(annotation: PlanarFreehandROIAnnotation, targetId: string, viewport: any, renderingEngine: any, enabledElement: any): void;
    // (undocumented)
    cancel: (element: HTMLDivElement) => void;
    // (undocumented)
    protected createAnnotation(evt: EventTypes_2.InteractionEventType): Annotation;
    // (undocumented)
    filterInteractableAnnotationsForElement(element: HTMLDivElement, annotations: Annotations): Annotations | undefined;
    // (undocumented)
    protected getAnnotationStyle(context: any): any;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: PlanarFreehandROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    protected isContourSegmentationTool(): boolean;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isEditingClosed: boolean;
    // (undocumented)
    isEditingOpen: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: PlanarFreehandROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    protected renderAnnotationInstance(renderContext: AnnotationRenderContext): boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: PlanarFreehandROIAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace planarFreehandROITool {
    export {
        _default_4 as default,
        smoothAnnotation
    }
}

// @public (undocumented)
export class PlanarRotateTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: EventTypes_2.MouseDragEventType): void;
    // (undocumented)
    mouseDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
}

// @public (undocumented)
function playClip(element: HTMLDivElement, playClipOptions: CINETypes.PlayClipOptions): void;

// @public (undocumented)
type PlayClipOptions = {
    framesPerSecond?: number;
    frameTimeVector?: number[];
    reverse?: boolean;
    loop?: boolean;
    dynamicCineEnabled?: boolean;
    frameTimeVectorSpeedMultiplier?: number;
    waitForRendered?: number;
};

declare namespace point {
    export {
        distanceToPoint_3 as distanceToPoint,
        distanceToPointSquared_3 as distanceToPointSquared,
        mirror
    }
}

// @public (undocumented)
const pointCanProjectOnLine: (p: Types_2.Point2, p1: Types_2.Point2, p2: Types_2.Point2, proximity: number) => boolean;

// @public (undocumented)
function pointInEllipse(ellipse: any, pointLPS: any, inverts?: Inverts): boolean;

// @public (undocumented)
function pointInShapeCallback(imageData: vtkImageData | Types_2.CPUImageData, pointInShapeFn: ShapeFnCriteria, callback?: PointInShapeCallback, boundsIJK?: BoundsIJK_2): Array<PointInShape>;

// @public (undocumented)
function pointInSurroundingSphereCallback(imageData: vtkImageData, circlePoints: [Types_2.Point3, Types_2.Point3], callback: PointInShapeCallback, viewport?: Types_2.IVolumeViewport): void;

// @public (undocumented)
const pointsAreWithinCloseContourProximity: (p1: Types_2.Point2, p2: Types_2.Point2, closeContourProximity: number) => boolean;

// @public (undocumented)
function pointToString(point: any, decimals?: number): string;

declare namespace polyDataUtils {
    export {
        getPoint,
        getPolyDataPointIndexes,
        getPolyDataPoints
    }
}

declare namespace polyline {
    export {
        isClosed,
        containsPoint,
        containsPoints,
        getAABB,
        getArea,
        getSignedArea,
        getWindingDirection,
        getNormal3,
        getNormal2,
        intersectPolyline,
        decimate,
        getFirstLineSegmentIntersectionIndexes,
        getLineSegmentIntersectionsIndexes,
        getLineSegmentIntersectionsCoordinates,
        getClosestLineSegmentIntersection,
        getSubPixelSpacingAndXYDirections,
        pointsAreWithinCloseContourProximity,
        addCanvasPointsToArray,
        pointCanProjectOnLine,
        mergePolylines,
        subtractPolylines,
        isPointInsidePolyline3D,
        projectTo2D
    }
}

// @public (undocumented)
type PolySegConversionOptions = {
    segmentIndices?: number[];
    segmentationRepresentationUID?: string;
    viewport?: Types_2.IStackViewport | Types_2.IVolumeViewport;
};

declare namespace polySegManager {
    export {
        canComputeRequestedRepresentation,
        computeAndAddSurfaceRepresentation,
        computeAndAddLabelmapRepresentation,
        computeAndAddContourRepresentation
    }
}

// @public (undocumented)
const precalculatePointInEllipse: (ellipse: any, inverts?: Inverts) => Inverts;

// @public (undocumented)
interface ProbeAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
        };
        cachedStats: {
            [targetId: string]: {
                Modality: string;
                index: Types_2.Point3;
                value: number;
            };
        };
        label: string;
    };
}

// @public (undocumented)
export class ProbeTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => ProbeAnnotation;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        newAnnotation?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    eventDispatchDetail: {
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getHandleNearImagePoint(element: HTMLDivElement, annotation: ProbeAnnotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: ProbeAnnotation): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool(): boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback(): void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function projectTo2D(polyline: Types_2.Point3[]): {
    sharedDimensionIndex: any;
    projectedPolyline: Types_2.Point2[];
};

// @public (undocumented)
type PublicToolProps = SharedToolProp & {
    name?: string;
};

declare namespace rectangle {
    export {
        distanceToPoint_4 as distanceToPoint
    }
}

// @public (undocumented)
interface RectangleROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats?: ROICachedStats | {
            pointsInVolume?: Types_2.Point3[];
            projectionPoints?: Types_2.Point3[];
            projectionPointsImageIds?: string[];
        };
    };
}

// @public (undocumented)
interface RectangleROIStartEndThresholdAnnotation extends Annotation {
    // (undocumented)
    data: {
        label: string;
        startSlice: number;
        endSlice: number;
        cachedStats: {
            pointsInVolume: Types_2.Point3[];
            projectionPoints: Types_2.Point3[][];
            projectionPointsImageIds: string[];
        };
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
        };
    };
    // (undocumented)
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        annotationUID?: string;
        FrameOfReferenceUID: string;
        referencedImageId?: string;
        toolName: string;
        enabledElement: any;
        volumeId: string;
        spacingInNormal: number;
    };
}

// @public (undocumented)
export class RectangleROIStartEndThresholdTool extends RectangleROITool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => {
        highlighted: boolean;
        invalidated: boolean;
        metadata: {
            viewPlaneNormal: Types_2.Point3;
            enabledElement: Types_2.IEnabledElement;
            viewUp: Types_2.Point3;
            FrameOfReferenceUID: string;
            referencedImageId: any;
            toolName: string;
            volumeId: any;
            spacingInNormal: number;
        };
        data: {
            label: string;
            startSlice: number;
            endSlice: number;
            cachedStats: {
                pointsInVolume: any[];
                projectionPoints: any[];
                projectionPointsImageIds: any[];
            };
            handles: {
                textBox: {
                    hasMoved: boolean;
                    worldPosition: any;
                    worldBoundingBox: any;
                };
                points: Types_2.Point3[];
                activeHandleIndex: any;
            };
            labelmapUID: any;
        };
    };
    // (undocumented)
    _calculateCachedStatsTool(annotation: any, enabledElement: any): any;
    // (undocumented)
    _computePointsInsideVolume(annotation: any, imageVolume: any, enabledElement: any): void;
    // (undocumented)
    _computeProjectionPoints(annotation: RectangleROIStartEndThresholdAnnotation, imageVolume: Types_2.IImageVolume): void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getEndSliceIndex(imageVolume: Types_2.IImageVolume, worldPos: Types_2.Point3, spacingInNormal: number, viewPlaneNormal: Types_2.Point3): number | undefined;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
interface RectangleROIThresholdAnnotation extends Annotation {
    // (undocumented)
    data: {
        label: string;
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
        };
    };
    // (undocumented)
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        annotationUID?: string;
        FrameOfReferenceUID: string;
        referencedImageId?: string;
        toolName: string;
        enabledElement: Types_2.IEnabledElement;
        volumeId: string;
    };
}

// @public (undocumented)
export class RectangleROIThresholdTool extends RectangleROITool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => {
        highlighted: boolean;
        invalidated: boolean;
        metadata: {
            viewPlaneNormal: Types_2.Point3;
            enabledElement: Types_2.IEnabledElement;
            viewUp: Types_2.Point3;
            FrameOfReferenceUID: string;
            referencedImageId: any;
            toolName: string;
            volumeId: any;
        };
        data: {
            label: string;
            handles: {
                textBox: {
                    hasMoved: boolean;
                    worldPosition: any;
                    worldBoundingBox: any;
                };
                points: Types_2.Point3[];
                activeHandleIndex: any;
            };
            segmentationId: any;
        };
    };
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
function rectangleROIThresholdVolumeByRange(annotationUIDs: string[], segmentationVolume: Types_2.IImageVolume, thresholdVolumeInformation: ThresholdInformation[], options: ThresholdOptions): Types_2.IImageVolume;

// @public (undocumented)
export class RectangleROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => RectangleROIAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewPlaneNormal: any, viewUp: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getRectangleImageCoordinates: (points: Array<Types_2.Point2>) => {
        left: number;
        top: number;
        width: number;
        height: number;
    };
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: RectangleROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: RectangleROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: RectangleROIAnnotation) => void;
}

declare namespace rectangleROITool {
    export {
        getBoundsIJKFromRectangleAnnotations,
        isAxisAlignedRectangle
    }
}

// @public (undocumented)
export class RectangleScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        imageIdReferenceMap: Map<string, string>;
        volumeId: string;
        referencedVolumeId: string;
        annotation: any;
        segmentationId: string;
        segmentIndex: number;
        segmentsLocked: number[];
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
interface ReferenceCursor extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: [Types_2.Point3];
        };
    };
}

// @public (undocumented)
export class ReferenceCursors extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    createInitialAnnotation: (worldPos: Types_2.Point3, element: HTMLDivElement) => void;
    // (undocumented)
    _currentCanvasPosition: null | Types_2.Point2;
    // (undocumented)
    _currentCursorWorldPosition: null | Types_2.Point3;
    // (undocumented)
    _disableCursorEnabled: boolean;
    // (undocumented)
    _elementWithCursor: null | HTMLDivElement;
    // (undocumented)
    filterInteractableAnnotationsForElement(element: HTMLDivElement, annotations: Annotations): Annotations;
    // (undocumented)
    getActiveAnnotation(element: HTMLDivElement): null | Annotation;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    onCameraModified: (evt: any) => void;
    // (undocumented)
    onSetToolActive(): void;
    // (undocumented)
    onSetToolDisabled(): void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
    // (undocumented)
    updateAnnotationPosition(element: HTMLDivElement, annotation: Annotation): void;
    // (undocumented)
    updateViewportImage(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport): void;
}

// @public (undocumented)
interface ReferenceLineAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
        };
    };
}

// @public (undocumented)
class ReferenceLines extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    editData: {
        renderingEngine: any;
        sourceViewportId: string;
        annotation: ReferenceLineAnnotation;
    } | null;
    // (undocumented)
    _init: () => void;
    // (undocumented)
    intersectInfiniteLines(line1Start: Types_2.Point2, line1End: Types_2.Point2, line2Start: Types_2.Point2, line2End: Types_2.Point2): number[];
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isInBound(point: number[], dimensions: Types_2.Point3): boolean;
    // (undocumented)
    isParallel(vec1: Types_2.Point3, vec2: Types_2.Point3): boolean;
    // (undocumented)
    isPerpendicular: (vec1: Types_2.Point3, vec2: Types_2.Point3) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    onCameraModified: (evt: Types_2.EventTypes.CameraModifiedEvent) => void;
    // (undocumented)
    onSetToolConfiguration: () => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}
export { ReferenceLines }
export { ReferenceLines as ReferenceLinesTool }

// @public (undocumented)
function registerCursor(toolName: string, iconContent: string, viewBox: {
    x: number;
    y: number;
}): void;

// @public (undocumented)
function removeAllAnnotations(): void;

// @public (undocumented)
function removeAnnotation(annotationUID: string): void;

// @public (undocumented)
function removeColorLUT(colorLUTIndex: number): void;

// @public (undocumented)
function removeContourSegmentationAnnotation(annotation: ContourSegmentationAnnotation): void;

// @public (undocumented)
function removeSegmentation(segmentationId: string): void;

// @public (undocumented)
function removeSegmentationRepresentation(toolGroupId: string, segmentationRepresentationUID: string): void;

// @public (undocumented)
function removeSegmentationRepresentations(toolGroupId: string): void;

// @public (undocumented)
function removeSegmentationsFromToolGroup(toolGroupId: string, segmentationRepresentationUIDs?: string[] | undefined, immediate?: boolean): void;

// @public (undocumented)
export function removeTool(ToolClass: any): void;

// @public (undocumented)
type RepresentationConfig = {
    LABELMAP?: LabelmapConfig;
    CONTOUR?: ContourConfig;
    SURFACE?: any;
};

// @public (undocumented)
type RepresentationPublicInput = {
    segmentationId: string;
    type: Enums.SegmentationRepresentations;
    options?: RepresentationPublicInputOptions;
};

// @public (undocumented)
function resetAnnotationManager(): void;

// @public (undocumented)
function resetElementCursor(element: HTMLDivElement): void;

// @public (undocumented)
const roundNumber: typeof utilities_2.roundNumber;

// @public (undocumented)
interface ScaleOverlayAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
        };
        viewportId: string;
    };
}

// @public (undocumented)
export class ScaleOverlayTool extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    computeCanvasScaleCoordinates: (canvasSize: any, canvasCoordinates: any, vscaleBounds: any, hscaleBounds: any, location: any) => any;
    // (undocumented)
    computeEndScaleTicks: (canvasCoordinates: any, location: any) => {
        endTick1: any[][];
        endTick2: any[][];
    };
    // (undocumented)
    computeInnerScaleTicks: (scaleSize: number, location: string, annotationUID: string, leftTick: any[][], rightTick: any[][]) => {
        tickIds: any[];
        tickUIDs: any[];
        tickCoordinates: any[];
    };
    // (undocumented)
    computeScaleBounds: (canvasSize: any, horizontalReduction: any, verticalReduction: any, location: any) => {
        height: any;
        width: any;
    };
    // (undocumented)
    computeScaleSize: (worldWidthViewport: number, worldHeightViewport: number, location: any) => any;
    // (undocumented)
    computeWorldScaleCoordinates: (scaleSize: any, location: any, pointSet: any) => any;
    // (undocumented)
    editData: {
        renderingEngine: any;
        viewport: any;
        annotation: ScaleOverlayAnnotation;
    } | null;
    // (undocumented)
    _getTextLines(scaleSize: number): string[] | undefined;
    // (undocumented)
    _init: () => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    onCameraModified: (evt: Types_2.EventTypes.CameraModifiedEvent) => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function scroll_2(viewport: Types_2.IViewport, options: ScrollOptions_2): void;

// @public (undocumented)
type ScrollOptions_2 = {
    delta: number;
    volumeId?: string;
    debounceLoading?: boolean;
    loop?: boolean;
    scrollSlabs?: boolean;
};

// @public (undocumented)
type Segmentation = {
    segmentationId: string;
    type: Enums.SegmentationRepresentations;
    label: string;
    activeSegmentIndex: number;
    segmentsLocked: Set<number>;
    cachedStats: {
        [key: string]: number;
    };
    segmentLabels: {
        [key: string]: string;
    };
    representationData: SegmentationRepresentationData;
};

declare namespace segmentation {
    export {
        addSegmentations,
        addSegmentationRepresentations,
        removeSegmentationsFromToolGroup,
        addRepresentationData,
        state_3 as state,
        activeSegmentation,
        segmentLocking,
        config_2 as config,
        segmentIndex,
        triggerSegmentationEvents,
        convertStackToVolumeSegmentation,
        convertVolumeToStackSegmentation,
        polySegManager as polySeg
    }
}
export { segmentation }

declare namespace segmentation_2 {
    export {
        thresholdVolumeByRange,
        createMergedLabelmapForIndex,
        isValidRepresentationConfig,
        getDefaultRepresentationConfig,
        createLabelmapVolumeForViewport,
        rectangleROIThresholdVolumeByRange,
        triggerSegmentationRender,
        floodFill,
        getBrushSizeForToolGroup,
        setBrushSizeForToolGroup,
        getBrushThresholdForToolGroup,
        setBrushThresholdForToolGroup,
        thresholdSegmentationByRange,
        createImageIdReferenceMap,
        contourAndFindLargestBidirectional,
        createBidirectionalToolData,
        segmentContourAction,
        invalidateBrushCursor,
        getUniqueSegmentIndices,
        getSegmentAtWorldPoint,
        getSegmentAtLabelmapBorder,
        getHoveredContourSegmentationAnnotation,
        getBrushToolInstances
    }
}

// @public (undocumented)
type SegmentationDataModifiedEventDetail = {
    segmentationId: string;
    modifiedSlicesToUse?: number[];
};

// @public (undocumented)
type SegmentationDataModifiedEventType = Types_2.CustomEventType<SegmentationDataModifiedEventDetail>;

// @public (undocumented)
export class SegmentationDisplayTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addPlanarFreeHandToolIfAbsent(toolGroupId: any): void;
    // (undocumented)
    _getMergedRepresentationsConfig(toolGroupId: string): SegmentationRepresentationConfig;
    // (undocumented)
    onSetToolDisabled(): void;
    // (undocumented)
    onSetToolEnabled(): void;
    // (undocumented)
    renderSegmentation: (toolGroupId: string) => void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
export class SegmentationIntersectionTool extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _init: () => void;
    // (undocumented)
    onCameraModified: (evt: Types_2.EventTypes.CameraModifiedEvent) => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
type SegmentationModifiedEventDetail = {
    segmentationId: string;
};

// @public (undocumented)
type SegmentationModifiedEventType = Types_2.CustomEventType<SegmentationModifiedEventDetail>;

// @public (undocumented)
type SegmentationRemovedEventDetail = {
    segmentationId: string;
};

// @public (undocumented)
type SegmentationRemovedEventType = Types_2.CustomEventType<SegmentationRemovedEventDetail>;

// @public (undocumented)
type SegmentationRenderedEventDetail = {
    viewportId: string;
    toolGroupId: string;
};

// @public (undocumented)
type SegmentationRenderedEventType = Types_2.CustomEventType<SegmentationRenderedEventDetail>;

// @public (undocumented)
type SegmentationRepresentationConfig = {
    renderInactiveSegmentations: boolean;
    representations: RepresentationConfig;
};

// @public (undocumented)
type SegmentationRepresentationData = {
    LABELMAP?: LabelmapSegmentationData;
    CONTOUR?: ContourSegmentationData;
    SURFACE?: SurfaceSegmentationData;
};

// @public (undocumented)
type SegmentationRepresentationModifiedEventDetail = {
    toolGroupId: string;
    segmentationRepresentationUID: string;
};

// @public (undocumented)
type SegmentationRepresentationModifiedEventType = Types_2.CustomEventType<SegmentationRepresentationModifiedEventDetail>;

// @public (undocumented)
type SegmentationRepresentationRemovedEventDetail = {
    toolGroupId: string;
    segmentationRepresentationUID: string;
};

// @public (undocumented)
type SegmentationRepresentationRemovedEventType = Types_2.CustomEventType<SegmentationRepresentationRemovedEventDetail>;

// @public (undocumented)
enum SegmentationRepresentations {
    // (undocumented)
    Contour = "CONTOUR",
    // (undocumented)
    Labelmap = "LABELMAP",
    // (undocumented)
    Surface = "SURFACE"
}

// @public (undocumented)
type SegmentationState = {
    colorLUT: Types_2.ColorLUT[];
    segmentations: Segmentation[];
    globalConfig: SegmentationRepresentationConfig;
    toolGroups: {
        [key: string]: {
            segmentationRepresentations: ToolGroupSpecificRepresentations;
            config: SegmentationRepresentationConfig;
        };
    };
};

// @public (undocumented)
function segmentContourAction(element: HTMLDivElement, configuration: any): any;

declare namespace segmentIndex {
    export {
        getActiveSegmentIndex,
        setActiveSegmentIndex
    }
}

declare namespace segmentLocking {
    export {
        isSegmentIndexLocked,
        setSegmentIndexLocked,
        getLockedSegments
    }
}

// @public (undocumented)
export class SegmentSelectTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    onSetToolActive: () => void;
    // (undocumented)
    onSetToolDisabled: () => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    static SelectMode: {
        Inside: string;
        Border: string;
    };
    // (undocumented)
    _setActiveSegment(evt?: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    _setActiveSegmentForType(activeSegmentationReps: ToolGroupSpecificRepresentation, worldPoint: Types_2.Point3, viewport: Types_2.IStackViewport | Types_2.IVolumeViewport): void;
    // (undocumented)
    static toolName: any;
}

declare namespace selection {
    export {
        setAnnotationSelected,
        getAnnotationsSelected,
        getAnnotationsSelectedByToolName,
        getAnnotationsSelectedCount,
        deselectAnnotation,
        isAnnotationSelected
    }
}

// @public (undocumented)
function setActiveSegmentationRepresentation(toolGroupId: string, segmentationRepresentationUID: string): void;

// @public (undocumented)
function setActiveSegmentIndex(segmentationId: string, segmentIndex: number): void;

// @public (undocumented)
function setAnnotationLocked(annotation: Annotation, locked?: boolean): void;

// @public (undocumented)
function setAnnotationManager(annotationManager: any): void;

// @public (undocumented)
function setAnnotationSelected(annotationUID: string, selected?: boolean, preserveSelected?: boolean): void;

// @public (undocumented)
function setAnnotationVisibility(annotationUID: string, visible?: boolean): void;

// @public (undocumented)
function setAttributesIfNecessary(attributes: any, svgNode: any): void;

// @public (undocumented)
function setBrushSizeForToolGroup(toolGroupId: string, brushSize: number, toolName?: string): void;

// @public (undocumented)
function setBrushThresholdForToolGroup(toolGroupId: string, threshold: Types_2.Point2, otherArgs?: Record<string, unknown>): void;

// @public (undocumented)
function setColorForSegmentIndex(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number, color: Types_2.Color): void;

// @public (undocumented)
function setColorLUT(toolGroupId: string, segmentationRepresentationUID: string, colorLUTIndex: number): void;

// @public (undocumented)
function setCursorForElement(element: HTMLDivElement, cursorName: string): void;

// @public (undocumented)
function _setElementCursor(element: HTMLDivElement, cursor: MouseCursor | null): void;

// @public (undocumented)
function setGlobalConfig(config: SegmentationRepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setGlobalConfig_2(segmentationConfig: SegmentationRepresentationConfig): void;

// @public (undocumented)
function setGlobalRepresentationConfig(representationType: SegmentationRepresentations, config: RepresentationConfig['LABELMAP']): void;

// @public (undocumented)
function setNewAttributesIfValid(attributes: any, svgNode: any): void;

// @public (undocumented)
function setSegmentationRepresentationSpecificConfig(toolGroupId: string, segmentationRepresentationUID: string, config: RepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setSegmentationRepresentationSpecificConfig_2(toolGroupId: string, segmentationRepresentationUID: string, config: RepresentationConfig): void;

// @public (undocumented)
function setSegmentationVisibility(toolGroupId: string, segmentationRepresentationUID: string, visibility: boolean): void;

// @public (undocumented)
function setSegmentIndexLocked(segmentationId: string, segmentIndex: number, locked?: boolean): void;

// @public (undocumented)
function setSegmentSpecificConfig(toolGroupId: string, segmentationRepresentationUID: string, config: SegmentSpecificRepresentationConfig): void;

// @public (undocumented)
function setSegmentSpecificRepresentationConfig(toolGroupId: string, segmentationRepresentationUID: string, config: SegmentSpecificRepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setSegmentsVisibility(toolGroupId: string, segmentationRepresentationUID: string, segmentIndices: number[], visibility: boolean): void;

// @public (undocumented)
function setSegmentVisibility(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number, visibility: boolean): void;

// @public (undocumented)
type SetToolBindingsType = {
    bindings: IToolBinding[];
};

// @public (undocumented)
function setToolGroupSpecificConfig(toolGroupId: string, config: SegmentationRepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setToolGroupSpecificConfig_2(toolGroupId: string, segmentationRepresentationConfig: SegmentationRepresentationConfig): void;

// @public (undocumented)
function showAllAnnotations(): void;

// @public (undocumented)
function smoothAnnotation(enabledElement: Types_2.IEnabledElement, annotation: PlanarFreehandROIAnnotation, knotsRatioPercentage: number): boolean;

// @public (undocumented)
export class SphereScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentIndex: number;
        segmentsLocked: number[];
        segmentationRepresentationUID: string;
        volumeId: string;
        referencedVolumeId: string;
        imageIdReferenceMap: Map<string, string>;
        toolGroupId: string;
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        centerCanvas?: Array<number>;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => true;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
type SplineContourSegmentationAnnotation = SplineROIAnnotation & ContourSegmentationAnnotationData;

// @public (undocumented)
export class SplineContourSegmentationTool extends SplineROITool {
    constructor(toolProps: PublicToolProps);
    // (undocumented)
    protected isContourSegmentationTool(): boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
type SplineCurveSegment = {
    controlPoints: {
        p0: Types_2.Point2;
        p1: Types_2.Point2;
        p2: Types_2.Point2;
        p3: Types_2.Point2;
    };
    aabb: Types_2.AABB2;
    length: number;
    previousCurveSegmentsLength: number;
    lineSegments: SplineLineSegment[];
};

// @public (undocumented)
type SplineLineSegment = {
    points: {
        start: Types_2.Point2;
        end: Types_2.Point2;
    };
    aabb: Types_2.AABB2;
    length: number;
    previousLineSegmentsLength: number;
};

// @public (undocumented)
type SplineProps = {
    resolution?: number;
    fixedResolution?: boolean;
    closed?: boolean;
};

// @public (undocumented)
type SplineROIAnnotation = ContourAnnotation & {
    data: {
        label?: string;
        spline: {
            type: string;
            instance: ISpline;
            resolution: number;
        };
        cachedStats?: {
            [targetId: string]: {
                Modality: string;
                area: number;
                areaUnit: string;
            };
        };
    };
};

// @public (undocumented)
export class SplineROITool extends ContourSegmentationBaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    static Actions: typeof SplineToolActions;
    // (undocumented)
    addControlPointCallback: (evt: EventTypes_2.InteractionEventType, annotation: SplineROIAnnotation) => void;
    // (undocumented)
    addNewAnnotation(evt: EventTypes_2.InteractionEventType): SplineROIAnnotation;
    // (undocumented)
    cancel(element: HTMLDivElement): string;
    // (undocumented)
    protected createAnnotation(evt: EventTypes_2.InteractionEventType): Annotation;
    // (undocumented)
    protected createInterpolatedSplineControl(annotation: any): void;
    // (undocumented)
    deleteControlPointCallback: (evt: EventTypes_2.InteractionEventType, annotation: SplineROIAnnotation) => void;
    // (undocumented)
    editData: {
        annotation: SplineROIAnnotation;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        lastCanvasPoint?: Types_2.Point2;
        contourHoleProcessingEnabled?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    fireChangeOnUpdate: {
        annotationUID: string;
        changeType: ChangeTypes;
        contourHoleProcessingEnabled: boolean;
    };
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: SplineROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    protected isContourSegmentationTool(): boolean;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: SplineROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    _isSplineROIAnnotation(annotation: Annotation): annotation is SplineROIAnnotation;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    protected renderAnnotationInstance(renderContext: AnnotationRenderContext): boolean;
    // (undocumented)
    static SplineTypes: typeof SplineTypesEnum;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: SplineROIAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
    // (undocumented)
    triggerAnnotationCompleted: (annotation: SplineROIAnnotation, contourHoleProcessingEnabled: boolean) => void;
    // (undocumented)
    triggerAnnotationModified: (annotation: SplineROIAnnotation, enabledElement: Types_2.IEnabledElement, changeType?: ChangeTypes) => void;
    // (undocumented)
    triggerChangeEvent: (annotation: SplineROIAnnotation, enabledElement: Types_2.IEnabledElement, changeType: ChangeTypes, contourHoleProcessingEnabled: any) => void;
}

// @public (undocumented)
const stackContextPrefetch: {
    enable: (element: any) => void;
    disable: typeof disable_2;
    getConfiguration: typeof getConfiguration_2;
    setConfiguration: typeof setConfiguration_2;
};

// @public (undocumented)
const stackPrefetch: {
    enable: typeof enable;
    disable: typeof disable;
    getConfiguration: typeof getConfiguration;
    setConfiguration: typeof setConfiguration;
};

// @public (undocumented)
export class StackScrollMouseWheelTool extends BaseTool {
    constructor(toolProps?: {}, defaultToolProps?: {
        supportedInteractionTypes: string[];
        configuration: {
            invert: boolean;
            debounceIfNotLoaded: boolean;
            loop: boolean;
            scrollSlabs: boolean;
        };
    });
    // (undocumented)
    _configuration: any;
    // (undocumented)
    mouseWheelCallback(evt: MouseWheelEventType): void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
export class StackScrollTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    deltaY: number;
    // (undocumented)
    _dragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    _getPixelPerImage(viewport: any): number;
    // (undocumented)
    mouseDragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback(evt: EventTypes_2.InteractionEventType): void;
}

// @public (undocumented)
export let state: ICornerstoneTools3dState;

declare namespace state_2 {
    export {
        getAllAnnotations,
        getAnnotations,
        getParentAnnotation,
        getChildAnnotations,
        clearParentAnnotation,
        addChildAnnotation,
        getNumberOfAnnotations,
        addAnnotation,
        getAnnotation,
        removeAnnotation,
        removeAllAnnotations,
        setAnnotationManager,
        getAnnotationManager,
        resetAnnotationManager,
        invalidateAnnotation
    }
}

declare namespace state_3 {
    export {
        getDefaultSegmentationStateManager,
        getSegmentation,
        getSegmentations,
        addSegmentation,
        removeSegmentation,
        getSegmentationRepresentations,
        addSegmentationRepresentation,
        removeSegmentationRepresentation,
        removeSegmentationRepresentations,
        getToolGroupSpecificConfig,
        setToolGroupSpecificConfig,
        getGlobalConfig,
        setGlobalConfig,
        getSegmentationRepresentationSpecificConfig,
        setSegmentationRepresentationSpecificConfig,
        getSegmentSpecificRepresentationConfig,
        setSegmentSpecificRepresentationConfig,
        getToolGroupIdsWithSegmentation,
        getAllSegmentationRepresentations,
        getSegmentationRepresentationByUID,
        getSegmentationIdRepresentations,
        addColorLUT,
        getColorLUT,
        getNextColorLUTIndex,
        removeColorLUT,
        findSegmentationRepresentationByUID,
        getToolGroupIdFromSegmentationRepresentationUID
    }
}

// @public (undocumented)
type Statistics = {
    name: string;
    label?: string;
    value: number | number[];
    unit: null | string;
};

// @public (undocumented)
function stopClip(element: HTMLDivElement, options?: any): void;

// @public (undocumented)
enum StrategyCallbacks {
    // (undocumented)
    AcceptPreview = "acceptPreview",
    // (undocumented)
    ComputeInnerCircleRadius = "computeInnerCircleRadius",
    // (undocumented)
    CreateIsInThreshold = "createIsInThreshold",
    // (undocumented)
    Fill = "fill",
    // (undocumented)
    Initialize = "initialize",
    // (undocumented)
    INTERNAL_setValue = "setValue",
    // (undocumented)
    OnInteractionEnd = "onInteractionEnd",
    // (undocumented)
    OnInteractionStart = "onInteractionStart",
    // (undocumented)
    Preview = "preview",
    // (undocumented)
    RejectPreview = "rejectPreview",
    // (undocumented)
    StrategyFunction = "strategyFunction"
}

// @public (undocumented)
type StyleConfig = {
    annotations?: {
        [annotationUID: string]: AnnotationStyle_2;
    };
    viewports?: {
        [viewportId: string]: ToolStyleConfig;
    };
    toolGroups?: {
        [toolGroupId: string]: ToolStyleConfig;
    };
    default: ToolStyleConfig;
};

// @public (undocumented)
type StyleSpecifier = {
    viewportId?: string;
    toolGroupId?: string;
    toolName?: string;
    annotationUID?: string;
};

// @public (undocumented)
function subtractPolylines(targetPolyline: Types_2.Point2[], sourcePolyline: Types_2.Point2[]): Types_2.Point2[][];

// @public (undocumented)
type SVGCursorDescriptor = {
    iconContent: string;
    iconSize: number;
    viewBox: SVGPoint_2;
    mousePoint: SVGPoint_2;
    mousePointerGroupString: string;
};

// @public (undocumented)
type SVGDrawingHelper = {
    svgLayerElement: HTMLDivElement;
    svgNodeCacheForCanvas: Record<string, unknown>;
    getSvgNode: (cacheKey: string) => SVGGElement | undefined;
    appendNode: (svgNode: SVGElement, cacheKey: string) => void;
    setNodeTouched: (cacheKey: string) => void;
    clearUntouched: () => void;
};

// @public (undocumented)
class SVGMouseCursor extends ImageMouseCursor {
    constructor(url: string, x?: number, y?: number, name?: string | undefined, fallback?: MouseCursor | undefined);
    // (undocumented)
    static getDefinedCursor(name: string, pointer?: boolean, color?: string): MouseCursor;
}

// @public (undocumented)
type SVGPoint_2 = {
    x: number;
    y: number;
};

// @public (undocumented)
enum Swipe {
    // (undocumented)
    DOWN = "DOWN",
    // (undocumented)
    LEFT = "LEFT",
    // (undocumented)
    RIGHT = "RIGHT",
    // (undocumented)
    UP = "UP"
}

// @public (undocumented)
export class Synchronizer {
    constructor(synchronizerId: string, eventName: string, eventHandler: ISynchronizerEventHandler, options?: any);
    // (undocumented)
    add(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    addSource(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    addTarget(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    getOptions(viewportId: string): Record<string, unknown> | undefined;
    // (undocumented)
    getSourceViewports(): Array<Types_2.IViewportId>;
    // (undocumented)
    getTargetViewports(): Array<Types_2.IViewportId>;
    // (undocumented)
    hasSourceViewport(renderingEngineId: string, viewportId: string): boolean;
    // (undocumented)
    hasTargetViewport(renderingEngineId: string, viewportId: string): boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    isDisabled(): boolean;
    // (undocumented)
    remove(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    removeSource(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    removeTarget(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    setEnabled(enabled: boolean): void;
    // (undocumented)
    setOptions(viewportId: string, options?: Record<string, unknown>): void;
}

declare namespace SynchronizerManager {
    export {
        createSynchronizer,
        destroy_2 as destroy,
        getSynchronizer,
        getSynchronizersForViewport,
        getAllSynchronizers,
        destroySynchronizer
    }
}
export { SynchronizerManager }

declare namespace synchronizers {
    export {
        createCameraPositionSynchronizer,
        createPresentationViewSynchronizer,
        createVOISynchronizer,
        createZoomPanSynchronizer,
        createImageSliceSynchronizer,
        createStackImageSynchronizer,
        createPresentationViewSynchronizer_2 as createSlabThicknessSynchronizer
    }
}
export { synchronizers }

// @public (undocumented)
type TextBoxHandle = {
    hasMoved: boolean;
    worldBoundingBox: {
        bottomLeft: Types_2.Point3;
        bottomRight: Types_2.Point3;
        topLeft: Types_2.Point3;
        topRight: Types_2.Point3;
    };
    worldPosition: Types_2.Point3;
};

// @public (undocumented)
function thresholdSegmentationByRange(segmentationVolume: Types_2.IImageVolume, segmentationIndex: number, thresholdVolumeInformation: ThresholdInformation[], overlapType: number): Types_2.IImageVolume;

// @public (undocumented)
function thresholdVolumeByRange(segmentationVolume: Types_2.IImageVolume, thresholdVolumeInformation: ThresholdInformation[], options: ThresholdRangeOptions): Types_2.IImageVolume;

// @public (undocumented)
function throttle(func: Function, wait?: number, options?: {
    leading?: boolean;
    trailing?: boolean;
}): Function;

// @public (undocumented)
type ToolAction = {
    method: string | ((evt: InteractionEventType, annotation: Annotation) => void);
    bindings: SetToolBindingsType[];
};

// @public (undocumented)
type ToolActivatedEventDetail = {
    toolGroupId: string;
    toolName: string;
    toolBindingsOptions: SetToolBindingsType;
};

// @public (undocumented)
type ToolActivatedEventType = Types_2.CustomEventType<ToolActivatedEventDetail>;

// @public (undocumented)
type ToolConfiguration = Record<string, any> & {
    statsCalculator?: Calculator;
};

// @public (undocumented)
interface ToolData {
    // (undocumented)
    dynamicCineEnabled?: boolean;
    // (undocumented)
    framesPerSecond: number;
    // (undocumented)
    frameTimeVector: number[] | undefined;
    // (undocumented)
    ignoreFrameTimeVector: boolean;
    // (undocumented)
    intervalId: number | undefined;
    // (undocumented)
    lastFrameTimeStamp: number | undefined;
    // (undocumented)
    loop: boolean;
    // (undocumented)
    reverse: boolean;
    // (undocumented)
    speed: number;
    // (undocumented)
    usingFrameTimeVector: boolean;
}

// @public (undocumented)
class ToolGroup implements ToolGroup {
    constructor(id: string);
    // (undocumented)
    addTool(toolName: string, configuration?: ToolConfiguration): void;
    // (undocumented)
    addToolInstance(toolName: string, parentClassName: string, configuration?: {}): void;
    // (undocumented)
    addViewport(viewportId: string, renderingEngineId?: string): void;
    // (undocumented)
    clone(newToolGroupId: any, fnToolFilter?: (toolName: string) => void): ToolGroup;
    // (undocumented)
    currentActivePrimaryToolName: string | null;
    // (undocumented)
    getActivePrimaryMouseButtonTool(): string;
    // (undocumented)
    getDefaultMousePrimary(): MouseBindings;
    // (undocumented)
    getDefaultPrimaryBindings(): IToolBinding[];
    // (undocumented)
    getPrevActivePrimaryToolName(): string;
    // (undocumented)
    getToolConfiguration(toolName: string, configurationPath?: string): any;
    // (undocumented)
    getToolInstance(toolInstanceName: string): any;
    // (undocumented)
    getToolInstances(): Record<string, any>;
    // (undocumented)
    getToolOptions(toolName: string): ToolOptionsType;
    // (undocumented)
    getViewportIds(): string[];
    // (undocumented)
    getViewportsInfo(): Array<Types_2.IViewportId>;
    // (undocumented)
    hasTool(toolName: string): boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    prevActivePrimaryToolName: string | null;
    // (undocumented)
    removeViewports(renderingEngineId: string, viewportId?: string): void;
    // (undocumented)
    restoreToolOptions: {};
    // (undocumented)
    setActiveStrategy(toolName: string, strategyName: string): void;
    // (undocumented)
    _setCursorForViewports(cursor: MouseCursor): void;
    // (undocumented)
    setToolActive(toolName: string, toolBindingsOptions?: SetToolBindingsType): void;
    // (undocumented)
    setToolConfiguration(toolName: string, configuration: ToolConfiguration, overwrite?: boolean): boolean;
    // (undocumented)
    setToolDisabled(toolName: string): void;
    // (undocumented)
    setToolEnabled(toolName: string): void;
    // (undocumented)
    setToolMode(toolName: string, mode: ToolModes, options?: SetToolBindingsType): void;
    // (undocumented)
    setToolPassive(toolName: string, options?: {
        removeAllBindings?: boolean | IToolBinding[];
    }): void;
    // (undocumented)
    setViewportsCursorByToolName(toolName: string, strategyName?: string): void;
    // (undocumented)
    _toolInstances: {};
    // (undocumented)
    toolOptions: {};
    // (undocumented)
    viewportsInfo: any[];
}

declare namespace ToolGroupManager {
    export {
        createToolGroup,
        destroy_3 as destroy,
        destroyToolGroup,
        getToolGroup,
        getToolGroupForViewport,
        getAllToolGroups,
        getToolGroupsWithToolName
    }
}
export { ToolGroupManager }

// @public (undocumented)
type ToolGroupSpecificContourRepresentation = ToolGroupSpecificRepresentationState & {
    config: ContourRenderingConfig;
    segmentationRepresentationSpecificConfig?: RepresentationConfig;
    segmentSpecificConfig?: SegmentSpecificRepresentationConfig;
};

// @public (undocumented)
type ToolGroupSpecificLabelmapRepresentation = ToolGroupSpecificRepresentationState & {
    config: LabelmapRenderingConfig;
    segmentationRepresentationSpecificConfig?: RepresentationConfig;
    segmentSpecificConfig?: SegmentSpecificRepresentationConfig;
};

// @public (undocumented)
type ToolGroupSpecificRepresentation = ToolGroupSpecificLabelmapRepresentation | ToolGroupSpecificContourRepresentation;

// @public (undocumented)
type ToolGroupSpecificRepresentationState = {
    segmentationRepresentationUID: string;
    segmentationId: string;
    type: Enums.SegmentationRepresentations;
    active: boolean;
    segmentsHidden: Set<number>;
    colorLUTIndex: number;
    polySeg?: {
        enabled: boolean;
        options?: any;
    };
};

// @public (undocumented)
type ToolHandle = AnnotationHandle | TextBoxHandle;

// @public (undocumented)
type ToolModeChangedEventDetail = {
    toolGroupId: string;
    toolName: string;
    mode: ToolModes;
    toolBindingsOptions?: SetToolBindingsType;
};

// @public (undocumented)
type ToolModeChangedEventType = Types_2.CustomEventType<ToolModeChangedEventDetail>;

// @public (undocumented)
enum ToolModes {
    // (undocumented)
    Active = "Active",
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled",
    // (undocumented)
    Passive = "Passive"
}

// @public (undocumented)
type ToolOptionsType = {
    bindings: IToolBinding[];
    mode: ToolModes;
};

// @public (undocumented)
type ToolProps = SharedToolProp;

declare namespace ToolSpecificAnnotationTypes {
    export {
        RectangleROIAnnotation,
        ProbeAnnotation,
        LengthAnnotation,
        AdvancedMagnifyAnnotation,
        CircleROIAnnotation,
        SplineROIAnnotation,
        SplineContourSegmentationAnnotation,
        LivewireContourAnnotation,
        LivewireContourSegmentationAnnotation,
        EllipticalROIAnnotation,
        BidirectionalAnnotation,
        RectangleROIThresholdAnnotation,
        RectangleROIStartEndThresholdAnnotation,
        CircleROIStartEndThresholdAnnotation,
        PlanarFreehandROIAnnotation,
        PlanarFreehandContourSegmentationAnnotation,
        InterpolationROIAnnotation,
        ArrowAnnotation,
        AngleAnnotation,
        UltrasoundDirectionalAnnotation,
        CobbAngleAnnotation,
        ReferenceCursor,
        ReferenceLineAnnotation,
        ScaleOverlayAnnotation,
        VideoRedactionAnnotation,
        ContourAnnotation
    }
}

// @public (undocumented)
const toolStyle: ToolStyle;

// @public (undocumented)
type ToolStyleConfig = {
    [toolName: string]: AnnotationStyle_2;
} & {
    global?: AnnotationStyle_2;
};

declare namespace touch {
    export {
        getMeanPoints,
        getMeanTouchPoints,
        copyPoints,
        copyPointsList,
        getDeltaDistanceBetweenIPoints,
        getDeltaPoints,
        getDeltaDistance,
        getDeltaRotation
    }
}

// @public (undocumented)
type TouchDragEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & TouchPointsDetail;

// @public (undocumented)
type TouchDragEventType = Types_2.CustomEventType<TouchDragEventDetail>;

// @public (undocumented)
type TouchEndEventDetail = NormalizedInteractionEventDetail & TouchPointsDetail & TouchCustomEventDetail;

// @public (undocumented)
type TouchEndEventType = Types_2.CustomEventType<TouchEndEventDetail>;

// @public (undocumented)
type TouchPressEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & {
    startPointsList: ITouchPoints[];
    lastPointsList: ITouchPoints[];
    startPoints: ITouchPoints;
    lastPoints: ITouchPoints;
};

// @public (undocumented)
type TouchPressEventType = Types_2.CustomEventType<TouchPressEventDetail>;

// @public (undocumented)
type TouchStartActivateEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & TouchPointsDetail;

// @public (undocumented)
type TouchStartActivateEventType = Types_2.CustomEventType<TouchStartActivateEventDetail>;

// @public (undocumented)
type TouchStartEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & TouchPointsDetail;

// @public (undocumented)
type TouchStartEventType = Types_2.CustomEventType<TouchStartEventDetail>;

// @public (undocumented)
type TouchSwipeEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & {
    swipe: Swipe;
};

// @public (undocumented)
type TouchSwipeEventType = Types_2.CustomEventType<TouchSwipeEventDetail>;

// @public (undocumented)
type TouchTapEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & {
    currentPointsList: ITouchPoints[];
    currentPoints: ITouchPoints;
    taps: number;
};

// @public (undocumented)
type TouchTapEventType = Types_2.CustomEventType<TouchTapEventDetail>;

// @public (undocumented)
export class TrackballRotateTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    cleanUp: () => void;
    // (undocumented)
    _dragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    mouseDragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    rotateCamera: (viewport: any, centerWorld: any, axis: any, angle: any) => void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: (evt: EventTypes_2.InteractionEventType) => void;
}

// @public (undocumented)
function triggerAnnotationRender(element: HTMLDivElement): void;

// @public (undocumented)
function triggerAnnotationRenderForToolGroupIds(toolGroupIds: string[]): void;

// @public (undocumented)
function triggerAnnotationRenderForViewportIds(renderingEngine: Types_2.IRenderingEngine, viewportIdsToRender: string[]): void;

// @public (undocumented)
function triggerEvent(el: EventTarget, type: string, detail?: unknown): boolean;

// @public (undocumented)
function triggerSegmentationDataModified(segmentationId: string, modifiedSlicesToUse?: number[]): void;

declare namespace triggerSegmentationEvents {
    export {
        triggerSegmentationRepresentationModified,
        triggerSegmentationRepresentationRemoved,
        triggerSegmentationDataModified,
        triggerSegmentationModified,
        triggerSegmentationRemoved
    }
}

// @public (undocumented)
function triggerSegmentationModified(segmentationId?: string): void;

// @public (undocumented)
function triggerSegmentationRemoved(segmentationId: string): void;

// @public (undocumented)
function triggerSegmentationRender(toolGroupId: string): void;

// @public (undocumented)
function triggerSegmentationRepresentationModified(toolGroupId: string, segmentationRepresentationUID?: string): void;

// @public (undocumented)
function triggerSegmentationRepresentationRemoved(toolGroupId: string, segmentationRepresentationUID: string): void;

declare namespace Types {
    export {
        Annotation,
        Annotations,
        ContourAnnotationData,
        ContourAnnotation,
        ContourSegmentationAnnotationData,
        ContourSegmentationAnnotation,
        BidirectionalData,
        CanvasCoordinates,
        IAnnotationManager,
        InterpolationViewportData,
        ImageInterpolationData,
        GroupSpecificAnnotations,
        AnnotationState,
        AnnotationStyle,
        ToolSpecificAnnotationTypes,
        JumpToSliceOptions,
        AnnotationGroupSelector,
        AnnotationRenderContext,
        PlanarBoundingBox,
        ToolProps,
        PublicToolProps,
        ToolConfiguration,
        EventTypes_2 as EventTypes,
        IPoints,
        ITouchPoints,
        IDistance,
        IToolBinding,
        SetToolBindingsType,
        ToolOptionsType,
        InteractionTypes,
        ToolAction,
        ToolGroup as IToolGroup,
        IToolClassReference,
        ISynchronizerEventHandler,
        ToolHandle,
        AnnotationHandle,
        TextBoxHandle,
        Segmentation,
        SegmentationState,
        SegmentationRepresentationData,
        SegmentationRepresentationConfig,
        RepresentationConfig,
        ToolGroupSpecificRepresentationState,
        ToolGroupSpecificContourRepresentation,
        ToolGroupSpecificLabelmapRepresentation,
        ToolGroupSpecificRepresentation,
        RepresentationPublicInput,
        LabelmapTypes,
        SVGCursorDescriptor,
        SVGPoint_2 as SVGPoint,
        ScrollOptions_2 as ScrollOptions,
        CINETypes,
        BoundsIJK_2 as BoundsIJK,
        SVGDrawingHelper,
        FloodFillResult,
        FloodFillGetter,
        FloodFillOptions,
        ContourSegmentationData,
        Statistics,
        NamedStatistics,
        LabelmapToolOperationData,
        LabelmapToolOperationDataStack,
        LabelmapToolOperationDataVolume,
        CardinalSplineProps,
        ClosestControlPoint,
        ClosestPoint,
        ClosestSplinePoint,
        ControlPointInfo,
        ISpline,
        SplineCurveSegment,
        SplineLineSegment,
        SplineProps,
        PolySegConversionOptions
    }
}
export { Types }

declare namespace Types_3 {
    export {
        ColorbarCommonProps,
        ColorbarProps,
        ColorbarImageRange,
        ColorbarVOIRange,
        ColorbarSize,
        ColorbarTicksProps,
        ColorbarTicksStyle,
        ViewportColorbarProps
    }
}

// @public (undocumented)
interface UltrasoundDirectionalAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                xValues: number[];
                yValues: number[];
                units: string[];
                isHorizontal: boolean;
                isUnitless: boolean;
            };
        };
    };
}

// @public (undocumented)
export class UltrasoundDirectionalTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => UltrasoundDirectionalAnnotation;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: UltrasoundDirectionalAnnotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: UltrasoundDirectionalAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    startedDrawing: boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: Annotation, interactionType: InteractionTypes, canvasCoords?: Types_2.Point2): void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function unlockAllAnnotations(): void;

// @public (undocumented)
function updateContourPolyline(annotation: ContourAnnotation, polylineData: {
    points: Types_2.Point2[];
    closed?: boolean;
    targetWindingDirection?: ContourWindingDirection;
}, transforms: {
    canvasToWorld: (point: Types_2.Point2) => Types_2.Point3;
}, options?: {
    decimate?: {
        enabled?: boolean;
        epsilon?: number;
    };
}): void;

declare namespace utilities {
    export {
        math,
        planar,
        viewportFilters,
        drawing_2 as drawing,
        debounce,
        dynamicVolume,
        throttle,
        orientation_2 as orientation,
        isObject,
        touch,
        triggerEvent,
        calibrateImageSpacing,
        getCalibratedLengthUnits,
        getCalibratedAreaUnits,
        getCalibratedScale,
        segmentation_2 as segmentation,
        contours,
        triggerAnnotationRenderForViewportIds,
        triggerAnnotationRenderForToolGroupIds,
        triggerAnnotationRender,
        pointInShapeCallback,
        getSphereBoundsInfo,
        getAnnotationNearPoint,
        getViewportForAnnotation,
        getAnnotationNearPointOnEnabledElement,
        jumpToSlice,
        pointInSurroundingSphereCallback,
        viewport,
        cine,
        clip_2 as clip,
        boundingBox,
        rectangleROITool,
        planarFreehandROITool,
        stackPrefetch,
        stackContextPrefetch,
        scroll_2 as scroll,
        roundNumber,
        pointToString,
        polyDataUtils,
        voi,
        AnnotationFrameRange as annotationFrameRange,
        contourSegmentation
    }
}
export { utilities }

declare namespace vec2 {
    export {
        findClosestPoint,
        clip as liangBarksyClip
    }
}

// @public (undocumented)
interface VideoRedactionAnnotation extends Annotation {
    // (undocumented)
    data: {
        invalidated: boolean;
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
        };
        cachedStats: {
            [key: string]: any;
        };
        active: boolean;
    };
    // (undocumented)
    metadata: {
        viewPlaneNormal: Types_2.Point3;
        viewUp: Types_2.Point3;
        FrameOfReferenceUID: string;
        referencedImageId: string;
        toolName: string;
    };
}

// @public (undocumented)
export class VideoRedactionTool extends AnnotationTool {
    constructor(toolConfiguration?: {});
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => VideoRedactionAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewPlaneNormal: any, viewUp: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel(element: any): any;
    // (undocumented)
    _configuration: any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportUIDsToRender: string[];
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    getHandleNearImagePoint: (element: any, annotation: any, canvasCoords: any, proximity: any) => any;
    // (undocumented)
    _getImageVolumeFromTargetUID(targetUID: any, renderingEngine: any): {
        imageVolume: any;
        viewport: any;
    };
    // (undocumented)
    _getRectangleImageCoordinates: (points: Array<Types_2.Point2>) => {
        left: number;
        top: number;
        width: number;
        height: number;
    };
    // (undocumented)
    _getTargetStackUID(viewport: any): string;
    // (undocumented)
    _getTargetVolumeUID: (scene: any) => any;
    // (undocumented)
    handleSelectedCallback: (evt: any, annotation: any, handle: any, interactionType?: string) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: any, annotation: any, canvasCoords: any, proximity: any) => boolean;
    // (undocumented)
    _mouseDragCallback: (evt: any) => void;
    // (undocumented)
    _mouseUpCallback: (evt: any) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    toolSelectedCallback: (evt: any, annotation: any, interactionType?: string) => void;
}

declare namespace viewport {
    export {
        isViewportPreScaled,
        jumpToSlice,
        jumpToWorld
    }
}

// @public (undocumented)
class ViewportColorbar extends Colorbar {
    constructor(props: ViewportColorbarProps);
    // (undocumented)
    get element(): HTMLDivElement;
    // (undocumented)
    get enabledElement(): Types_2.IEnabledElement;
    // (undocumented)
    protected getVOIMultipliers(): [number, number];
    // (undocumented)
    protected onVoiChange(voiRange: ColorbarVOIRange): void;
}

// @public (undocumented)
type ViewportColorbarProps = ColorbarProps & {
    element: HTMLDivElement;
    volumeId?: string;
};

declare namespace viewportFilters {
    export {
        filterViewportsWithToolEnabled,
        filterViewportsWithFrameOfReferenceUID,
        getViewportIdsWithToolToRender,
        filterViewportsWithParallelNormals
    }
}

declare namespace visibility {
    export {
        setAnnotationVisibility,
        showAllAnnotations,
        isAnnotationVisible,
        checkAndDefineIsVisibleProperty
    }
}

declare namespace visibility_2 {
    export {
        setSegmentationVisibility,
        getSegmentationVisibility,
        setSegmentVisibility,
        setSegmentsVisibility,
        getSegmentVisibility
    }
}

declare namespace voi {
    export {
        colorbar
    }
}

// @public (undocumented)
export class VolumeRotateMouseWheelTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _configuration: any;
    // (undocumented)
    mouseWheelCallback(evt: MouseWheelEventType): void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
type VolumeScrollOutOfBoundsEventDetail = {
    volumeId: string;
    viewport: Types_2.IVolumeViewport;
    desiredStepIndex: number;
    currentStepIndex: number;
    delta: number;
    numScrollSteps: number;
    currentImageId: string;
};

// @public (undocumented)
type VolumeScrollOutOfBoundsEventType = Types_2.CustomEventType<VolumeScrollOutOfBoundsEventDetail>;

// @public (undocumented)
export class WindowLevelTool extends BaseTool {
    constructor(toolProps?: {}, defaultToolProps?: {
        supportedInteractionTypes: string[];
    });
    // (undocumented)
    _getImageDynamicRangeFromMiddleSlice: (scalarData: any, dimensions: any) => number;
    // (undocumented)
    _getImageDynamicRangeFromViewport(viewport: any): number;
    // (undocumented)
    _getMultiplierFromDynamicRange(viewport: any, volumeId: any): number;
    // (undocumented)
    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }: {
        viewport: any;
        deltaPointsCanvas: any;
        volumeId: any;
        lower: any;
        upper: any;
    }): {
        lower: number;
        upper: number;
    };
    // (undocumented)
    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }: {
        deltaPointsCanvas: any;
        lower: any;
        upper: any;
        clientHeight: any;
        viewport: any;
        volumeId: any;
        isPreScaled: any;
    }): {
        lower: any;
        upper: any;
    };
    // (undocumented)
    mouseDragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback(evt: EventTypes_2.InteractionEventType): void;
}

// @public (undocumented)
export class ZoomTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    dirVec: Types_2.Point3;
    // (undocumented)
    _dragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    _dragParallelProjection: (evt: EventTypes_2.InteractionEventType, viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, camera: Types_2.ICamera, pinch?: boolean) => void;
    // (undocumented)
    _dragPerspectiveProjection: (evt: EventTypes_2.InteractionEventType, viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, camera: Types_2.ICamera, pinch?: boolean) => void;
    // (undocumented)
    initialMousePosWorld: Types_2.Point3;
    // (undocumented)
    mouseDragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _panCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    _pinchCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    preTouchStartCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: (evt: EventTypes_2.InteractionEventType) => void;
}

// (No @packageDocumentation comment for this package)

```

## API Report File for "@cornerstonejs/tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { mat4 } from 'gl-matrix';
import type vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';
import type { vtkColorTransferFunction } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';
import type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';
import vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import type { vtkPiecewiseFunction } from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';
import type vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';

declare namespace activeSegmentation {
    export {
        getActiveSegmentationRepresentation,
        setActiveSegmentationRepresentation
    }
}

// @public (undocumented)
type Actor = vtkActor;

// @public
type ActorEntry = {
    uid: string;
    actor: Actor | VolumeActor | ImageActor;
    referenceId?: string;
    slabThickness?: number;
};

// @public
type ActorSliceRange = {
    actor: VolumeActor;
    viewPlaneNormal: Point3;
    focalPoint: Point3;
    min: number;
    max: number;
    current: number;
};

// @public (undocumented)
function addAnnotation(annotation: Annotation, annotationGroupSelector: AnnotationGroupSelector): string;

// @public (undocumented)
const addCanvasPointsToArray: (element: HTMLDivElement, canvasPoints: Types_2.Point2[], newCanvasPoint: Types_2.Point2, commonData: PlanarFreehandROICommonData) => number;

// @public (undocumented)
function addColorLUT(colorLUT: ColorLUT, index: number): void;

// @public (undocumented)
function addColorLUT_2(colorLUT: ColorLUT, colorLUTIndex: number): void;

// @public (undocumented)
function addSegmentation(segmentationInput: SegmentationPublicInput, suppressEvents?: boolean): void;

// @public (undocumented)
function addSegmentationRepresentation(toolGroupId: string, segmentationRepresentation: ToolGroupSpecificRepresentation, suppressEvents?: boolean): void;

// @public (undocumented)
function addSegmentationRepresentations(toolGroupId: string, representationInputArray: RepresentationPublicInput[], toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig): Promise<string[]>;

// @public (undocumented)
function addSegmentations(segmentationInputArray: SegmentationPublicInput[]): void;

// @public (undocumented)
export function addTool(ToolClass: any): void;

// @public (undocumented)
function addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void;

// @public (undocumented)
interface AngleAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                angle: number;
            };
        };
    };
}

// @public (undocumented)
export class AngleTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => AngleAnnotation;
    // (undocumented)
    angleStartedNotYetCompleted: boolean;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getTextLines(data: any, targetId: any): string[];
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: AngleAnnotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: AngleAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: AngleAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
type Annotation = {
    annotationUID?: string;
    highlighted?: boolean;
    isLocked?: boolean;
    isVisible?: boolean;
    invalidated?: boolean;
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        FrameOfReferenceUID: string;
        toolName: string;
        referencedImageId?: string;
        volumeId?: string;
    };
    data: {
        handles?: {
            points?: Types_2.Point3[];
            activeHandleIndex?: number | null;
            textBox?: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
            [key: string]: any;
        };
        [key: string]: any;
        cachedStats?: unknown;
    };
};

declare namespace annotation {
    export {
        config,
        locking,
        selection,
        state_2 as state,
        visibility,
        FrameOfReferenceSpecificAnnotationManager
    }
}
export { annotation }

// @public (undocumented)
type AnnotationAddedEventDetail = {
    viewportId: string;
    renderingEngineId: string;
    annotation: Annotation;
};

// @public (undocumented)
type AnnotationAddedEventType = Types_2.CustomEventType<AnnotationAddedEventDetail>;

// @public (undocumented)
type AnnotationCompletedEventDetail = {
    annotation: Annotation;
};

// @public (undocumented)
type AnnotationCompletedEventType = Types_2.CustomEventType<AnnotationCompletedEventDetail>;

// @public (undocumented)
type AnnotationGroupSelector = HTMLDivElement | string;

// @public (undocumented)
type AnnotationHandle = Types_2.Point3;

// @public (undocumented)
type AnnotationLockChangeEventDetail = {
    added: Array<Annotation>;
    removed: Array<Annotation>;
    locked: Array<Annotation>;
};

// @public (undocumented)
type AnnotationLockChangeEventType = Types_2.CustomEventType<AnnotationLockChangeEventDetail>;

// @public (undocumented)
type AnnotationModifiedEventDetail = {
    viewportId: string;
    renderingEngineId: string;
    annotation: Annotation;
};

// @public (undocumented)
type AnnotationModifiedEventType = Types_2.CustomEventType<AnnotationModifiedEventDetail>;

// @public (undocumented)
type AnnotationRemovedEventDetail = {
    annotation: Annotation;
    annotationManagerUID: string;
};

// @public (undocumented)
type AnnotationRemovedEventType = Types_2.CustomEventType<AnnotationRemovedEventDetail>;

// @public (undocumented)
type AnnotationRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type AnnotationRenderedEventType = Types_2.CustomEventType<AnnotationRenderedEventDetail>;

// @public (undocumented)
type Annotations = Array<Annotation>;

// @public (undocumented)
type AnnotationSelectionChangeEventDetail = {
    added: Array<string>;
    removed: Array<string>;
    selection: Array<string>;
};

// @public (undocumented)
type AnnotationSelectionChangeEventType = Types_2.CustomEventType<AnnotationSelectionChangeEventDetail>;

// @public (undocumented)
type AnnotationState = {
    [key: string]: GroupSpecificAnnotations;
};

declare namespace AnnotationStyle {
    export {
        AnnotationStyle_2 as AnnotationStyle,
        ToolStyleConfig,
        StyleConfig,
        StyleSpecifier
    }
}

// @public (undocumented)
type AnnotationStyle_2 = {
    [key in `${Properties}${States}${Modes}`]?: string;
};

// @public (undocumented)
enum AnnotationStyleStates {
    // (undocumented)
    Default = "",
    // (undocumented)
    Highlighted = "Highlighted",
    // (undocumented)
    Locked = "Locked",
    // (undocumented)
    Selected = "Selected"
}

// @public (undocumented)
export abstract class AnnotationTool extends AnnotationDisplayTool {
    // (undocumented)
    abstract addNewAnnotation(evt: EventTypes_2.InteractionEventType, interactionType: InteractionTypes): Annotation;
    // (undocumented)
    abstract cancel(element: HTMLDivElement): any;
    // (undocumented)
    getHandleNearImagePoint(element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    getLinkedTextBoxStyle(specifications: StyleSpecifier, annotation?: Annotation): Record<string, unknown>;
    // (undocumented)
    abstract handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: Annotation, handle: ToolHandle, interactionType: InteractionTypes): void;
    // (undocumented)
    abstract isPointNearTool(element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number, interactionType: string): boolean;
    // (undocumented)
    isSuvScaled(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, targetId: string, imageId?: string): boolean;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.MouseMoveEventType, filteredAnnotations?: Annotations) => boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    abstract toolSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: Annotation, interactionType: InteractionTypes): void;
}

// @public (undocumented)
type AnnotationVisibilityChangeEventDetail = {
    lastHidden: Array<string>;
    lastVisible: Array<string>;
    hidden: Array<string>;
};

// @public (undocumented)
type AnnotationVisibilityChangeEventType = Types_2.CustomEventType<AnnotationVisibilityChangeEventDetail>;

// @public (undocumented)
export class ArrowAnnotateTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => ArrowAnnotation;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _doneChangingTextCallback(element: any, annotation: any, updatedText: any): void;
    // (undocumented)
    doubleClickCallback: (evt: EventTypes_2.TouchTapEventType) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: ArrowAnnotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume(index1: any, index2: any, dimensions: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: ArrowAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: ArrowAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
    // (undocumented)
    touchTapCallback: (evt: EventTypes_2.TouchTapEventType) => void;
}

// @public (undocumented)
interface ArrowAnnotation extends Annotation {
    // (undocumented)
    data: {
        text: string;
        handles: {
            points: Types_2.Point3[];
            arrowFirst: boolean;
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
    };
}

// @public (undocumented)
export abstract class BaseTool implements IBaseTool {
    constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps);
    // (undocumented)
    applyActiveStrategy(enabledElement: Types_2.IEnabledElement, operationData: unknown): any;
    // (undocumented)
    configuration: Record<string, any>;
    // (undocumented)
    protected getTargetId(viewport: Types_2.IViewport): string | undefined;
    // (undocumented)
    protected getTargetIdImage(targetId: string, renderingEngine: Types_2.IRenderingEngine): Types_2.IImageData | Types_2.CPUIImageData | Types_2.IImageVolume;
    // (undocumented)
    getToolName(): string;
    // (undocumented)
    mode: ToolModes;
    // (undocumented)
    setActiveStrategy(strategyName: string): void;
    // (undocumented)
    setConfiguration(newConfiguration: Record<string, any>): void;
    // (undocumented)
    supportedInteractionTypes: InteractionTypes[];
    // (undocumented)
    toolGroupId: string;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
interface BidirectionalAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                length: number;
                width: number;
                unit: string;
            };
        };
    };
}

// @public (undocumented)
export class BidirectionalTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation(evt: EventTypes_2.InteractionEventType): BidirectionalAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    _calculateLength(pos1: any, pos2: any): number;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragDrawCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyHandle: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getSignedAngle: (vector1: any, vector2: any) => number;
    // (undocumented)
    _getTextLines: (data: any, targetId: any) => string[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: BidirectionalAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, index3: any, index4: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: BidirectionalAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _movingLongAxisWouldPutItThroughShortAxis: (firstLineSegment: any, secondLineSegment: any) => boolean;
    // (undocumented)
    preventHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: BidirectionalAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace boundingBox {
    export {
        extend2DBoundingBoxInViewAxis,
        getBoundingBoxAroundShape
    }
}

// @public (undocumented)
type BoundsIJK = [Types_2.Point2, Types_2.Point2, Types_2.Point2];

// @public (undocumented)
export class BrushTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    invalidateBrushCursor(): void;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    onSetToolDisabled: () => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    onSetToolPassive: () => void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.MouseDownActivateEventType) => boolean;
    // (undocumented)
    renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
function calculateAreaOfPoints(points: Types_2.Point2[]): number;

// @public (undocumented)
function calibrateImageSpacing(imageId: string, renderingEngine: Types_2.IRenderingEngine, rowPixelSpacing: number, columnPixelSpacing: number): void;

// @public
type CameraModifiedEvent = CustomEvent_2<CameraModifiedEventDetail>;

// @public
type CameraModifiedEventDetail = {
    previousCamera: ICamera;
    camera: ICamera;
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    rotation?: number;
};

// @public (undocumented)
export function cancelActiveManipulations(element: HTMLDivElement): string | undefined;

// @public (undocumented)
function checkAndDefineIsLockedProperty(annotation: Annotation): void;

// @public (undocumented)
function checkAndDefineIsVisibleProperty(annotation: Annotation): void;

declare namespace cine {
    export {
        playClip,
        stopClip,
        Events_2 as Events,
        getToolState,
        addToolState
    }
}

// @public (undocumented)
type CinePlayContext = {
    get numScrollSteps(): number;
    get currentStepIndex(): number;
    get frameTimeVectorEnabled(): boolean;
    scroll(delta: number): void;
};

declare namespace CINETypes {
    export {
        PlayClipOptions,
        ToolData,
        CinePlayContext
    }
}

// @public (undocumented)
interface CircleROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: [Types_2.Point3, Types_2.Point3];
            activeHandleIndex: number | null;
            textBox?: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats?: ROICachedStats & {
            [targetId: string]: {
                radius: number;
                radiusUnit: string;
                perimeter: number;
            };
        };
    };
}

// @public (undocumented)
export class CircleROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => CircleROIAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewport: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragDrawCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragHandle: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getTextLines: (data: any, targetId: string, isPreScaled: boolean, isSuvScaled: boolean) => string[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: CircleROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: CircleROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: CircleROIAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
export class CircleScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentation: any;
        segmentIndex: number;
        segmentationId: string;
        segmentsLocked: number[];
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        centerCanvas?: Array<number>;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
function clip(a: any, b: any, box: any, da?: any, db?: any): 1 | 0;

// @public (undocumented)
function clip_2(val: number, low: number, high: number): number;

// @public (undocumented)
export class CobbAngleTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => AngleAnnotation;
    // (undocumented)
    angleStartedNotYetCompleted: boolean;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getTextLines(data: any, targetId: any): string[];
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: AngleAnnotation, handle: ToolHandle, interactionType?: string): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: AngleAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType | EventTypes_2.MouseMoveEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: AngleAnnotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
type Color = [number, number, number, number];

declare namespace color {
    export {
        getColorForSegmentIndex,
        addColorLUT_2 as addColorLUT,
        setColorLUT,
        setColorForSegmentIndex
    }
}

// @public (undocumented)
type ColorLUT = Array<Color>;

// @public (undocumented)
type ColormapPublic = {
    name: string;
    opacityMapping?: OpacityMapping[];
};

// @public (undocumented)
type ColormapRegistration = {
    ColorSpace: string;
    Name: string;
    RGBPoints: RGB[];
};

declare namespace config {
    export {
        getState,
        getFont,
        toolStyle as style
    }
}

declare namespace config_2 {
    export {
        color,
        visibility_2 as visibility,
        getGlobalConfig_2 as getGlobalConfig,
        getGlobalRepresentationConfig,
        getToolGroupSpecificConfig_2 as getToolGroupSpecificConfig,
        setGlobalConfig_2 as setGlobalConfig,
        setGlobalRepresentationConfig,
        setToolGroupSpecificConfig_2 as setToolGroupSpecificConfig,
        setSegmentSpecificConfig,
        getSegmentSpecificConfig,
        setSegmentationRepresentationSpecificConfig_2 as setSegmentationRepresentationSpecificConfig,
        getSegmentationRepresentationSpecificConfig_2 as getSegmentationRepresentationSpecificConfig
    }
}

declare namespace CONSTANTS {
    export {
        CORNERSTONE_COLOR_LUT as COLOR_LUT
    }
}
export { CONSTANTS }

// @public (undocumented)
type ContourData = {
    points: Point3[];
    type: ContourType;
    color: Point3;
    segmentIndex: number;
};

// @public (undocumented)
type ContourSegmentationData = {
    geometryIds: string[];
};

// @public (undocumented)
type ContourSetData = {
    id: string;
    data: ContourData[];
    frameOfReferenceUID: string;
    color?: Point3;
    segmentIndex?: number;
};

// @public (undocumented)
function copyPoints(points: ITouchPoints): ITouchPoints;

// @public (undocumented)
function copyPointsList(points: ITouchPoints[]): ITouchPoints[];

// @public (undocumented)
type Cornerstone3DConfig = {
    detectGPU: any;
    rendering: {
        // vtk.js supports 8bit integer textures and 32bit float textures.
        // However, if the client has norm16 textures (it can be seen by visiting
        // the webGl report at https://webglreport.com/?v=2), vtk will be default
        // to use it to improve memory usage. However, if the client don't have
        // it still another level of optimization can happen by setting the
        // preferSizeOverAccuracy since it will reduce the size of the texture to half
        // float at the cost of accuracy in rendering. This is a tradeoff that the
        // client can decide.
        //
        // Read more in the following Pull Request:
        // 1. HalfFloat: https://github.com/Kitware/vtk-js/pull/2046
        // 2. Norm16: https://github.com/Kitware/vtk-js/pull/2058
        preferSizeOverAccuracy: boolean;
        // Whether the EXT_texture_norm16 extension is supported by the browser.
        // WebGL 2 report (link: https://webglreport.com/?v=2) can be used to check
        // if the browser supports this extension.
        // In case the browser supports this extension, instead of using 32bit float
        // textures, 16bit float textures will be used to reduce the memory usage where
        // possible.
        // Norm16 may not work currently due to the two active bugs in chrome + safari
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1408247
        // https://bugs.webkit.org/show_bug.cgi?id=252039
        useNorm16Texture: boolean;
        useCPURendering: boolean;
        strictZSpacingForVolumeViewport: boolean;
    };
};

// @public (undocumented)
const CORNERSTONE_COLOR_LUT: number[][];

// @public (undocumented)
interface CPUFallbackColormap {
    // (undocumented)
    addColor: (rgba: Point4) => void;
    // (undocumented)
    buildLookupTable: (lut: CPUFallbackLookupTable) => void;
    // (undocumented)
    clearColors: () => void;
    // (undocumented)
    createLookupTable: () => CPUFallbackLookupTable;
    // (undocumented)
    getColor: (index: number) => Point4;
    // (undocumented)
    getColorRepeating: (index: number) => Point4;
    // (undocumented)
    getColorSchemeName: () => string;
    getId: () => string;
    // (undocumented)
    getNumberOfColors: () => number;
    // (undocumented)
    insertColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    isValidIndex: (index: number) => boolean;
    // (undocumented)
    removeColor: (index: number) => void;
    // (undocumented)
    setColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    setColorSchemeName: (name: string) => void;
    // (undocumented)
    setNumberOfColors: (numColors: number) => void;
}

// @public (undocumented)
type CPUFallbackColormapData = {
    name: string;
    numOfColors?: number;
    colors?: Point4[];
    segmentedData?: unknown;
    numColors?: number;
    gamma?: number;
};

// @public (undocumented)
type CPUFallbackColormapsData = {
    [key: string]: CPUFallbackColormapData;
};

// @public (undocumented)
interface CPUFallbackEnabledElement {
    // (undocumented)
    canvas?: HTMLCanvasElement;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    image?: IImage;
    // (undocumented)
    invalid?: boolean;
    // (undocumented)
    metadata?: {
        direction?: Mat3;
        dimensions?: Point3;
        spacing?: Point3;
        origin?: Point3;
        imagePlaneModule?: ImagePlaneModule;
        imagePixelModule?: ImagePixelModule;
    };
    // (undocumented)
    needsRedraw?: boolean;
    // (undocumented)
    options?: {
        [key: string]: unknown;
        colormap?: CPUFallbackColormap;
    };
    // (undocumented)
    pan?: Point2;
    // (undocumented)
    renderingTools?: CPUFallbackRenderingTools;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    transform?: CPUFallbackTransform;
    // (undocumented)
    viewport?: CPUFallbackViewport;
    // (undocumented)
    zoom?: number;
}

// @public (undocumented)
interface CPUFallbackLookupTable {
    // (undocumented)
    build: (force: boolean) => void;
    // (undocumented)
    getColor: (scalar: number) => Point4;
    // (undocumented)
    setAlphaRange: (start: number, end: number) => void;
    // (undocumented)
    setHueRange: (start: number, end: number) => void;
    // (undocumented)
    setNumberOfTableValues: (number: number) => void;
    // (undocumented)
    setRamp: (ramp: string) => void;
    // (undocumented)
    setRange: (start: number, end: number) => void;
    // (undocumented)
    setSaturationRange: (start: number, end: number) => void;
    // (undocumented)
    setTableRange: (start: number, end: number) => void;
    // (undocumented)
    setTableValue(index: number, rgba: Point4);
    // (undocumented)
    setValueRange: (start: number, end: number) => void;
}

// @public (undocumented)
type CPUFallbackLUT = {
    lut: number[];
};

// @public (undocumented)
type CPUFallbackRenderingTools = {
    renderCanvas?: HTMLCanvasElement;
    lastRenderedIsColor?: boolean;
    lastRenderedImageId?: string;
    lastRenderedViewport?: {
        windowWidth: number | number[];
        windowCenter: number | number[];
        invert: boolean;
        rotation: number;
        hflip: boolean;
        vflip: boolean;
        modalityLUT: CPUFallbackLUT;
        voiLUT: CPUFallbackLUT;
        colormap: unknown;
    };
    renderCanvasContext?: CanvasRenderingContext2D;
    colormapId?: string;
    colorLUT?: CPUFallbackLookupTable;
    renderCanvasData?: ImageData;
};

// @public (undocumented)
interface CPUFallbackTransform {
    // (undocumented)
    clone: () => CPUFallbackTransform;
    // (undocumented)
    getMatrix: () => TransformMatrix2D;
    // (undocumented)
    invert: () => void;
    // (undocumented)
    multiply: (matrix: TransformMatrix2D) => void;
    // (undocumented)
    reset: () => void;
    // (undocumented)
    rotate: (rad: number) => void;
    // (undocumented)
    scale: (sx: number, sy: number) => void;
    // (undocumented)
    transformPoint: (point: Point2) => Point2;
    // (undocumented)
    translate: (x: number, y: number) => void;
}

// @public (undocumented)
type CPUFallbackViewport = {
    scale?: number;
    parallelScale?: number;
    focalPoint?: number[];
    translation?: {
        x: number;
        y: number;
    };
    voi?: {
        windowWidth: number;
        windowCenter: number;
    };
    invert?: boolean;
    pixelReplication?: boolean;
    rotation?: number;
    hflip?: boolean;
    vflip?: boolean;
    modalityLUT?: CPUFallbackLUT;
    voiLUT?: CPUFallbackLUT;
    colormap?: CPUFallbackColormap;
    displayedArea?: CPUFallbackViewportDisplayedArea;
    modality?: string;
};

// @public (undocumented)
type CPUFallbackViewportDisplayedArea = {
    tlhc: {
        x: number;
        y: number;
    };
    brhc: {
        x: number;
        y: number;
    };
    rowPixelSpacing: number;
    columnPixelSpacing: number;
    presentationSizeMode: string;
};

// @public (undocumented)
type CPUIImageData = {
    dimensions: Point3;
    direction: Mat3;
    spacing: Point3;
    origin: Point3;
    imageData: CPUImageData;
    metadata: { Modality: string };
    scalarData: PixelDataTypedArray;
    scaling: Scaling;
    hasPixelSpacing?: boolean;
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
};

// @public (undocumented)
type CPUImageData = {
    worldToIndex?: (point: Point3) => Point3;
    indexToWorld?: (point: Point3) => Point3;
    getWorldToIndex?: () => Point3;
    getIndexToWorld?: () => Point3;
    getSpacing?: () => Point3;
    getDirection?: () => Mat3;
    getScalarData?: () => PixelDataTypedArray;
    getDimensions?: () => Point3;
};

// @public (undocumented)
function createCameraPositionSynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
function createLabelmapVolumeForViewport(input: {
    viewportId: string;
    renderingEngineId: string;
    segmentationId?: string;
    options?: {
        volumeId?: string;
        scalarData?: Float32Array | Uint8Array | Uint16Array | Int16Array;
        targetBuffer?: {
            type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';
        };
        metadata?: any;
        dimensions?: Types_2.Point3;
        spacing?: Types_2.Point3;
        origin?: Types_2.Point3;
        direction?: Float32Array;
    };
}): Promise<string>;

// @public (undocumented)
function createMergedLabelmapForIndex(labelmaps: Array<Types_2.IImageVolume>, segmentIndex?: number, volumeId?: string): Types_2.IImageVolume;

// @public (undocumented)
function createStackImageSynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
function createSynchronizer(synchronizerId: string, eventName: string, eventHandler: ISynchronizerEventHandler): Synchronizer;

// @public (undocumented)
function createToolGroup(toolGroupId: string): IToolGroup | undefined;

// @public (undocumented)
function createVOISynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
function createZoomPanSynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
export class CrosshairsTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => CrosshairsAnnotation;
    // (undocumented)
    _applyDeltaShiftToSelectedViewportCameras(renderingEngine: any, viewportsAnnotationsToUpdate: any, delta: any): void;
    // (undocumented)
    _applyDeltaShiftToViewportCamera(renderingEngine: Types_2.IRenderingEngine, annotation: any, delta: any): void;
    // (undocumented)
    _areViewportIdArraysEqual: (viewportIdArrayOne: any, viewportIdArrayTwo: any) => boolean;
    // (undocumented)
    _autoPanViewportIfNecessary(viewportId: string, renderingEngine: Types_2.IRenderingEngine): void;
    // (undocumented)
    cancel: () => void;
    // (undocumented)
    _checkIfViewportsRenderingSameScene: (viewport: any, otherViewport: any) => boolean;
    // (undocumented)
    computeToolCenter: (viewportsInfo: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _filterAnnotationsByUniqueViewportOrientations: (enabledElement: any, annotations: any) => any[];
    // (undocumented)
    filterInteractableAnnotationsForElement: (element: any, annotations: any) => any;
    // (undocumented)
    _filterViewportWithSameOrientation: (enabledElement: any, referenceAnnotation: any, annotations: any) => any;
    // (undocumented)
    _getAnnotations: (enabledElement: Types_2.IEnabledElement) => Annotations;
    // (undocumented)
    _getAnnotationsForViewportsWithDifferentCameras: (enabledElement: any, annotations: any) => any;
    // (undocumented)
    getHandleNearImagePoint(element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    _getReferenceLineColor?: (viewportId: string) => string;
    // (undocumented)
    _getReferenceLineControllable?: (viewportId: string) => boolean;
    // (undocumented)
    _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;
    // (undocumented)
    _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;
    // (undocumented)
    _getRotationHandleNearImagePoint(viewport: any, annotation: any, canvasCoords: any, proximity: any): any;
    // (undocumented)
    _getSlabThicknessHandleNearImagePoint(viewport: any, annotation: any, canvasCoords: any, proximity: any): any;
    // (undocumented)
    _getViewportsInfo: () => Types_2.IViewportId[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: Annotation) => void;
    // (undocumented)
    initializeViewport: ({ renderingEngineId, viewportId, }: Types_2.IViewportId) => {
        normal: Types_2.Point3;
        point: Types_2.Point3;
    };
    // (undocumented)
    _isClockWise(a: any, b: any, c: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: CrosshairsAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    _jump: (enabledElement: any, jumpWorld: any) => boolean;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.MouseMoveEventType, filteredToolAnnotations: Annotations) => boolean;
    // (undocumented)
    onCameraModified: (evt: any) => void;
    // (undocumented)
    _onNewVolume: (e: any) => void;
    // (undocumented)
    onSetToolActive(): void;
    // (undocumented)
    onSetToolDisabled(): void;
    // (undocumented)
    onSetToolEnabled(): void;
    // (undocumented)
    onSetToolPassive(): void;
    // (undocumented)
    _pointNearReferenceLine: (annotation: any, canvasCoords: any, proximity: any, lineViewport: any) => boolean;
    // (undocumented)
    _pointNearTool(element: any, annotation: any, canvasCoords: any, proximity: any): boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    setSlabThickness(viewport: any, slabThickness: any): void;
    // (undocumented)
    _subscribeToViewportNewVolumeSet(viewports: any): void;
    // (undocumented)
    toolCenter: Types_2.Point3;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: Annotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    _unsubscribeToViewportNewVolumeSet(viewportsInfo: any): void;
}

// @public (undocumented)
const CursorNames: string[];

declare namespace cursors {
    export {
        MouseCursor,
        ImageMouseCursor,
        SVGMouseCursor,
        elementCursor,
        registerCursor,
        CursorNames,
        CursorSVG,
        setCursorForElement
    }
}
export { cursors }

// @public (undocumented)
const CursorSVG: {
    Angle: SVGCursorDescriptor;
    ArrowAnnotate: SVGCursorDescriptor;
    Bidirectional: SVGCursorDescriptor;
    CobbAngle: SVGCursorDescriptor;
    CircleROI: SVGCursorDescriptor;
    EllipticalROI: SVGCursorDescriptor;
    FreehandROI: SVGCursorDescriptor;
    FreehandROISculptor: SVGCursorDescriptor;
    Length: SVGCursorDescriptor;
    Probe: SVGCursorDescriptor;
    RectangleROI: SVGCursorDescriptor;
    TextMarker: SVGCursorDescriptor;
    Crosshairs: SVGCursorDescriptor;
    Eraser: SVGCursorDescriptor;
    Magnify: SVGCursorDescriptor;
    Pan: SVGCursorDescriptor;
    Rotate: SVGCursorDescriptor;
    StackScroll: SVGCursorDescriptor;
    WindowLevelRegion: SVGCursorDescriptor;
    WindowLevel: SVGCursorDescriptor;
    Zoom: SVGCursorDescriptor;
    SegmentationFreeHandEraseInside: SVGCursorDescriptor;
    SegmentationFreeHandFillInside: SVGCursorDescriptor;
    SegmentationFreeHandEraseOutside: SVGCursorDescriptor;
    SegmentationFreeHandFillOutside: SVGCursorDescriptor;
    SegmentationRectangleEraseInside: SVGCursorDescriptor;
    RectangleScissor: SVGCursorDescriptor;
    'RectangleScissor.FILL_INSIDE': SVGCursorDescriptor;
    'RectangleScissor.FILL_OUTSIDE': SVGCursorDescriptor;
    'RectangleScissor.ERASE_OUTSIDE': SVGCursorDescriptor;
    'RectangleScissor.ERASE_INSIDE': SVGCursorDescriptor;
    CircleScissor: SVGCursorDescriptor;
    'CircleScissor.FILL_INSIDE': SVGCursorDescriptor;
    'CircleScissor.ERASE_OUTSIDE': SVGCursorDescriptor;
    'CircleScissor.FILL_OUTSIDE': SVGCursorDescriptor;
};

// @public (undocumented)
interface CustomEvent_2<T = any> extends Event {
    readonly detail: T;
    // (undocumented)
    initCustomEvent(
    typeArg: string,
    canBubbleArg: boolean,
    cancelableArg: boolean,
    detailArg: T
    ): void;
}

// @public (undocumented)
function debounce(func: Function, wait?: number, options?: {
    leading?: boolean;
    maxWait?: number;
    trailing?: boolean;
}): Function;

// @public (undocumented)
const _default: {
    filterAnnotationsWithinSlice: typeof filterAnnotationsWithinSlice;
    getWorldWidthAndHeightFromCorners: typeof getWorldWidthAndHeightFromCorners;
    filterAnnotationsForDisplay: typeof filterAnnotationsForDisplay;
    getPointInLineOfSightWithCriteria: typeof getPointInLineOfSightWithCriteria;
};

// @public (undocumented)
const _default_2: {
    interpolateAnnotation: typeof interpolateAnnotation;
};

// @public (undocumented)
function deselectAnnotation(annotationUID?: string): void;

// @public (undocumented)
export function destroy(): void;

// @public (undocumented)
function destroy_2(): void;

// @public (undocumented)
function destroy_3(): void;

// @public (undocumented)
function destroySynchronizer(synchronizerId: string): void;

// @public (undocumented)
function destroyToolGroup(toolGroupId: string): void;

// @public (undocumented)
function disable(element: any): void;

// @public (undocumented)
type DisplayArea = {
    imageArea: [number, number]; // areaX, areaY
    imageCanvasPoint: {
        imagePoint: [number, number]; // imageX, imageY
        canvasPoint: [number, number]; // canvasX, canvasY
    };
    storeAsInitialCamera: boolean;
};

// @public
type DisplayAreaModifiedEvent = CustomEvent_2<DisplayAreaModifiedEventDetail>;

// @public
type DisplayAreaModifiedEventDetail = {
    viewportId: string;
    displayArea: DisplayArea;
    volumeId?: string;
    storeAsInitialCamera?: boolean;
};

// @public (undocumented)
function distanceToPoint(lineStart: Types_2.Point2, lineEnd: Types_2.Point2, point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPoint_2(rect: number[], point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPoint_3(p1: Types_2.Point2, p2: Types_2.Point2): number;

// @public (undocumented)
function distanceToPointSquared(lineStart: Types_2.Point2, lineEnd: Types_2.Point2, point: Types_2.Point2): number;

// @public (undocumented)
export class DragProbeTool extends ProbeTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        newAnnotation?: boolean;
    } | null;
    // (undocumented)
    eventDispatchDetail: {
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    postMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => ProbeAnnotation;
    // (undocumented)
    postTouchStartCallback: (evt: EventTypes_2.InteractionEventType) => ProbeAnnotation;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function draw(element: HTMLDivElement, fn: (svgDrawingElement: any) => any): void;

// @public (undocumented)
function drawArrow(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, arrowUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}): void;

// @public (undocumented)
function drawCircle(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, circleUID: string, center: Types_2.Point2, radius: number, options?: {}, dataId?: string): void;

// @public (undocumented)
function drawEllipse(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, ellipseUID: string, corner1: Types_2.Point2, corner2: Types_2.Point2, options?: {}, dataId?: string): void;

// @public (undocumented)
function drawHandles(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, handleGroupUID: string, handlePoints: Array<Types_2.Point2>, options?: {}): void;

declare namespace drawing {
    export {
        draw,
        drawCircle,
        drawEllipse,
        drawHandles,
        drawLine,
        drawPolyline,
        drawLinkedTextBox,
        drawRect,
        drawTextBox,
        drawArrow
    }
}
export { drawing }

declare namespace drawing_2 {
    export {
        getTextBoxCoordsCanvas
    }
}

// @public (undocumented)
function drawLine(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, lineUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}, dataId?: string): void;

// @public (undocumented)
function drawLinkedTextBox(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, textBoxUID: string, textLines: Array<string>, textBoxPosition: Types_2.Point2, annotationAnchorPoints: Array<Types_2.Point2>, textBox: unknown, options?: {}): SVGRect;

// @public (undocumented)
function drawPolyline(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, polylineUID: string, points: Types_2.Point2[], options: {
    color?: string;
    width?: number;
    lineWidth?: number;
    lineDash?: string;
    connectLastToFirst?: boolean;
}): void;

// @public (undocumented)
function drawRect(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, rectangleUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}, dataId?: string): void;

// @public (undocumented)
function drawTextBox(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, textUID: string, textLines: Array<string>, position: Types_2.Point2, options?: {}): SVGRect;

declare namespace dynamicVolume {
    export {
        getDataInTime,
        generateImageFromTimeData
    }
}

declare namespace elementCursor {
    export {
        initElementCursor,
        resetElementCursor,
        hideElementCursor,
        _setElementCursor as setElementCursor
    }
}

// @public
type ElementDisabledEvent = CustomEvent_2<ElementDisabledEventDetail>;

// @public
type ElementDisabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public
type ElementEnabledEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public
type ElementEnabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

declare namespace ellipse {
    export {
        pointInEllipse,
        getCanvasEllipseCorners
    }
}

// @public (undocumented)
interface EllipticalROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: [Types_2.Point3, Types_2.Point3, Types_2.Point3, Types_2.Point3];
            activeHandleIndex: number | null;
            textBox?: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats?: ROICachedStats;
        initialRotation: number;
    };
}

// @public (undocumented)
export class EllipticalROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => EllipticalROIAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewport: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragDrawCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragHandle: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        movingTextBox?: boolean;
        centerCanvas?: Array<number>;
        canvasWidth?: number;
        canvasHeight?: number;
        originalHandleCanvas?: Array<number>;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getCanvasEllipseCenter(ellipseCanvasPoints: Types_2.Point2[]): Types_2.Point2;
    // (undocumented)
    _getTextLines: (data: any, targetId: string, isPreScaled: boolean, isSuvScaled: boolean) => string[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: EllipticalROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: EllipticalROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _pointInEllipseCanvas(ellipse: any, location: Types_2.Point2): boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: EllipticalROIAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function enable(element: any): void;

declare namespace Enums {
    export {
        MouseBindings,
        KeyboardBindings,
        ToolModes,
        AnnotationStyleStates,
        Events,
        SegmentationRepresentations,
        Swipe
    }
}
export { Enums }

// @public (undocumented)
enum Events {
    // (undocumented)
    ANNOTATION_ADDED = "CORNERSTONE_TOOLS_ANNOTATION_ADDED",
    // (undocumented)
    ANNOTATION_COMPLETED = "CORNERSTONE_TOOLS_ANNOTATION_COMPLETED",
    // (undocumented)
    ANNOTATION_LOCK_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE",
    // (undocumented)
    ANNOTATION_MODIFIED = "CORNERSTONE_TOOLS_ANNOTATION_MODIFIED",
    // (undocumented)
    ANNOTATION_REMOVED = "CORNERSTONE_TOOLS_ANNOTATION_REMOVED",
    // (undocumented)
    ANNOTATION_RENDERED = "CORNERSTONE_TOOLS_ANNOTATION_RENDERED",
    // (undocumented)
    ANNOTATION_SELECTION_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE",
    // (undocumented)
    ANNOTATION_VISIBILITY_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE",
    // (undocumented)
    KEY_DOWN = "CORNERSTONE_TOOLS_KEY_DOWN",
    // (undocumented)
    KEY_UP = "CORNERSTONE_TOOLS_KEY_UP",
    // (undocumented)
    MOUSE_CLICK = "CORNERSTONE_TOOLS_MOUSE_CLICK",
    // (undocumented)
    MOUSE_DOUBLE_CLICK = "CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK",
    // (undocumented)
    MOUSE_DOWN = "CORNERSTONE_TOOLS_MOUSE_DOWN",
    // (undocumented)
    MOUSE_DOWN_ACTIVATE = "CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE",
    // (undocumented)
    MOUSE_DRAG = "CORNERSTONE_TOOLS_MOUSE_DRAG",
    // (undocumented)
    MOUSE_MOVE = "CORNERSTONE_TOOLS_MOUSE_MOVE",
    // (undocumented)
    MOUSE_UP = "CORNERSTONE_TOOLS_MOUSE_UP",
    // (undocumented)
    MOUSE_WHEEL = "CORNERSTONE_TOOLS_MOUSE_WHEEL",
    // (undocumented)
    SEGMENTATION_DATA_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED",
    // (undocumented)
    SEGMENTATION_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED",
    // (undocumented)
    SEGMENTATION_REMOVED = "CORNERSTONE_TOOLS_SEGMENTATION_REMOVED",
    // (undocumented)
    SEGMENTATION_RENDERED = "CORNERSTONE_TOOLS_SEGMENTATION_RENDERED",
    // (undocumented)
    SEGMENTATION_REPRESENTATION_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED",
    // (undocumented)
    SEGMENTATION_REPRESENTATION_REMOVED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED",
    // (undocumented)
    TOUCH_DRAG = "CORNERSTONE_TOOLS_TOUCH_DRAG",
    // (undocumented)
    TOUCH_END = "CORNERSTONE_TOOLS_TOUCH_END",
    // (undocumented)
    TOUCH_PRESS = "CORNERSTONE_TOOLS_TOUCH_PRESS",
    // (undocumented)
    TOUCH_START = "CORNERSTONE_TOOLS_TOUCH_START",
    // (undocumented)
    TOUCH_START_ACTIVATE = "CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE",
    // (undocumented)
    TOUCH_SWIPE = "CORNERSTONE_TOOLS_SWIPE",
    // (undocumented)
    TOUCH_TAP = "CORNERSTONE_TOOLS_TAP"
}

// @public (undocumented)
enum Events_2 {
    // (undocumented)
    CLIP_STARTED = "CORNERSTONE_CINE_TOOL_STARTED",
    // (undocumented)
    CLIP_STOPPED = "CORNERSTONE_CINE_TOOL_STOPPED"
}

declare namespace EventTypes {
    export {
        CameraModifiedEventDetail,
        CameraModifiedEvent,
        VoiModifiedEvent,
        VoiModifiedEventDetail,
        DisplayAreaModifiedEvent,
        DisplayAreaModifiedEventDetail,
        ElementDisabledEvent,
        ElementDisabledEventDetail,
        ElementEnabledEvent,
        ElementEnabledEventDetail,
        ImageRenderedEventDetail,
        ImageRenderedEvent,
        ImageVolumeModifiedEvent,
        ImageVolumeModifiedEventDetail,
        ImageLoadedEvent,
        ImageLoadedEventDetail,
        ImageLoadedFailedEventDetail,
        ImageLoadedFailedEvent,
        VolumeLoadedEvent,
        VolumeLoadedEventDetail,
        VolumeLoadedFailedEvent,
        VolumeLoadedFailedEventDetail,
        ImageCacheImageAddedEvent,
        ImageCacheImageAddedEventDetail,
        ImageCacheImageRemovedEvent,
        ImageCacheImageRemovedEventDetail,
        VolumeCacheVolumeAddedEvent,
        VolumeCacheVolumeAddedEventDetail,
        VolumeCacheVolumeRemovedEvent,
        VolumeCacheVolumeRemovedEventDetail,
        StackNewImageEvent,
        StackNewImageEventDetail,
        PreStackNewImageEvent,
        PreStackNewImageEventDetail,
        ImageSpacingCalibratedEvent,
        ImageSpacingCalibratedEventDetail,
        ImageLoadProgressEvent,
        ImageLoadProgressEventDetail,
        VolumeNewImageEvent,
        VolumeNewImageEventDetail,
        StackViewportNewStackEvent,
        StackViewportNewStackEventDetail,
        StackViewportScrollEvent,
        StackViewportScrollEventDetail
    }
}

declare namespace EventTypes_2 {
    export {
        InteractionStartType,
        InteractionEndType,
        InteractionEventType,
        NormalizedInteractionEventDetail,
        NormalizedMouseEventType,
        NormalizedTouchEventType,
        AnnotationAddedEventDetail,
        AnnotationAddedEventType,
        AnnotationCompletedEventDetail,
        AnnotationCompletedEventType,
        AnnotationModifiedEventDetail,
        AnnotationModifiedEventType,
        AnnotationRemovedEventDetail,
        AnnotationRemovedEventType,
        AnnotationSelectionChangeEventDetail,
        AnnotationSelectionChangeEventType,
        AnnotationRenderedEventDetail,
        AnnotationRenderedEventType,
        AnnotationLockChangeEventDetail,
        AnnotationVisibilityChangeEventDetail,
        AnnotationLockChangeEventType,
        AnnotationVisibilityChangeEventType,
        SegmentationDataModifiedEventType,
        SegmentationRepresentationModifiedEventDetail,
        SegmentationRepresentationModifiedEventType,
        SegmentationRepresentationRemovedEventDetail,
        SegmentationRepresentationRemovedEventType,
        SegmentationRemovedEventType,
        SegmentationRemovedEventDetail,
        SegmentationDataModifiedEventDetail,
        SegmentationRenderedEventType,
        SegmentationRenderedEventDetail,
        SegmentationModifiedEventType,
        SegmentationModifiedEventDetail,
        KeyDownEventDetail,
        KeyDownEventType,
        KeyUpEventDetail,
        KeyUpEventType,
        MouseDownEventDetail,
        TouchStartEventDetail,
        MouseDownEventType,
        TouchStartEventType,
        MouseDownActivateEventDetail,
        TouchStartActivateEventDetail,
        MouseDownActivateEventType,
        TouchStartActivateEventType,
        MouseDragEventDetail,
        TouchDragEventDetail,
        MouseDragEventType,
        TouchDragEventType,
        MouseUpEventDetail,
        TouchEndEventDetail,
        MouseUpEventType,
        TouchEndEventType,
        MouseClickEventDetail,
        MouseClickEventType,
        TouchTapEventDetail,
        TouchTapEventType,
        TouchSwipeEventDetail,
        TouchSwipeEventType,
        TouchPressEventDetail,
        TouchPressEventType,
        MouseMoveEventDetail,
        MouseMoveEventType,
        MouseDoubleClickEventDetail,
        MouseDoubleClickEventType,
        MouseWheelEventDetail,
        MouseWheelEventType,
        VolumeScrollOutOfBoundsEventDetail,
        VolumeScrollOutOfBoundsEventType
    }
}

// @public (undocumented)
function extend2DBoundingBoxInViewAxis(boundsIJK: [Types_2.Point2, Types_2.Point2, Types_2.Point2], numSlicesToProject: number): [Types_2.Point2, Types_2.Point2, Types_2.Point2];

// @public (undocumented)
function filterAnnotationsForDisplay(viewport: Types_2.IViewport, annotations: Annotations): Annotations;

// @public (undocumented)
function filterAnnotationsWithinSlice(annotations: Annotations, camera: Types_2.ICamera, spacingInNormalDirection: number): Annotations;

// @public (undocumented)
function filterViewportsWithFrameOfReferenceUID(viewports: Array<Types_2.IStackViewport | Types_2.IVolumeViewport>, FrameOfReferenceUID: string): Array<Types_2.IStackViewport | Types_2.IVolumeViewport>;

// @public (undocumented)
function filterViewportsWithParallelNormals(viewports: any, camera: any, EPS?: number): any;

// @public (undocumented)
function filterViewportsWithToolEnabled(viewports: Array<Types_2.IStackViewport | Types_2.IVolumeViewport>, toolName: string): Array<Types_2.IStackViewport | Types_2.IVolumeViewport>;

// @public (undocumented)
function findClosestPoint(sourcePoints: Array<Types_2.Point2>, targetPoint: Types_2.Point2): Types_2.Point2;

// @public
type FlipDirection = {
    flipHorizontal?: boolean;
    flipVertical?: boolean;
};

// @public (undocumented)
function floodFill(getter: FloodFillGetter, seed: Types_2.Point2 | Types_2.Point3, options?: FloodFillOptions): FloodFillResult;

// @public (undocumented)
type FloodFillGetter = FloodFillGetter2D | FloodFillGetter3D;

// @public (undocumented)
type FloodFillOptions = {
    onFlood?: (x: any, y: any) => void;
    onBoundary?: (x: any, y: any) => void;
    equals?: (a: any, b: any) => boolean;
    diagonals?: boolean;
};

// @public (undocumented)
type FloodFillResult = {
    flooded: Types_2.Point2[] | Types_2.Point3[];
    boundaries: Types_2.Point2[] | Types_2.Point3[];
};

// @public (undocumented)
class FrameOfReferenceSpecificAnnotationManager implements IAnnotationManager {
    constructor(uid?: string);
    // (undocumented)
    addAnnotation: (annotation: Annotation, groupKey?: string) => void;
    // (undocumented)
    getAnnotation: (annotationUID: string) => Annotation | undefined;
    // (undocumented)
    getAnnotations: (groupKey: string, toolName?: string) => GroupSpecificAnnotations | Annotations;
    // (undocumented)
    getFramesOfReference: () => Array<string>;
    // (undocumented)
    getGroupKey: (annotationGroupSelector: AnnotationGroupSelector) => string;
    // (undocumented)
    getNumberOfAllAnnotations: () => number;
    // (undocumented)
    getNumberOfAnnotations: (groupKey: string, toolName?: string) => number;
    // (undocumented)
    _imageVolumeModifiedHandler: (evt: Types_2.EventTypes.ImageVolumeModifiedEvent) => void;
    // (undocumented)
    removeAllAnnotations: () => void;
    // (undocumented)
    removeAnnotation: (annotationUID: string) => void;
    // (undocumented)
    removeAnnotations: (groupKey: string, toolName?: string) => void;
    // (undocumented)
    restoreAnnotations: (state: AnnotationState | GroupSpecificAnnotations | Annotations, groupKey?: string, toolName?: string) => void;
    // (undocumented)
    saveAnnotations: (groupKey?: string, toolName?: string) => AnnotationState | GroupSpecificAnnotations | Annotations;
    // (undocumented)
    readonly uid: string;
}

// @public (undocumented)
function generateImageFromTimeData(dynamicVolume: Types_2.IDynamicImageVolume, operation: string, frameNumbers?: number[]): Float32Array;

// @public (undocumented)
function getActiveSegmentationRepresentation(toolGroupId: string): ToolGroupSpecificRepresentation;

// @public (undocumented)
function getActiveSegmentIndex(segmentationId: string): number | undefined;

// @public (undocumented)
function getAllSynchronizers(): Array<Synchronizer>;

// @public (undocumented)
function getAllToolGroups(): Array<IToolGroup>;

// @public (undocumented)
function getAnnotation(annotationUID: string): Annotation;

// @public (undocumented)
function getAnnotationManager(): FrameOfReferenceSpecificAnnotationManager;

// @public (undocumented)
function getAnnotationNearPoint(element: HTMLDivElement, canvasPoint: Types_2.Point2, proximity?: number): Annotation | null;

// @public (undocumented)
function getAnnotationNearPointOnEnabledElement(enabledElement: Types_2.IEnabledElement, point: Types_2.Point2, proximity: number): Annotation | null;

// @public (undocumented)
function getAnnotations(toolName: string, annotationGroupSelector: AnnotationGroupSelector): Annotations;

// @public (undocumented)
function getAnnotationsLocked(): Array<Annotation>;

// @public (undocumented)
function getAnnotationsLockedCount(): number;

// @public (undocumented)
function getAnnotationsSelected(): Array<string>;

// @public (undocumented)
function getAnnotationsSelectedByToolName(toolName: string): Array<string>;

// @public (undocumented)
function getAnnotationsSelectedCount(): number;

// @public (undocumented)
function getBoundingBoxAroundShape(points: Types_2.Point3[], dimensions?: Types_2.Point3): [Types_2.Point2, Types_2.Point2, Types_2.Point2];

// @public (undocumented)
function getBoundsIJKFromRectangleAnnotations(annotations: any, referenceVolume: any, options?: Options): any;

// @public (undocumented)
function getBrushSizeForToolGroup(toolGroupId: string): void;

// @public (undocumented)
function getBrushThresholdForToolGroup(toolGroupId: string): any;

// @public (undocumented)
function getCanvasEllipseCorners(ellipseCanvasPoints: canvasCoordinates): Array<Types_2.Point2>;

// @public (undocumented)
function getClosestIntersectionWithPolyline(points: Types_2.Point2[], p1: Types_2.Point2, q1: Types_2.Point2, closed?: boolean): {
    segment: Types_2.Point2;
    distance: number;
} | undefined;

// @public (undocumented)
function getColorForSegmentIndex(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number): Color;

// @public (undocumented)
function getColorLUT(index: number): ColorLUT | undefined;

// @public (undocumented)
function getConfiguration(): {
    maxImagesToPrefetch: number;
    preserveExistingPool: boolean;
};

// @public (undocumented)
function getDataInTime(dynamicVolume: Types_2.IDynamicImageVolume, options: {
    frameNumbers?: any;
    maskVolumeId?: any;
    imageCoordinate?: any;
}): number[] | number[][];

// @public (undocumented)
function getDefaultRepresentationConfig(segmentation: Segmentation): LabelmapConfig;

// @public (undocumented)
function getDefaultSegmentationStateManager(): SegmentationStateManager;

// @public (undocumented)
function getDeltaDistance(currentPoints: IPoints[], lastPoints: IPoints[]): IDistance;

// @public (undocumented)
function getDeltaDistanceBetweenIPoints(currentPoints: IPoints[], lastPoints: IPoints[]): IDistance;

// @public (undocumented)
function getDeltaPoints(currentPoints: IPoints[], lastPoints: IPoints[]): IPoints;

// @public (undocumented)
function getDeltaRotation(currentPoints: ITouchPoints[], lastPoints: ITouchPoints[]): void;

// @public (undocumented)
function getFirstIntersectionWithPolyline(points: Types_2.Point2[], p1: Types_2.Point2, q1: Types_2.Point2, closed?: boolean): Types_2.Point2 | undefined;

// @public (undocumented)
function getFont(styleSpecifier: StyleSpecifier, state?: AnnotationStyleStates, mode?: ToolModes): string;

// @public (undocumented)
function getGlobalConfig(): SegmentationRepresentationConfig;

// @public (undocumented)
function getGlobalConfig_2(): SegmentationRepresentationConfig;

// @public (undocumented)
function getGlobalRepresentationConfig(representationType: SegmentationRepresentations): RepresentationConfig['LABELMAP'];

// @public (undocumented)
function getLockedSegments(segmentationId: string): number[] | [];

// @public (undocumented)
function getMeanPoints(points: IPoints[]): IPoints;

// @public (undocumented)
function getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints;

// @public (undocumented)
function getNumberOfAnnotations(toolName: string, annotationGroupSelector: AnnotationGroupSelector): number;

// @public (undocumented)
function getOrientationStringLPS(vector: Types_2.Point3): string;

// @public (undocumented)
function getPointInLineOfSightWithCriteria(viewport: Types_2.IVolumeViewport, worldPos: Types_2.Point3, targetVolumeId: string, criteriaFunction: (intensity: number, point: Types_2.Point3) => Types_2.Point3, stepSize?: number): Types_2.Point3;

// @public (undocumented)
function getSegmentation(segmentationId: string): Segmentation | undefined;

// @public (undocumented)
function getSegmentationRepresentationByUID(toolGroupId: string, segmentationRepresentationUID: string): ToolGroupSpecificRepresentation | undefined;

// @public (undocumented)
function getSegmentationRepresentations(toolGroupId: string): ToolGroupSpecificRepresentations | [];

// @public (undocumented)
function getSegmentationRepresentationSpecificConfig(toolGroupId: string, segmentationRepresentationUID: string): RepresentationConfig;

// @public (undocumented)
function getSegmentationRepresentationSpecificConfig_2(toolGroupId: string, segmentationRepresentationUID: string): RepresentationConfig;

// @public (undocumented)
function getSegmentations(): Segmentation[] | [];

// @public (undocumented)
function getSegmentationVisibility(toolGroupId: string, segmentationRepresentationUID: string): boolean | undefined;

// @public (undocumented)
function getSegmentSpecificConfig(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number): RepresentationConfig;

// @public (undocumented)
function getSegmentSpecificRepresentationConfig(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number): RepresentationConfig;

// @public (undocumented)
function getState(annotation?: Annotation): AnnotationStyleStates;

// @public (undocumented)
const getSubPixelSpacingAndXYDirections: (viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, subPixelResolution: number) => {
    spacing: Types_2.Point2;
    xDir: Types_2.Point3;
    yDir: Types_2.Point3;
};

// @public (undocumented)
function getSynchronizer(synchronizerId: string): Synchronizer | void;

// @public (undocumented)
function getSynchronizersForViewport(viewportId: string, renderingEngineId: string): Array<Synchronizer>;

// @public (undocumented)
function getTextBoxCoordsCanvas(annotationCanvasPoints: Array<Types_2.Point2>): Types_2.Point2;

// @public (undocumented)
function getToolGroup(toolGroupId: string): IToolGroup | undefined;

// @public (undocumented)
function getToolGroupForViewport(viewportId: string, renderingEngineId: string): IToolGroup | undefined;

// @public (undocumented)
function getToolGroupIdsWithSegmentation(segmentationId: string): string[];

// @public (undocumented)
function getToolGroupSpecificConfig(toolGroupId: string): SegmentationRepresentationConfig;

// @public (undocumented)
function getToolGroupSpecificConfig_2(toolGroupId: string): SegmentationRepresentationConfig;

// @public (undocumented)
function getToolGroupsWithToolName(toolName: string): IToolGroup[] | [];

// @public (undocumented)
function getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined;

// @public (undocumented)
function getViewportIdsWithToolToRender(element: HTMLDivElement, toolName: string, requireParallelNormals?: boolean): string[];

// @public (undocumented)
function getWorldWidthAndHeightFromCorners(viewPlaneNormal: Types_2.Point3, viewUp: Types_2.Point3, topLeftWorld: Types_2.Point3, bottomRightWorld: Types_2.Point3): {
    worldWidth: number;
    worldHeight: number;
};

// @public (undocumented)
type GroupSpecificAnnotations = {
    [toolName: string]: Annotations;
};

// @public (undocumented)
function hideElementCursor(element: HTMLDivElement): void;

// @public (undocumented)
interface IAnnotationManager {
    // (undocumented)
    addAnnotation: (annotation: Annotation, groupKey: string) => void;
    // (undocumented)
    getAnnotation: (annotationUID: string) => Annotation;
    // (undocumented)
    getAnnotations: (groupKey: string, toolName?: string) => GroupSpecificAnnotations | Annotations;
    // (undocumented)
    getGroupKey: (annotationGroupSelector: AnnotationGroupSelector) => string;
    // (undocumented)
    getNumberOfAllAnnotations: () => number;
    // (undocumented)
    getNumberOfAnnotations: (groupKey: string, toolName?: string) => number;
    // (undocumented)
    removeAllAnnotations: () => void;
    // (undocumented)
    removeAnnotation: (annotationUID: string) => void;
    // (undocumented)
    removeAnnotations: (groupKey: string) => void;
}

// @public (undocumented)
interface ICache {
    getCacheSize: () => number;
    getImageLoadObject: (imageId: string) => IImageLoadObject | void;
    getMaxCacheSize: () => number;
    getVolumeLoadObject: (volumeId: string) => IVolumeLoadObject | void;
    purgeCache: () => void;
    putImageLoadObject: (
    imageId: string,
    imageLoadObject: IImageLoadObject
    ) => Promise<any>;
    putVolumeLoadObject: (
    volumeId: string,
    volumeLoadObject: IVolumeLoadObject
    ) => Promise<any>;
    setMaxCacheSize: (maxCacheSize: number) => void;
}

// @public (undocumented)
interface ICachedGeometry {
    // (undocumented)
    geometry?: IGeometry;
    // (undocumented)
    geometryId: string;
    // (undocumented)
    geometryLoadObject: IGeometryLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedImage {
    // (undocumented)
    image?: IImage;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageLoadObject: IImageLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedVolume {
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
    // (undocumented)
    volume?: IImageVolume;
    // (undocumented)
    volumeId: string;
    // (undocumented)
    volumeLoadObject: IVolumeLoadObject;
}

// @public
interface ICamera {
    clippingRange?: Point2;
    flipHorizontal?: boolean;
    flipVertical?: boolean;
    focalPoint?: Point3;
    parallelProjection?: boolean;
    parallelScale?: number;
    position?: Point3;
    scale?: number;
    viewAngle?: number;
    viewPlaneNormal?: Point3;
    viewUp?: Point3;
}

// @public (undocumented)
interface IContour {
    // (undocumented)
    color: any;
    // (undocumented)
    getColor(): Point3;
    // (undocumented)
    getFlatPointsArray(): number[];
    getPoints(): Point3[];
    // (undocumented)
    _getSizeInBytes(): number;
    // (undocumented)
    getType(): ContourType;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    points: Point3[];
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public
interface IContourSet {
    // (undocumented)
    contours: IContour[];
    // (undocumented)
    _createEachContour(data: ContourData[]): void;
    // (undocumented)
    readonly frameOfReferenceUID: string;
    // (undocumented)
    getCentroid(): Point3;
    // (undocumented)
    getColor(): any;
    getContours(): IContour[];
    getFlatPointsArray(): Point3[];
    getNumberOfContours(): number;
    getNumberOfPointsArray(): number[];
    getNumberOfPointsInAContour(contourIndex: number): number;
    getPointsInContour(contourIndex: number): Point3[];
    // (undocumented)
    getSegmentIndex(): number;
    // (undocumented)
    getSizeInBytes(): number;
    getTotalNumberOfPoints(): number;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public (undocumented)
type IDistance = {
    page: number;
    client: number;
    canvas: number;
    world: number;
};

// @public
interface IDynamicImageVolume extends IImageVolume {
    getScalarDataArrays(): VolumeScalarData[];
    get numTimePoints(): number;
    get timePointIndex(): number;
    set timePointIndex(newTimePointIndex: number);
}

// @public
interface IEnabledElement {
    FrameOfReferenceUID: string;
    renderingEngine: IRenderingEngine;
    renderingEngineId: string;
    viewport: IStackViewport | IVolumeViewport;
    viewportId: string;
}

// @public (undocumented)
interface IGeometry {
    // (undocumented)
    data: IContourSet;
    // (undocumented)
    id: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    type: GeometryType;
}

// @public (undocumented)
interface IGeometryLoadObject {
    cancelFn?: () => void;
    decache?: () => void;
    promise: Promise<IGeometry>;
}

// @public
interface IImage {
    cachedLut?: {
        windowWidth?: number | number[];
        windowCenter?: number | number[];
        invert?: boolean;
        lutArray?: Uint8ClampedArray;
        modalityLUT?: unknown;
        voiLUT?: CPUFallbackLUT;
    };
    color: boolean;
    colormap?: CPUFallbackColormap;
    columnPixelSpacing: number;
    columns: number;
    // (undocumented)
    getCanvas: () => HTMLCanvasElement;
    getPixelData: () => PixelDataTypedArray;
    height: number;
    imageId: string;
    intercept: number;
    invert: boolean;
    isPreScaled?: boolean;
    // (undocumented)
    maxPixelValue: number;
    minPixelValue: number;
    modalityLUT?: CPUFallbackLUT;
    numComps: number;
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    render?: (
    enabledElement: CPUFallbackEnabledElement,
    invalidated: boolean
    ) => unknown;
    rgba: boolean;
    rowPixelSpacing: number;
    rows: number;
    scaling?: {
        PET?: {
            // @TODO: Do these values exist?
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            // accessed in ProbeTool
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sharedCacheKey?: string;
    sizeInBytes: number;
    sliceThickness?: number;
    slope: number;
    stats?: {
        lastStoredPixelDataToCanvasImageDataTime?: number;
        lastGetPixelDataTime?: number;
        lastPutImageDataTime?: number;
        lastLutGenerateTime?: number;
        lastRenderedViewport?: unknown;
        lastRenderTime?: number;
    };
    voiLUT?: CPUFallbackLUT;
    voiLUTFunction: string;
    width: number;
    windowCenter: number[] | number;
    windowWidth: number[] | number;
}

// @public
interface IImageData {
    dimensions: Point3;
    direction: Mat3;
    hasPixelSpacing?: boolean;
    imageData: vtkImageData;
    metadata: { Modality: string };
    origin: Point3;
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    scalarData: Float32Array | Uint16Array | Uint8Array | Int16Array;
    scaling?: Scaling;
    spacing: Point3;
}

// @public
interface IImageLoadObject {
    cancelFn?: () => void;
    decache?: () => void;
    promise: Promise<IImage>;
}

// @public
interface IImageVolume {
    // (undocumented)
    cancelLoading?: () => void;
    convertToCornerstoneImage?: (
    imageId: string,
    imageIdIndex: number
    ) => IImageLoadObject;
    destroy(): void;
    dimensions: Point3;
    direction: Mat3;
    getImageIdIndex(imageId: string): number;
    getImageURIIndex(imageURI: string): number;
    getScalarData(): VolumeScalarData;
    hasPixelSpacing: boolean;
    imageData?: vtkImageData;
    imageIds: Array<string>;
    isDynamicVolume(): boolean;
    isPrescaled: boolean;
    loadStatus?: Record<string, any>;
    metadata: Metadata;
    numVoxels: number;
    origin: Point3;
    referencedVolumeId?: string;
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    sizeInBytes?: number;
    spacing: Point3;
    readonly volumeId: string;
    vtkOpenGLTexture: any;
}

// @public
type ImageCacheImageAddedEvent =
CustomEvent_2<ImageCacheImageAddedEventDetail>;

// @public
type ImageCacheImageAddedEventDetail = {
    image: ICachedImage;
};

// @public
type ImageCacheImageRemovedEvent =
CustomEvent_2<ImageCacheImageRemovedEventDetail>;

// @public
type ImageCacheImageRemovedEventDetail = {
    imageId: string;
};

// @public
type ImageLoadedEvent = CustomEvent_2<ImageLoadedEventDetail>;

// @public
type ImageLoadedEventDetail = {
    image: IImage;
};

// @public
type ImageLoadedFailedEvent = CustomEvent_2<ImageLoadedFailedEventDetail>;

// @public
type ImageLoadedFailedEventDetail = {
    imageId: string;
    error: unknown;
};

// @public
type ImageLoaderFn = (
imageId: string,
options?: Record<string, any>
) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public
type ImageLoadProgressEvent = CustomEvent_2<ImageLoadProgressEventDetail>;

// @public
type ImageLoadProgressEventDetail = {
    url: string;
    imageId: string;
    loaded: number;
    total: number;
    percent: number;
};

// @public (undocumented)
class ImageMouseCursor extends MouseCursor {
    constructor(url: string, x?: number, y?: number, name?: string | undefined, fallback?: MouseCursor | undefined);
    // (undocumented)
    getStyleProperty(): string;
    // (undocumented)
    static getUniqueInstanceName(prefix: string): string;
}

// @public (undocumented)
interface ImagePixelModule {
    // (undocumented)
    bitsAllocated: number;
    // (undocumented)
    bitsStored: number;
    // (undocumented)
    highBit: number;
    // (undocumented)
    modality: string;
    // (undocumented)
    photometricInterpretation: string;
    // (undocumented)
    pixelRepresentation: string;
    // (undocumented)
    samplesPerPixel: number;
    // (undocumented)
    voiLUTFunction: VOILUTFunctionType;
    // (undocumented)
    windowCenter: number | number[];
    // (undocumented)
    windowWidth: number | number[];
}

// @public (undocumented)
interface ImagePlaneModule {
    // (undocumented)
    columnCosines?: Point3;
    // (undocumented)
    columnPixelSpacing?: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    frameOfReferenceUID: string;
    // (undocumented)
    imageOrientationPatient?: Float32Array;
    // (undocumented)
    imagePositionPatient?: Point3;
    // (undocumented)
    pixelSpacing?: Point2;
    // (undocumented)
    rowCosines?: Point3;
    // (undocumented)
    rowPixelSpacing?: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    sliceLocation?: number;
    // (undocumented)
    sliceThickness?: number;
}

// @public
type ImageRenderedEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public
type ImageRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    suppressEvents?: boolean;
};

// @public (undocumented)
type ImageSliceData = {
    numberOfSlices: number;
    imageIndex: number;
};

// @public
type ImageSpacingCalibratedEvent =
CustomEvent_2<ImageSpacingCalibratedEventDetail>;

// @public
type ImageSpacingCalibratedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    imageId: string;
    rowScale: number;
    columnScale: number;
    imageData: vtkImageData;
    worldToIndex: mat4;
};

// @public
type ImageVolumeModifiedEvent = CustomEvent_2<ImageVolumeModifiedEventDetail>;

// @public
type ImageVolumeModifiedEventDetail = {
    imageVolume: IImageVolume;
    FrameOfReferenceUID: string;
};

// @public (undocumented)
export function init(defaultConfiguration?: {}): void;

// @public (undocumented)
function initElementCursor(element: HTMLDivElement, cursor: MouseCursor | null): void;

// @public (undocumented)
type InteractionEndType = Types_2.CustomEventType<InteractionEndEventDetail>;

// @public (undocumented)
type InteractionEventType = Types_2.CustomEventType<InteractionEventDetail>;

// @public (undocumented)
type InteractionStartType = Types_2.CustomEventType<InteractionStartEventDetail>;

// @public (undocumented)
type InteractionTypes = 'Mouse' | 'Touch';

// @public (undocumented)
function interpolateAnnotation(enabledElement: Types_2.IEnabledElement, annotation: PlanarFreehandROIAnnotation, knotsRatioPercentage: number): boolean;

// @public (undocumented)
function intersectLine(line1Start: Types_2.Point2, line1End: Types_2.Point2, line2Start: Types_2.Point2, line2End: Types_2.Point2): number[];

// @public (undocumented)
function invertOrientationStringLPS(orientationString: string): string;

// @public (undocumented)
type IPoints = {
    page: Types_2.Point2;
    client: Types_2.Point2;
    canvas: Types_2.Point2;
    world: Types_2.Point3;
};

// @public
interface IRegisterImageLoader {
    // (undocumented)
    registerImageLoader: (scheme: string, imageLoader: ImageLoaderFn) => void;
}

// @public (undocumented)
interface IRenderingEngine {
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(
    canvas: HTMLCanvasElement,
    backgroundColor: [number, number, number]
    ): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getViewport(id: string): IStackViewport | IVolumeViewport;
    // (undocumented)
    getViewports(): Array<IStackViewport | IVolumeViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference(FrameOfReferenceUID: string): void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, resetPan?: boolean, resetZoom?: boolean): void;
    // (undocumented)
    setViewports(viewports: Array<PublicViewportInput>): void;
}

// @public (undocumented)
function isAnnotationLocked(annotation: Annotation): boolean;

// @public (undocumented)
function isAnnotationSelected(annotationUID: string): boolean;

// @public (undocumented)
function isAnnotationVisible(annotationUID: string): boolean | undefined;

// @public (undocumented)
function isObject(value: any): boolean;

// @public (undocumented)
function isSegmentIndexLocked(segmentationId: string, segmentIndex: number): boolean;

// @public
interface IStackViewport extends IViewport {
    calibrateSpacing(imageId: string): void;
    canvasToWorld: (canvasPos: Point2) => Point3;
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
    };
    getCamera(): ICamera;
    getCornerstoneImage: () => IImage;
    getCurrentImageId: () => string;
    getCurrentImageIdIndex: () => number;
    getFrameOfReferenceUID: () => string;
    getImageData(): IImageData | CPUIImageData;
    getImageIds: () => string[];
    getProperties: () => StackViewportProperties;
    getRenderer(): any;
    hasImageId: (imageId: string) => boolean;
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    modality: string;
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    resetProperties(): void;
    resize: () => void;
    scaling: Scaling;
    setCamera(cameraInterface: ICamera): void;
    setColormap(colormap: CPUFallbackColormapData | ColormapRegistration): void;
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    setProperties(
        { voiRange, invert, interpolationType, rotation }: StackViewportProperties,
    suppressEvents?: boolean
    ): void;
    setStack(
    imageIds: Array<string>,
    currentImageIdIndex?: number
    ): Promise<string>;
    unsetColormap(): void;
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public
interface IStreamingImageVolume extends ImageVolume {
    clearLoadCallbacks(): void;
    convertToCornerstoneImage(imageId: string, imageIdIndex: number): any;
    decache(completelyRemove: boolean): void;
}

// @public (undocumented)
interface IStreamingVolumeProperties {
    imageIds: Array<string>;

    loadStatus: {
        loaded: boolean;
        loading: boolean;
        cancelled: boolean;
        cachedFrames: Array<boolean>;
        callbacks: Array<() => void>;
    };
}

// @public (undocumented)
function isValidRepresentationConfig(representationType: string, config: RepresentationConfig): boolean;

// @public (undocumented)
function isViewportPreScaled(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, targetId: string): boolean;

// @public (undocumented)
interface ISynchronizerEventHandler {
    // (undocumented)
    (synchronizer: Synchronizer, sourceViewport: Types_2.IViewportId, targetViewport: Types_2.IViewportId, sourceEvent: any): void;
}

// @public (undocumented)
type IToolBinding = {
    mouseButton?: ToolBindingMouseType;
    modifierKey?: ToolBindingKeyboardType;
    numTouchPoints?: number;
};

// @public (undocumented)
type IToolClassReference = new <T extends BaseTool>(config: any) => T;

// @public (undocumented)
interface IToolGroup {
    // (undocumented)
    addTool: {
        (toolName: string, toolConfiguration?: any): void;
    };
    // (undocumented)
    addToolInstance: {
        (ttoolName: string, parentClassName: string, configuration?: any): void;
    };
    // (undocumented)
    addViewport: {
        (viewportId: string, renderingEngineId?: string): void;
    };
    // (undocumented)
    getActivePrimaryMouseButtonTool: {
        (): undefined | string;
    };
    // (undocumented)
    getToolConfiguration: {
        (toolName: string, configurationPath: string): any;
    };
    // (undocumented)
    getToolInstance: {
        (toolName: string): any;
    };
    // (undocumented)
    getToolOptions: {
        (toolName: string): ToolOptionsType;
    };
    // (undocumented)
    getViewportIds: () => string[];
    // (undocumented)
    getViewportsInfo: () => Array<Types_2.IViewportId>;
    // (undocumented)
    id: string;
    // (undocumented)
    removeViewports: {
        (renderingEngineId: string, viewportId?: string): void;
    };
    // (undocumented)
    setToolActive: {
        (toolName: string, toolBindingsOption?: SetToolBindingsType): void;
    };
    // (undocumented)
    setToolConfiguration: {
        (toolName: string, configuration: Record<any, any>, overwrite?: boolean): void;
    };
    // (undocumented)
    setToolDisabled: {
        (toolName: string): void;
    };
    // (undocumented)
    setToolEnabled: {
        (toolName: string): void;
    };
    // (undocumented)
    setToolPassive: {
        (toolName: string): void;
    };
    // (undocumented)
    setViewportsCursorByToolName: {
        (toolName: string, strategyName?: string): void;
    };
    // (undocumented)
    _toolInstances: Record<string, any>;
    // (undocumented)
    toolOptions: Record<string, any>;
    // (undocumented)
    viewportsInfo: Array<Types_2.IViewportId>;
}

// @public (undocumented)
type ITouchPoints = IPoints & {
    touch: {
        identifier: string;
        radiusX: number;
        radiusY: number;
        force: number;
        rotationAngle: number;
    };
};

// @public
interface IViewport {
    _actors: Map<string, any>;
    addActor(actorEntry: ActorEntry): void;
    addActors(actors: Array<ActorEntry>): void;
    canvas: HTMLCanvasElement;
    canvasToWorld: (canvasPos: Point2) => Point3;
    customRenderViewportToCanvas: () => unknown;
    defaultOptions: any;
    element: HTMLDivElement;
    getActor(actorUID: string): ActorEntry;
    getActorByIndex(index: number): ActorEntry;
    getActors(): Array<ActorEntry>;
    getActorUIDByIndex(index: number): string;
    getCamera(): ICamera;
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    getDefaultActor(): ActorEntry;
    getDisplayArea(): DisplayArea | undefined;
    getFrameOfReferenceUID: () => string;
    getPan(): Point2;
    getRenderer(): void;
    getRenderingEngine(): any;
    getRotation: () => number;
    getZoom(): number;
    id: string;
    isDisabled: boolean;
    options: ViewportInputOptions;
    removeActors(actorUIDs: Array<string>): void;
    removeAllActors(): void;
    render(): void;
    renderingEngineId: string;
    reset(immediate: boolean): void;
    setActors(actors: Array<ActorEntry>): void;
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    setDisplayArea(
    displayArea: DisplayArea,
    callResetCamera?: boolean,
    suppressEvents?: boolean
    );
    setOptions(options: ViewportInputOptions, immediate: boolean): void;
    setPan(pan: Point2, storeAsInitialCamera?: boolean);
    setZoom(zoom: number, storeAsInitialCamera?: boolean);
    sHeight: number;
    suppressEvents: boolean;
    sWidth: number;
    sx: number;
    sy: number;
    type: ViewportType;
    // (undocumented)
    updateRenderingPipeline: () => void;
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public
interface IViewportId {
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public
interface IVolume {
    dimensions: Point3;
    direction: Mat3;
    imageData?: vtkImageData;
    metadata: Metadata;
    origin: Point3;
    referencedVolumeId?: string;
    scalarData: VolumeScalarData | Array<VolumeScalarData>;
    scaling?: {
        PET?: {
            // @TODO: Do these values exist?
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            // accessed in ProbeTool
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    sizeInBytes?: number;
    spacing: Point3;
    volumeId: string;
}

// @public
interface IVolumeInput {
    // (undocumented)
    actorUID?: string;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    blendMode?: BlendModes;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    callback?: VolumeInputCallback;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    slabThickness?: number;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    visibility?: boolean;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    volumeId: string;
}

// @public
interface IVolumeLoadObject {
    cancelFn?: () => void;
    decache?: () => void;
    promise: Promise<ImageVolume>;
}

// @public
interface IVolumeViewport extends IViewport {
    addVolumes(
    volumeInputArray: Array<IVolumeInput>,
    immediate?: boolean,
    suppressEvents?: boolean
    ): Promise<void>;
    canvasToWorld: (canvasPos: Point2) => Point3;
    flip(flipDirection: FlipDirection): void;
    getBounds(): any;
    getCurrentImageId: () => string;
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    getImageData(volumeId?: string): IImageData | undefined;
    getIntensityFromWorld(point: Point3): number;
    getProperties: () => VolumeViewportProperties;
    getSlabThickness(): number;
    hasImageURI: (imageURI: string) => boolean;
    hasVolumeId: (volumeId: string) => boolean;
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    resetCamera(
    resetPan?: boolean,
    resetZoom?: boolean,
    resetToCenter?: boolean
    ): boolean;
    setBlendMode(
    blendMode: BlendModes,
    filterActorUIDs?: Array<string>,
    immediate?: boolean
    ): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis): void;
    setProperties(
        { voiRange }: VolumeViewportProperties,
    volumeId?: string,
    suppressEvents?: boolean
    ): void;
    setSlabThickness(
    slabThickness: number,
    filterActorUIDs?: Array<string>
    ): void;
    setVolumes(
    volumeInputArray: Array<IVolumeInput>,
    immediate?: boolean,
    suppressEvents?: boolean
    ): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
function jumpToSlice(element: HTMLDivElement, options?: JumpToSliceOptions): Promise<void>;

// @public (undocumented)
type JumpToSliceOptions = {
    imageIndex: number;
    debounceLoading?: boolean;
    volumeId?: string;
};

// @public (undocumented)
function jumpToWorld(viewport: Types_2.IVolumeViewport, jumpWorld: Types_2.Point3): true | undefined;

// @public (undocumented)
enum KeyboardBindings {
    // (undocumented)
    Alt = 18,
    // (undocumented)
    AltMeta = 1891,
    // (undocumented)
    Ctrl = 17,
    // (undocumented)
    CtrlAlt = 1718,
    // (undocumented)
    CtrlMeta = 1791,
    // (undocumented)
    Meta = 91,
    // (undocumented)
    Shift = 16,
    // (undocumented)
    ShiftAlt = 1618,
    // (undocumented)
    ShiftCtrl = 1617,
    // (undocumented)
    ShiftMeta = 1691
}

// @public (undocumented)
type KeyDownEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    key: string;
    keyCode: number;
};

// @public (undocumented)
type KeyDownEventType = Types_2.CustomEventType<KeyDownEventDetail>;

// @public (undocumented)
type KeyUpEventDetail = KeyDownEventDetail;

// @public (undocumented)
type KeyUpEventType = Types_2.CustomEventType<KeyUpEventDetail>;

// @public (undocumented)
type LabelmapConfig = {
    renderOutline?: boolean;
    outlineWidthActive?: number;
    outlineWidthInactive?: number;
    renderFill?: boolean;
    renderFillInactive?: boolean;
    fillAlpha?: number;
    fillAlphaInactive?: number;
    outlineOpacity?: number;
    outlineOpacityInactive?: number;
};

// @public (undocumented)
type LabelmapRenderingConfig = {
    cfun?: vtkColorTransferFunction;
    ofun?: vtkPiecewiseFunction;
};

// @public (undocumented)
type LabelmapSegmentationData = {
    volumeId: string;
    referencedVolumeId?: string;
};

declare namespace LabelmapTypes {
    export {
        LabelmapConfig,
        LabelmapRenderingConfig,
        LabelmapSegmentationData
    }
}

// @public (undocumented)
interface LengthAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                length: number;
                unit: string;
            };
        };
    };
}

// @public (undocumented)
export class LengthTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => LengthAnnotation;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    _calculateLength(pos1: any, pos2: any): number;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getTextLines(data: any, targetId: any): string[];
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: LengthAnnotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume(index1: any, index2: any, dimensions: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: LengthAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: LengthAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace lineSegment {
    export {
        distanceToPoint,
        distanceToPointSquared,
        intersectLine
    }
}

declare namespace locking {
    export {
        setAnnotationLocked,
        getAnnotationsLocked,
        getAnnotationsLockedCount,
        unlockAllAnnotations,
        isAnnotationLocked,
        checkAndDefineIsLockedProperty
    }
}

// @public (undocumented)
export class MagnifyTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _bounds: any;
    // (undocumented)
    _createMagnificationViewport: () => void;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragEndCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        referencedImageId: string;
        viewportIdsToRender: string[];
        enabledElement: Types_2.IEnabledElement;
        renderingEngine: Types_2.IRenderingEngine;
        currentPoints: IPoints;
    } | null;
    // (undocumented)
    _getReferencedImageId(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport): string;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    preTouchStartCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    static toolName: any;
}

// @public
type Mat3 = [
number,
number,
number,
number,
number,
number,
number,
number,
number
];

declare namespace math {
    export {
        vec2,
        ellipse,
        lineSegment,
        rectangle,
        polyline,
        point
    }
}

// @public
type Metadata = {
    BitsAllocated: number;
    BitsStored: number;
    SamplesPerPixel: number;
    HighBit: number;
    PhotometricInterpretation: string;
    PixelRepresentation: number;
    Modality: string;
    SeriesInstanceUID?: string;
    ImageOrientationPatient: Array<number>;
    PixelSpacing: Array<number>;
    FrameOfReferenceUID: string;
    Columns: number;
    Rows: number;
    voiLut: Array<VOI>;
    VOILUTFunction: string;
};

// @public (undocumented)
export class MIPJumpToClickTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _bounds: any;
    // (undocumented)
    mouseClickCallback(evt: any): void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
enum MouseBindings {
    // (undocumented)
    Auxiliary = 4,
    // (undocumented)
    Fifth_Button = 16,
    // (undocumented)
    Fourth_Button = 8,
    // (undocumented)
    Primary = 1,
    // (undocumented)
    Primary_And_Auxiliary = 5,
    // (undocumented)
    Primary_And_Secondary = 3,
    // (undocumented)
    Primary_And_Secondary_And_Auxiliary = 7,
    // (undocumented)
    Secondary = 2,
    // (undocumented)
    Secondary_And_Auxiliary = 6
}

// @public (undocumented)
type MouseClickEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseClickEventType = Types_2.CustomEventType<MouseClickEventDetail>;

// @public (undocumented)
class MouseCursor {
    constructor(name: string, fallback?: MouseCursor | undefined);
    // (undocumented)
    addFallbackStyleProperty(style: string): string;
    // (undocumented)
    static getDefinedCursor(name: string): MouseCursor | undefined;
    // (undocumented)
    getName(): string;
    // (undocumented)
    getStyleProperty(): string;
    // (undocumented)
    static setDefinedCursor(name: string, cursor: MouseCursor): boolean;
}

// @public (undocumented)
type MouseDoubleClickEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail;

// @public (undocumented)
type MouseDoubleClickEventType = Types_2.CustomEventType<MouseDoubleClickEventDetail>;

// @public (undocumented)
type MouseDownActivateEventDetail = NormalizedInteractionEventDetail & MousePointsDetail & MouseCustomEventDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseDownActivateEventType = Types_2.CustomEventType<MouseDownActivateEventDetail>;

// @public (undocumented)
type MouseDownEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseDownEventType = Types_2.CustomEventType<MouseDownEventDetail>;

// @public (undocumented)
type MouseDragEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseDragEventType = Types_2.CustomEventType<MouseDragEventDetail>;

// @public (undocumented)
type MouseMoveEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & {
    currentPoints: IPoints;
};

// @public (undocumented)
type MouseMoveEventType = Types_2.CustomEventType<MouseMoveEventDetail>;

// @public (undocumented)
type MouseUpEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseUpEventType = Types_2.CustomEventType<MouseUpEventDetail>;

// @public (undocumented)
type MouseWheelEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & {
    detail: Record<string, any>;
    wheel: {
        spinX: number;
        spinY: number;
        pixelX: number;
        pixelY: number;
        direction: number;
    };
    points: IPoints;
};

// @public (undocumented)
type MouseWheelEventType = Types_2.CustomEventType<MouseWheelEventDetail>;

// @public (undocumented)
type NormalizedInteractionEventDetail = {
    eventName: string;
    renderingEngineId: string;
    viewportId: string;
    camera: Record<string, unknown>;
    element: HTMLDivElement;
};

// @public (undocumented)
type NormalizedMouseEventType = Types_2.CustomEventType<MouseCustomEventDetail>;

// @public (undocumented)
type NormalizedTouchEventType = Types_2.CustomEventType<TouchCustomEventDetail>;

declare namespace orientation_2 {
    export {
        getOrientationStringLPS,
        invertOrientationStringLPS
    }
}

// @public
type OrientationVectors = {
    viewPlaneNormal: Point3;
    viewUp: Point3;
};

// @public (undocumented)
export class PaintFillTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
export class PanTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    mouseDragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback(evt: EventTypes_2.InteractionEventType): void;
}

// @public (undocumented)
type PixelDataTypedArray =
| Float32Array
| Int16Array
| Uint16Array
| Uint8Array
| Int8Array
| Uint8ClampedArray;

declare namespace planar {
    export {
        _default as default,
        filterAnnotationsWithinSlice,
        getWorldWidthAndHeightFromCorners,
        filterAnnotationsForDisplay,
        getPointInLineOfSightWithCriteria
    }
}

// @public (undocumented)
type PlanarBoundingBox = {
    x: number;
    y: number;
    width: number;
    height: number;
};

// @public (undocumented)
interface PlanarFreehandROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        polyline: Types_2.Point3[];
        label?: string;
        isOpenContour?: boolean;
        isOpenUShapeContour?: boolean;
        openUShapeContourVectorToPeak?: Types_2.Point3[];
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        cachedStats?: ROICachedStats;
    };
    // (undocumented)
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        annotationUID?: string;
        FrameOfReferenceUID: string;
        referencedImageId?: string;
        toolName: string;
    };
}

// @public (undocumented)
export class PlanarFreehandROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => PlanarFreehandROIAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewport: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => void;
    // (undocumented)
    filterInteractableAnnotationsForElement(element: HTMLDivElement, annotations: Annotations): Annotations | undefined;
    // (undocumented)
    _getTextLines: (data: any, targetId: string, isPreScaled: boolean, isSuvScaled: boolean) => string[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: PlanarFreehandROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isEditingClosed: boolean;
    // (undocumented)
    isEditingOpen: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: PlanarFreehandROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _renderStats: (annotation: any, viewport: any, enabledElement: any, svgDrawingHelper: any) => void;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: PlanarFreehandROIAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
    // (undocumented)
    triggerAnnotationCompleted: (annotation: PlanarFreehandROIAnnotation) => void;
    // (undocumented)
    triggerAnnotationModified: (annotation: PlanarFreehandROIAnnotation, enabledElement: Types_2.IEnabledElement) => void;
}

declare namespace planarFreehandROITool {
    export {
        _default_2 as default,
        interpolateAnnotation
    }
}

// @public (undocumented)
export class PlanarRotateTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: EventTypes_2.MouseDragEventType): void;
    // (undocumented)
    mouseDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
}

// @public
type Plane = [number, number, number, number];

// @public (undocumented)
function playClip(element: HTMLDivElement, playClipOptions: CINETypes.PlayClipOptions): void;

// @public (undocumented)
type PlayClipOptions = {
    framesPerSecond?: number;
    frameTimeVector?: number[];
    reverse?: boolean;
    loop?: boolean;
    dynamicCineEnabled?: boolean;
    frameTimeVectorSpeedMultiplier?: number;
};

declare namespace point {
    export {
        distanceToPoint_3 as distanceToPoint
    }
}

// @public
type Point2 = [number, number];

// @public
type Point3 = [number, number, number];

// @public
type Point4 = [number, number, number, number];

// @public (undocumented)
const pointCanProjectOnLine: (p: Types_2.Point2, p1: Types_2.Point2, p2: Types_2.Point2, proximity: number) => boolean;

// @public (undocumented)
function pointInEllipse(ellipse: Ellipse, pointLPS: Types_2.Point3): boolean;

// @public (undocumented)
function pointInShapeCallback(imageData: vtkImageData | Types_2.CPUImageData, pointInShapeFn: ShapeFnCriteria, callback: PointInShapeCallback, boundsIJK?: BoundsIJK): void;

// @public (undocumented)
function pointInSurroundingSphereCallback(imageData: vtkImageData, circlePoints: [Types_2.Point3, Types_2.Point3], callback: PointInShapeCallback, viewport?: Types_2.IVolumeViewport): void;

// @public (undocumented)
const pointsAreWithinCloseContourProximity: (p1: Types_2.Point2, p2: Types_2.Point2, closeContourProximity: number) => boolean;

declare namespace polyline {
    export {
        getFirstIntersectionWithPolyline,
        getClosestIntersectionWithPolyline,
        getSubPixelSpacingAndXYDirections,
        pointsAreWithinCloseContourProximity,
        addCanvasPointsToArray,
        pointCanProjectOnLine,
        calculateAreaOfPoints
    }
}

// @public
type PreStackNewImageEvent = CustomEvent_2<PreStackNewImageEventDetail>;

// @public
type PreStackNewImageEventDetail = {
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
interface ProbeAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
        };
        cachedStats: {
            [targetId: string]: {
                Modality: string;
                index: Types_2.Point3;
                value: number;
            };
        };
        label: string;
    };
}

// @public (undocumented)
export class ProbeTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => ProbeAnnotation;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        newAnnotation?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    eventDispatchDetail: {
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getHandleNearImagePoint(element: HTMLDivElement, annotation: ProbeAnnotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    _getTextLines(data: any, targetId: string, isPreScaled: boolean, isSuvScaled: boolean): string[] | undefined;
    // (undocumented)
    _getValueForModality(value: any, imageVolume: any, modality: any): {};
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: ProbeAnnotation): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool(): boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback(): void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
type PTScaling = {
    suvbwToSuvlbm?: number;
    suvbwToSuvbsa?: number;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
type PublicContourSetData = ContourSetData;

// @public (undocumented)
type PublicToolProps = SharedToolProp & {
    name?: string;
};

// @public
type PublicViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions?: ViewportInputOptions;
};

declare namespace rectangle {
    export {
        distanceToPoint_2 as distanceToPoint
    }
}

// @public (undocumented)
interface RectangleROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats?: ROICachedStats | {
            projectionPoints?: Types_2.Point3[];
            projectionPointsImageIds?: string[];
        };
    };
}

// @public (undocumented)
interface RectangleROIStartEndThresholdAnnotation extends Annotation {
    // (undocumented)
    data: {
        label: string;
        startSlice: number;
        endSlice: number;
        cachedStats: {
            projectionPoints: Types_2.Point3[][];
            projectionPointsImageIds: string[];
        };
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
        };
    };
    // (undocumented)
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        annotationUID?: string;
        FrameOfReferenceUID: string;
        referencedImageId?: string;
        toolName: string;
        enabledElement: any;
        volumeId: string;
        spacingInNormal: number;
    };
}

// @public (undocumented)
export class RectangleROIStartEndThresholdTool extends RectangleROITool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => {
        highlighted: boolean;
        invalidated: boolean;
        metadata: {
            viewPlaneNormal: Types_2.Point3;
            enabledElement: Types_2.IEnabledElement;
            viewUp: Types_2.Point3;
            FrameOfReferenceUID: string;
            referencedImageId: any;
            toolName: string;
            volumeId: any;
            spacingInNormal: number;
        };
        data: {
            label: string;
            startSlice: number;
            endSlice: number;
            cachedStats: {
                projectionPoints: any[];
                projectionPointsImageIds: any[];
            };
            handles: {
                textBox: {
                    hasMoved: boolean;
                    worldPosition: any;
                    worldBoundingBox: any;
                };
                points: Types_2.Point3[];
                activeHandleIndex: any;
            };
            labelmapUID: any;
        };
    };
    // (undocumented)
    _calculateCachedStatsTool(annotation: any, enabledElement: any): any;
    // (undocumented)
    _computeProjectionPoints(annotation: RectangleROIStartEndThresholdAnnotation, imageVolume: Types_2.IImageVolume): void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getEndSliceIndex(imageVolume: Types_2.IImageVolume, worldPos: Types_2.Point3, spacingInNormal: number, viewPlaneNormal: Types_2.Point3): number | undefined;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
interface RectangleROIThresholdAnnotation extends Annotation {
    // (undocumented)
    data: {
        label: string;
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
        };
    };
    // (undocumented)
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        annotationUID?: string;
        FrameOfReferenceUID: string;
        referencedImageId?: string;
        toolName: string;
        enabledElement: Types_2.IEnabledElement;
        volumeId: string;
    };
}

// @public (undocumented)
export class RectangleROIThresholdTool extends RectangleROITool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => {
        highlighted: boolean;
        invalidated: boolean;
        metadata: {
            viewPlaneNormal: Types_2.Point3;
            enabledElement: Types_2.IEnabledElement;
            viewUp: Types_2.Point3;
            FrameOfReferenceUID: string;
            referencedImageId: any;
            toolName: string;
            volumeId: any;
        };
        data: {
            label: string;
            handles: {
                textBox: {
                    hasMoved: boolean;
                    worldPosition: any;
                    worldBoundingBox: any;
                };
                points: Types_2.Point3[];
                activeHandleIndex: any;
            };
            segmentationId: any;
        };
    };
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
function rectangleROIThresholdVolumeByRange(annotationUIDs: string[], segmentationVolume: Types_2.IImageVolume, thresholdVolumeInformation: ThresholdInformation[], options: ThresholdOptions): Types_2.IImageVolume;

// @public (undocumented)
export class RectangleROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => RectangleROIAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewPlaneNormal: any, viewUp: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getRectangleImageCoordinates: (points: Array<Types_2.Point2>) => {
        left: number;
        top: number;
        width: number;
        height: number;
    };
    // (undocumented)
    _getTextLines: (data: any, targetId: string, isPreScaled: boolean, isSuvScaled: boolean) => string[] | undefined;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: RectangleROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: RectangleROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: RectangleROIAnnotation) => void;
}

declare namespace rectangleROITool {
    export {
        getBoundsIJKFromRectangleAnnotations
    }
}

// @public (undocumented)
export class RectangleScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentationId: string;
        segmentation: any;
        segmentIndex: number;
        segmentsLocked: number[];
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
interface ReferenceCursor extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: [Types_2.Point3];
        };
    };
}

// @public (undocumented)
export class ReferenceCursors extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    createInitialAnnotation: (worldPos: Types_2.Point3, element: HTMLDivElement) => void;
    // (undocumented)
    _currentCanvasPosition: null | Types_2.Point2;
    // (undocumented)
    _currentCursorWorldPosition: null | Types_2.Point3;
    // (undocumented)
    _disableCursorEnabled: boolean;
    // (undocumented)
    _elementWithCursor: null | HTMLDivElement;
    // (undocumented)
    filterInteractableAnnotationsForElement(element: HTMLDivElement, annotations: Annotations): Annotations;
    // (undocumented)
    getActiveAnnotation(element: HTMLDivElement): null | Annotation;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    onCameraModified: (evt: any) => void;
    // (undocumented)
    onSetToolActive(): void;
    // (undocumented)
    onSetToolDisabled(): void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
    // (undocumented)
    updateAnnotationPosition(element: HTMLDivElement, annotation: Annotation): void;
    // (undocumented)
    updateViewportImage(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport): void;
}

// @public (undocumented)
interface ReferenceLineAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
        };
    };
}

// @public (undocumented)
class ReferenceLines extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    editData: {
        renderingEngine: any;
        sourceViewport: any;
        annotation: ReferenceLineAnnotation;
    } | null;
    // (undocumented)
    _init: () => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isParallel(vec1: Types_2.Point3, vec2: Types_2.Point3): boolean;
    // (undocumented)
    isPerpendicular: (vec1: Types_2.Point3, vec2: Types_2.Point3) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    onCameraModified: (evt: Types_2.EventTypes.CameraModifiedEvent) => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}
export { ReferenceLines }
export { ReferenceLines as ReferenceLinesTool }

// @public (undocumented)
function registerCursor(toolName: string, iconContent: string, viewBox: {
    x: number;
    y: number;
}): void;

// @public (undocumented)
function removeAllAnnotations(): void;

// @public (undocumented)
function removeAnnotation(annotationUID: string): void;

// @public (undocumented)
function removeColorLUT(colorLUTIndex: number): void;

// @public (undocumented)
function removeSegmentation(segmentationId: string): void;

// @public (undocumented)
function removeSegmentationRepresentation(toolGroupId: string, segmentationRepresentationUID: string): void;

// @public (undocumented)
function removeSegmentationsFromToolGroup(toolGroupId: string, segmentationRepresentationUIDs?: string[] | undefined, immediate?: boolean): void;

// @public (undocumented)
export function removeTool(ToolClass: any): void;

// @public (undocumented)
type RepresentationConfig = {
    LABELMAP?: LabelmapConfig;
    CONTOUR?: ContourConfig;
};

// @public (undocumented)
type RepresentationPublicInput = {
    segmentationId: string;
    type: Enums.SegmentationRepresentations;
};

// @public (undocumented)
function resetAnnotationManager(): void;

// @public (undocumented)
function resetElementCursor(element: HTMLDivElement): void;

// @public
type RGB = [number, number, number];

// @public (undocumented)
interface ScaleOverlayAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
        };
        viewportId: string;
    };
}

// @public (undocumented)
export class ScaleOverlayTool extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    computeCanvasScaleCoordinates: (canvasSize: any, canvasCoordinates: any, vscaleBounds: any, hscaleBounds: any, location: any) => any;
    // (undocumented)
    computeEndScaleTicks: (canvasCoordinates: any, location: any) => {
        endTick1: any[][];
        endTick2: any[][];
    };
    // (undocumented)
    computeInnerScaleTicks: (scaleSize: number, location: string, annotationUID: string, leftTick: any[][], rightTick: any[][]) => {
        tickIds: any[];
        tickUIDs: any[];
        tickCoordinates: any[];
    };
    // (undocumented)
    computeScaleBounds: (canvasSize: any, horizontalReduction: any, verticalReduction: any, location: any) => {
        height: any;
        width: any;
    };
    // (undocumented)
    computeScaleSize: (worldWidthViewport: number, worldHeightViewport: number, location: any) => any;
    // (undocumented)
    computeWorldScaleCoordinates: (scaleSize: any, location: any, pointSet: any) => any;
    // (undocumented)
    editData: {
        renderingEngine: any;
        viewport: any;
        annotation: ScaleOverlayAnnotation;
    } | null;
    // (undocumented)
    _getTextLines(scaleSize: number): string[] | undefined;
    // (undocumented)
    _init: () => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    onCameraModified: (evt: Types_2.EventTypes.CameraModifiedEvent) => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
type Scaling = {
    PET?: PTScaling;
};

// @public (undocumented)
type ScalingParameters = {
    rescaleSlope: number;
    rescaleIntercept: number;
    modality: string;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
function scroll_2(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, options: ScrollOptions_2): void;

// @public (undocumented)
type ScrollOptions_2 = {
    delta: number;
    volumeId?: string;
    debounceLoading?: boolean;
    loop?: boolean;
};

// @public (undocumented)
type Segmentation = {
    segmentationId: string;
    type: Enums.SegmentationRepresentations;
    label: string;
    activeSegmentIndex: number;
    segmentsLocked: Set<number>;
    cachedStats: {
        [key: string]: number;
    };
    segmentLabels: {
        [key: string]: string;
    };
    representationData: SegmentationRepresentationData;
};

declare namespace segmentation {
    export {
        state_3 as state,
        addSegmentations,
        activeSegmentation,
        addSegmentationRepresentations,
        removeSegmentationsFromToolGroup,
        segmentLocking,
        config_2 as config,
        segmentIndex,
        triggerSegmentationEvents
    }
}
export { segmentation }

declare namespace segmentation_2 {
    export {
        thresholdVolumeByRange,
        createMergedLabelmapForIndex,
        isValidRepresentationConfig,
        getDefaultRepresentationConfig,
        createLabelmapVolumeForViewport,
        rectangleROIThresholdVolumeByRange,
        triggerSegmentationRender,
        floodFill,
        getBrushSizeForToolGroup,
        setBrushSizeForToolGroup,
        getBrushThresholdForToolGroup,
        setBrushThresholdForToolGroup,
        thresholdSegmentationByRange
    }
}

// @public (undocumented)
type SegmentationDataModifiedEventDetail = {
    segmentationId: string;
    modifiedSlicesToUse?: number[];
};

// @public (undocumented)
type SegmentationDataModifiedEventType = Types_2.CustomEventType<SegmentationDataModifiedEventDetail>;

// @public (undocumented)
export class SegmentationDisplayTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _getMergedRepresentationsConfig(toolGroupId: string): SegmentationRepresentationConfig;
    // (undocumented)
    onSetToolDisabled(): void;
    // (undocumented)
    onSetToolEnabled(): void;
    // (undocumented)
    renderSegmentation: (toolGroupId: string) => void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
type SegmentationModifiedEventDetail = {
    segmentationId: string;
};

// @public (undocumented)
type SegmentationModifiedEventType = Types_2.CustomEventType<SegmentationModifiedEventDetail>;

// @public (undocumented)
type SegmentationRemovedEventDetail = {
    segmentationId: string;
};

// @public (undocumented)
type SegmentationRemovedEventType = Types_2.CustomEventType<SegmentationRemovedEventDetail>;

// @public (undocumented)
type SegmentationRenderedEventDetail = {
    viewportId: string;
    toolGroupId: string;
};

// @public (undocumented)
type SegmentationRenderedEventType = Types_2.CustomEventType<SegmentationRenderedEventDetail>;

// @public (undocumented)
type SegmentationRepresentationConfig = {
    renderInactiveSegmentations: boolean;
    representations: RepresentationConfig;
};

// @public (undocumented)
type SegmentationRepresentationData = {
    LABELMAP?: LabelmapSegmentationData;
    CONTOUR?: ContourSegmentationData;
};

// @public (undocumented)
type SegmentationRepresentationModifiedEventDetail = {
    toolGroupId: string;
    segmentationRepresentationUID: string;
};

// @public (undocumented)
type SegmentationRepresentationModifiedEventType = Types_2.CustomEventType<SegmentationRepresentationModifiedEventDetail>;

// @public (undocumented)
type SegmentationRepresentationRemovedEventDetail = {
    toolGroupId: string;
    segmentationRepresentationUID: string;
};

// @public (undocumented)
type SegmentationRepresentationRemovedEventType = Types_2.CustomEventType<SegmentationRepresentationRemovedEventDetail>;

// @public (undocumented)
enum SegmentationRepresentations {
    // (undocumented)
    Contour = "CONTOUR",
    // (undocumented)
    Labelmap = "LABELMAP"
}

// @public (undocumented)
type SegmentationState = {
    colorLUT: ColorLUT[];
    segmentations: Segmentation[];
    globalConfig: SegmentationRepresentationConfig;
    toolGroups: {
        [key: string]: {
            segmentationRepresentations: ToolGroupSpecificRepresentations;
            config: SegmentationRepresentationConfig;
        };
    };
};

declare namespace segmentIndex {
    export {
        getActiveSegmentIndex,
        setActiveSegmentIndex
    }
}

declare namespace segmentLocking {
    export {
        isSegmentIndexLocked,
        setSegmentIndexLocked,
        getLockedSegments
    }
}

declare namespace selection {
    export {
        setAnnotationSelected,
        getAnnotationsSelected,
        getAnnotationsSelectedByToolName,
        getAnnotationsSelectedCount,
        deselectAnnotation,
        isAnnotationSelected
    }
}

// @public (undocumented)
function setActiveSegmentationRepresentation(toolGroupId: string, segmentationRepresentationUID: string): void;

// @public (undocumented)
function setActiveSegmentIndex(segmentationId: string, segmentIndex: number): void;

// @public (undocumented)
function setAnnotationLocked(annotation: Annotation, locked?: boolean): void;

// @public (undocumented)
function setAnnotationManager(annotationManager: any): void;

// @public (undocumented)
function setAnnotationSelected(annotationUID: string, selected?: boolean, preserveSelected?: boolean): void;

// @public (undocumented)
function setAnnotationVisibility(annotationUID: string, visible?: boolean): void;

// @public (undocumented)
function setBrushSizeForToolGroup(toolGroupId: string, brushSize: number): void;

// @public (undocumented)
function setBrushThresholdForToolGroup(toolGroupId: string, threshold: Types_2.Point2): void;

// @public (undocumented)
function setColorForSegmentIndex(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number, color: Color): void;

// @public (undocumented)
function setColorLUT(toolGroupId: string, segmentationRepresentationUID: string, colorLUTIndex: number): void;

// @public (undocumented)
function setConfiguration(config: any): void;

// @public (undocumented)
function setCursorForElement(element: HTMLDivElement, cursorName: string): void;

// @public (undocumented)
function _setElementCursor(element: HTMLDivElement, cursor: MouseCursor | null): void;

// @public (undocumented)
function setGlobalConfig(config: SegmentationRepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setGlobalConfig_2(segmentationConfig: SegmentationRepresentationConfig): void;

// @public (undocumented)
function setGlobalRepresentationConfig(representationType: SegmentationRepresentations, config: RepresentationConfig['LABELMAP']): void;

// @public (undocumented)
function setSegmentationRepresentationSpecificConfig(toolGroupId: string, segmentationRepresentationUID: string, config: RepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setSegmentationRepresentationSpecificConfig_2(toolGroupId: string, segmentationRepresentationUID: string, config: RepresentationConfig): void;

// @public (undocumented)
function setSegmentationVisibility(toolGroupId: string, segmentationRepresentationUID: string, visibility: boolean): void;

// @public (undocumented)
function setSegmentIndexLocked(segmentationId: string, segmentIndex: number, locked?: boolean): void;

// @public (undocumented)
function setSegmentSpecificConfig(toolGroupId: string, segmentationRepresentationUID: string, config: SegmentSpecificRepresentationConfig): void;

// @public (undocumented)
function setSegmentSpecificRepresentationConfig(toolGroupId: string, segmentationRepresentationUID: string, config: SegmentSpecificRepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setSegmentsVisibility(toolGroupId: string, segmentationRepresentationUID: string, segmentIndices: number[], visibility: boolean): void;

// @public (undocumented)
function setSegmentVisibility(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number, visibility: boolean): void;

// @public (undocumented)
type SetToolBindingsType = {
    bindings: IToolBinding[];
};

// @public (undocumented)
function setToolGroupSpecificConfig(toolGroupId: string, config: SegmentationRepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setToolGroupSpecificConfig_2(toolGroupId: string, segmentationRepresentationConfig: SegmentationRepresentationConfig): void;

// @public (undocumented)
function showAllAnnotations(): void;

// @public (undocumented)
export class SphereScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentation: any;
        segmentIndex: number;
        segmentsLocked: number[];
        segmentationId: string;
        toolGroupId: string;
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        centerCanvas?: Array<number>;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => true;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public
type StackNewImageEvent = CustomEvent_2<StackNewImageEventDetail>;

// @public
type StackNewImageEventDetail = {
    image: IImage;
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

declare namespace stackPrefetch {
    export {
        enable,
        disable,
        setConfiguration,
        getConfiguration
    }
}

// @public (undocumented)
export class StackScrollMouseWheelTool extends BaseTool {
    constructor(toolProps?: {}, defaultToolProps?: {
        supportedInteractionTypes: string[];
        configuration: {
            invert: boolean;
            debounceIfNotLoaded: boolean;
            loop: boolean;
        };
    });
    // (undocumented)
    _configuration: any;
    // (undocumented)
    mouseWheelCallback(evt: MouseWheelEventType): void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
export class StackScrollTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    deltaY: number;
    // (undocumented)
    _dragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    _getNumberOfSlices(viewport: any): number;
    // (undocumented)
    _getPixelPerImage(viewport: any): number;
    // (undocumented)
    mouseDragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback(evt: EventTypes_2.InteractionEventType): void;
}

// @public
type StackViewportNewStackEvent =
CustomEvent_2<StackViewportNewStackEventDetail>;

// @public
type StackViewportNewStackEventDetail = {
    imageIds: string[];
    viewportId: string;
    element: HTMLDivElement;
    currentImageIdIndex: number;
};

// @public
type StackViewportProperties = ViewportProperties & {
    interpolationType?: InterpolationType;
    rotation?: number;
    suppressEvents?: boolean;
    isComputedVOI?: boolean;
};

// @public (undocumented)
type StackViewportScrollEvent = CustomEvent_2<StackViewportScrollEventDetail>;

// @public
type StackViewportScrollEventDetail = {
    newImageIdIndex: number;
    imageId: string;
    direction: number;
};

// @public (undocumented)
export let state: ICornerstoneTools3dState;

declare namespace state_2 {
    export {
        getAnnotations,
        getNumberOfAnnotations,
        addAnnotation,
        getAnnotation,
        removeAnnotation,
        removeAllAnnotations,
        setAnnotationManager,
        getAnnotationManager,
        resetAnnotationManager
    }
}

declare namespace state_3 {
    export {
        getDefaultSegmentationStateManager,
        getSegmentation,
        getSegmentations,
        addSegmentation,
        removeSegmentation,
        getSegmentationRepresentations,
        addSegmentationRepresentation,
        removeSegmentationRepresentation,
        getToolGroupSpecificConfig,
        setToolGroupSpecificConfig,
        getGlobalConfig,
        setGlobalConfig,
        getSegmentationRepresentationSpecificConfig,
        setSegmentationRepresentationSpecificConfig,
        getSegmentSpecificRepresentationConfig,
        setSegmentSpecificRepresentationConfig,
        getToolGroupIdsWithSegmentation,
        getSegmentationRepresentationByUID,
        addColorLUT,
        getColorLUT,
        removeColorLUT
    }
}

// @public (undocumented)
function stopClip(element: HTMLDivElement): void;

// @public (undocumented)
type StyleConfig = {
    annotations?: {
        [annotationUID: string]: AnnotationStyle_2;
    };
    viewports?: {
        [viewportId: string]: ToolStyleConfig;
    };
    toolGroups?: {
        [toolGroupId: string]: ToolStyleConfig;
    };
    default: ToolStyleConfig;
};

// @public (undocumented)
type StyleSpecifier = {
    viewportId?: string;
    toolGroupId?: string;
    toolName?: string;
    annotationUID?: string;
};

// @public (undocumented)
type SVGCursorDescriptor = {
    iconContent: string;
    iconSize: number;
    viewBox: SVGPoint_2;
    mousePoint: SVGPoint_2;
    mousePointerGroupString: string;
};

// @public (undocumented)
type SVGDrawingHelper = {
    svgLayerElement: HTMLDivElement;
    svgNodeCacheForCanvas: Record<string, unknown>;
    getSvgNode: (cacheKey: string) => SVGGElement | undefined;
    appendNode: (svgNode: SVGElement, cacheKey: string) => void;
    setNodeTouched: (cacheKey: string) => void;
    clearUntouched: () => void;
};

// @public (undocumented)
class SVGMouseCursor extends ImageMouseCursor {
    constructor(url: string, x?: number, y?: number, name?: string | undefined, fallback?: MouseCursor | undefined);
    // (undocumented)
    static getDefinedCursor(name: string, pointer?: boolean, color?: string): MouseCursor;
}

// @public (undocumented)
type SVGPoint_2 = {
    x: number;
    y: number;
};

// @public (undocumented)
enum Swipe {
    // (undocumented)
    DOWN = "DOWN",
    // (undocumented)
    LEFT = "LEFT",
    // (undocumented)
    RIGHT = "RIGHT",
    // (undocumented)
    UP = "UP"
}

// @public (undocumented)
export class Synchronizer {
    constructor(synchronizerId: string, eventName: string, eventHandler: ISynchronizerEventHandler);
    // (undocumented)
    add(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    addSource(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    addTarget(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    getOptions(viewportId: string): Record<string, unknown> | undefined;
    // (undocumented)
    getSourceViewports(): Array<Types_2.IViewportId>;
    // (undocumented)
    getTargetViewports(): Array<Types_2.IViewportId>;
    // (undocumented)
    hasSourceViewport(renderingEngineId: string, viewportId: string): boolean;
    // (undocumented)
    hasTargetViewport(renderingEngineId: string, viewportId: string): boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    isDisabled(): boolean;
    // (undocumented)
    remove(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    removeSource(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    removeTarget(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    setOptions(viewportId: string, options?: Record<string, unknown>): void;
}

declare namespace SynchronizerManager {
    export {
        createSynchronizer,
        destroy_2 as destroy,
        getSynchronizer,
        getSynchronizersForViewport,
        getAllSynchronizers,
        destroySynchronizer
    }
}
export { SynchronizerManager }

declare namespace synchronizers {
    export {
        createCameraPositionSynchronizer,
        createVOISynchronizer,
        createZoomPanSynchronizer,
        createStackImageSynchronizer
    }
}
export { synchronizers }

// @public (undocumented)
type TextBoxHandle = {
    hasMoved: boolean;
    worldBoundingBox: {
        bottomLeft: Types_2.Point3;
        bottomRight: Types_2.Point3;
        topLeft: Types_2.Point3;
        topRight: Types_2.Point3;
    };
    worldPosition: Types_2.Point3;
};

// @public (undocumented)
function thresholdSegmentationByRange(segmentationVolume: Types_2.IImageVolume, segmentationIndex: number, thresholdVolumeInformation: ThresholdInformation[], overlapType: number): Types_2.IImageVolume;

// @public (undocumented)
function thresholdVolumeByRange(segmentationVolume: Types_2.IImageVolume, thresholdVolumeInformation: ThresholdInformation[], options: ThresholdRangeOptions): Types_2.IImageVolume;

// @public (undocumented)
function throttle(func: Function, wait?: number, options?: {
    leading?: boolean;
    trailing?: boolean;
}): Function;

// @public (undocumented)
interface ToolData {
    // (undocumented)
    dynamicCineEnabled?: boolean;
    // (undocumented)
    framesPerSecond: number;
    // (undocumented)
    frameTimeVector: number[] | undefined;
    // (undocumented)
    ignoreFrameTimeVector: boolean;
    // (undocumented)
    intervalId: number | undefined;
    // (undocumented)
    lastFrameTimeStamp: number | undefined;
    // (undocumented)
    loop: boolean;
    // (undocumented)
    reverse: boolean;
    // (undocumented)
    speed: number;
    // (undocumented)
    usingFrameTimeVector: boolean;
}

declare namespace ToolGroupManager {
    export {
        createToolGroup,
        destroy_3 as destroy,
        destroyToolGroup,
        getToolGroup,
        getToolGroupForViewport,
        getAllToolGroups,
        getToolGroupsWithToolName
    }
}
export { ToolGroupManager }

// @public (undocumented)
type ToolGroupSpecificContourRepresentation = ToolGroupSpecificRepresentationState & {
    config: ContourRenderingConfig;
    segmentationRepresentationSpecificConfig?: RepresentationConfig;
    segmentSpecificConfig?: SegmentSpecificRepresentationConfig;
};

// @public (undocumented)
type ToolGroupSpecificLabelmapRepresentation = ToolGroupSpecificRepresentationState & {
    config: LabelmapRenderingConfig;
    segmentationRepresentationSpecificConfig?: RepresentationConfig;
    segmentSpecificConfig?: SegmentSpecificRepresentationConfig;
};

// @public (undocumented)
type ToolGroupSpecificRepresentation = ToolGroupSpecificLabelmapRepresentation | ToolGroupSpecificContourRepresentation;

// @public (undocumented)
type ToolGroupSpecificRepresentationState = {
    segmentationRepresentationUID: string;
    segmentationId: string;
    type: Enums.SegmentationRepresentations;
    active: boolean;
    segmentsHidden: Set<number>;
    colorLUTIndex: number;
};

// @public (undocumented)
type ToolHandle = AnnotationHandle | TextBoxHandle;

// @public (undocumented)
enum ToolModes {
    // (undocumented)
    Active = "Active",
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled",
    // (undocumented)
    Passive = "Passive"
}

// @public (undocumented)
type ToolOptionsType = {
    bindings: IToolBinding[];
    mode: ToolModes;
};

// @public (undocumented)
type ToolProps = SharedToolProp;

declare namespace ToolSpecificAnnotationTypes {
    export {
        RectangleROIAnnotation,
        ProbeAnnotation,
        LengthAnnotation,
        CircleROIAnnotation,
        EllipticalROIAnnotation,
        BidirectionalAnnotation,
        RectangleROIThresholdAnnotation,
        RectangleROIStartEndThresholdAnnotation,
        PlanarFreehandROIAnnotation,
        ArrowAnnotation,
        AngleAnnotation,
        ReferenceCursor,
        ReferenceLineAnnotation,
        ScaleOverlayAnnotation
    }
}

// @public (undocumented)
const toolStyle: ToolStyle;

// @public (undocumented)
type ToolStyleConfig = {
    [toolName: string]: AnnotationStyle_2;
} & {
    global?: AnnotationStyle_2;
};

declare namespace touch {
    export {
        getMeanPoints,
        getMeanTouchPoints,
        copyPoints,
        copyPointsList,
        getDeltaDistanceBetweenIPoints,
        getDeltaPoints,
        getDeltaDistance,
        getDeltaRotation
    }
}

// @public (undocumented)
type TouchDragEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & TouchPointsDetail;

// @public (undocumented)
type TouchDragEventType = Types_2.CustomEventType<TouchDragEventDetail>;

// @public (undocumented)
type TouchEndEventDetail = NormalizedInteractionEventDetail & TouchPointsDetail & TouchCustomEventDetail;

// @public (undocumented)
type TouchEndEventType = Types_2.CustomEventType<TouchEndEventDetail>;

// @public (undocumented)
type TouchPressEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & {
    startPointsList: ITouchPoints[];
    lastPointsList: ITouchPoints[];
    startPoints: ITouchPoints;
    lastPoints: ITouchPoints;
};

// @public (undocumented)
type TouchPressEventType = Types_2.CustomEventType<TouchPressEventDetail>;

// @public (undocumented)
type TouchStartActivateEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & TouchPointsDetail;

// @public (undocumented)
type TouchStartActivateEventType = Types_2.CustomEventType<TouchStartActivateEventDetail>;

// @public (undocumented)
type TouchStartEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & TouchPointsDetail;

// @public (undocumented)
type TouchStartEventType = Types_2.CustomEventType<TouchStartEventDetail>;

// @public (undocumented)
type TouchSwipeEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & {
    swipe: Swipe;
};

// @public (undocumented)
type TouchSwipeEventType = Types_2.CustomEventType<TouchSwipeEventDetail>;

// @public (undocumented)
type TouchTapEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & {
    currentPointsList: ITouchPoints[];
    currentPoints: ITouchPoints;
    taps: number;
};

// @public (undocumented)
type TouchTapEventType = Types_2.CustomEventType<TouchTapEventDetail>;

// @public (undocumented)
export class TrackballRotateTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    mouseDragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    rotateCamera: (viewport: any, centerWorld: any, axis: any, angle: any) => void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: (evt: EventTypes_2.InteractionEventType) => void;
}

// @public
type TransformMatrix2D = [number, number, number, number, number, number];

// @public (undocumented)
function triggerAnnotationRender(element: HTMLDivElement): void;

// @public (undocumented)
function triggerAnnotationRenderForViewportIds(renderingEngine: Types_2.IRenderingEngine, viewportIdsToRender: string[]): void;

// @public
function triggerEvent(
el: EventTarget = eventTarget,
type: string,
detail: unknown = null
): boolean {
    if (!type) {
        throw new Error('Event type was not defined');
    }

    const // (undocumented)
    event = new CustomEvent(type, {
        detail,
        cancelable: true,
    });

    return el.dispatchEvent(event);
}

// @public (undocumented)
function triggerSegmentationDataModified(segmentationId: string, modifiedSlicesToUse?: number[]): void;

declare namespace triggerSegmentationEvents {
    export {
        triggerSegmentationRepresentationModified,
        triggerSegmentationRepresentationRemoved,
        triggerSegmentationDataModified,
        triggerSegmentationModified,
        triggerSegmentationRemoved
    }
}

// @public (undocumented)
function triggerSegmentationModified(segmentationId?: string): void;

// @public (undocumented)
function triggerSegmentationRemoved(segmentationId: string): void;

// @public (undocumented)
function triggerSegmentationRender(toolGroupId: string): void;

// @public (undocumented)
function triggerSegmentationRepresentationModified(toolGroupId: string, segmentationRepresentationUID?: string): void;

// @public (undocumented)
function triggerSegmentationRepresentationRemoved(toolGroupId: string, segmentationRepresentationUID: string): void;

declare namespace Types {
    export {
        Annotation,
        Annotations,
        IAnnotationManager,
        GroupSpecificAnnotations,
        AnnotationState,
        AnnotationStyle,
        ToolSpecificAnnotationTypes,
        JumpToSliceOptions,
        AnnotationGroupSelector,
        PlanarBoundingBox,
        ToolProps,
        PublicToolProps,
        EventTypes_2 as EventTypes,
        IPoints,
        ITouchPoints,
        IDistance,
        IToolBinding,
        SetToolBindingsType,
        ToolOptionsType,
        InteractionTypes,
        IToolGroup,
        IToolClassReference,
        ISynchronizerEventHandler,
        ToolHandle,
        AnnotationHandle,
        TextBoxHandle,
        Segmentation,
        SegmentationState,
        SegmentationRepresentationData,
        SegmentationRepresentationConfig,
        RepresentationConfig,
        ToolGroupSpecificRepresentationState,
        ToolGroupSpecificContourRepresentation,
        ToolGroupSpecificLabelmapRepresentation,
        ToolGroupSpecificRepresentation,
        RepresentationPublicInput,
        Color,
        ColorLUT,
        LabelmapTypes,
        SVGCursorDescriptor,
        SVGPoint_2 as SVGPoint,
        ScrollOptions_2 as ScrollOptions,
        CINETypes,
        BoundsIJK,
        SVGDrawingHelper,
        FloodFillResult,
        FloodFillGetter,
        FloodFillOptions,
        ContourSegmentationData
    }
}
export { Types }

// @public (undocumented)
function unlockAllAnnotations(): void;

declare namespace utilities {
    export {
        math,
        planar,
        viewportFilters,
        drawing_2 as drawing,
        debounce,
        dynamicVolume,
        throttle,
        orientation_2 as orientation,
        isObject,
        touch,
        triggerEvent,
        calibrateImageSpacing,
        segmentation_2 as segmentation,
        triggerAnnotationRenderForViewportIds,
        triggerAnnotationRender,
        pointInShapeCallback,
        pointInSurroundingSphereCallback,
        getAnnotationNearPoint,
        getAnnotationNearPointOnEnabledElement,
        jumpToSlice,
        viewport,
        cine,
        clip_2 as clip,
        boundingBox,
        rectangleROITool,
        planarFreehandROITool,
        stackPrefetch,
        scroll_2 as scroll
    }
}
export { utilities }

declare namespace vec2 {
    export {
        findClosestPoint,
        clip as liangBarksyClip
    }
}

declare namespace viewport {
    export {
        isViewportPreScaled,
        jumpToSlice,
        jumpToWorld
    }
}

declare namespace viewportFilters {
    export {
        filterViewportsWithToolEnabled,
        filterViewportsWithFrameOfReferenceUID,
        getViewportIdsWithToolToRender,
        filterViewportsWithParallelNormals
    }
}

// @public
type ViewportInputOptions = {
    background?: RGB;
    orientation?: OrientationAxis | OrientationVectors;
    displayArea?: DisplayArea;
    suppressEvents?: boolean;
    parallelProjection?: boolean;
};

// @public (undocumented)
interface ViewportPreset {
    // (undocumented)
    ambient: string;
    // (undocumented)
    colorTransfer: string;
    // (undocumented)
    diffuse: string;
    // (undocumented)
    gradientOpacity: string;
    // (undocumented)
    interpolation: string;
    // (undocumented)
    name: string;
    // (undocumented)
    scalarOpacity: string;
    // (undocumented)
    shade: string;
    // (undocumented)
    specular: string;
    // (undocumented)
    specularPower: string;
}

// @public
type ViewportProperties = {
    voiRange?: VOIRange;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
};

declare namespace visibility {
    export {
        setAnnotationVisibility,
        showAllAnnotations,
        isAnnotationVisible,
        checkAndDefineIsVisibleProperty
    }
}

declare namespace visibility_2 {
    export {
        setSegmentationVisibility,
        getSegmentationVisibility,
        setSegmentVisibility,
        setSegmentsVisibility
    }
}

// @public (undocumented)
type VOI = {
    windowWidth: number;
    windowCenter: number;
};

// @public
type VoiModifiedEvent = CustomEvent_2<VoiModifiedEventDetail>;

// @public
type VoiModifiedEventDetail = {
    viewportId: string;
    range: VOIRange;
    volumeId?: string;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
};

// @public (undocumented)
type VOIRange = {
    upper: number;
    lower: number;
};

// @public (undocumented)
type VolumeActor = vtkVolume;

// @public
type VolumeCacheVolumeAddedEvent =
CustomEvent_2<VolumeCacheVolumeAddedEventDetail>;

// @public
type VolumeCacheVolumeAddedEventDetail = {
    volume: ICachedVolume;
};

// @public
type VolumeCacheVolumeRemovedEvent =
CustomEvent_2<VolumeCacheVolumeRemovedEventDetail>;

// @public
type VolumeCacheVolumeRemovedEventDetail = {
    volumeId: string;
};

// @public
type VolumeInputCallback = (params: {
    volumeActor: VolumeActor;
    volumeId: string;
}) => unknown;

// @public
type VolumeLoadedEvent = CustomEvent_2<VolumeLoadedEventDetail>;

// @public
type VolumeLoadedEventDetail = {
    volume: IImageVolume;
};

// @public
type VolumeLoadedFailedEvent = CustomEvent_2<VolumeLoadedFailedEventDetail>;

// @public
type VolumeLoadedFailedEventDetail = {
    volumeId: string;
    error: unknown;
};

// @public
type VolumeLoaderFn = (
volumeId: string,
options?: Record<string, any>
) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public
type VolumeNewImageEvent = CustomEvent_2<VolumeNewImageEventDetail>;

// @public
type VolumeNewImageEventDetail = {
    imageIndex: number;
    numberOfSlices: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
export class VolumeRotateMouseWheelTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _configuration: any;
    // (undocumented)
    mouseWheelCallback(evt: MouseWheelEventType): void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
type VolumeScalarData = Float32Array | Uint8Array | Uint16Array | Int16Array;

// @public (undocumented)
type VolumeScrollOutOfBoundsEventDetail = {
    volumeId: string;
    viewport: Types_2.IVolumeViewport;
    desiredStepIndex: number;
    currentStepIndex: number;
    delta: number;
    numScrollSteps: number;
    currentImageId: string;
};

// @public (undocumented)
type VolumeScrollOutOfBoundsEventType = Types_2.CustomEventType<VolumeScrollOutOfBoundsEventDetail>;

// @public
type VolumeViewportProperties = ViewportProperties & {
    colormap?: ColormapPublic;
    preset?: string;
};

// @public (undocumented)
export class WindowLevelTool extends BaseTool {
    constructor(toolProps?: {}, defaultToolProps?: {
        supportedInteractionTypes: string[];
    });
    // (undocumented)
    _getImageDynamicRangeFromMiddleSlice: (scalarData: any, dimensions: any) => number;
    // (undocumented)
    _getImageDynamicRangeFromViewport(viewport: any): number;
    // (undocumented)
    _getMultiplierFromDynamicRange(viewport: any, volumeId: any): number;
    // (undocumented)
    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }: {
        viewport: any;
        deltaPointsCanvas: any;
        volumeId: any;
        lower: any;
        upper: any;
    }): {
        lower: number;
        upper: number;
    };
    // (undocumented)
    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }: {
        deltaPointsCanvas: any;
        lower: any;
        upper: any;
        clientHeight: any;
        viewport: any;
        volumeId: any;
        isPreScaled: any;
    }): {
        lower: any;
        upper: any;
    };
    // (undocumented)
    mouseDragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback(evt: EventTypes_2.InteractionEventType): void;
}

// @public (undocumented)
export class ZoomTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    dirVec: Types_2.Point3;
    // (undocumented)
    _dragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    _dragParallelProjection: (evt: EventTypes_2.InteractionEventType, viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, camera: Types_2.ICamera, pinch?: boolean) => void;
    // (undocumented)
    _dragPerspectiveProjection: (evt: EventTypes_2.InteractionEventType, viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, camera: Types_2.ICamera, pinch?: boolean) => void;
    // (undocumented)
    initialMousePosWorld: Types_2.Point3;
    // (undocumented)
    mouseDragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _panCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    _pinchCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    preTouchStartCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: (evt: EventTypes_2.InteractionEventType) => void;
}

// (No @packageDocumentation comment for this package)

```

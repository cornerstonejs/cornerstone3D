## API Report File for "@cornerstonejs/tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { mat4 } from 'gl-matrix';
import type vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';
import type { vtkColorTransferFunction } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';
import type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';
import vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import type { vtkPiecewiseFunction } from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';
import type vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';

declare namespace activeSegmentation {
    export {
        getActiveSegmentationRepresentation,
        setActiveSegmentationRepresentation
    }
}

// @public (undocumented)
type Actor = vtkActor;

// @public
type ActorEntry = {
    uid: string;
    actor: Actor | VolumeActor | ImageActor;
    slabThickness?: number;
};

// @public
type ActorSliceRange = {
    actor: VolumeActor;
    viewPlaneNormal: Point3;
    focalPoint: Point3;
    min: number;
    max: number;
    current: number;
};

// @public (undocumented)
function addAnnotation(element: HTMLDivElement, annotation: Annotation): void;

// @public (undocumented)
const addCanvasPointsToArray: (element: HTMLDivElement, canvasPoints: Types_2.Point2[], newCanvasPoint: Types_2.Point2, commonData: PlanarFreehandROICommonData) => number;

// @public (undocumented)
function addColorLUT(colorLUT: ColorLUT, index: number): void;

// @public (undocumented)
function addColorLUT_2(colorLUT: ColorLUT, colorLUTIndex: number): void;

// @public (undocumented)
function addSegmentation(segmentationInput: SegmentationPublicInput, suppressEvents?: boolean): void;

// @public (undocumented)
function addSegmentationRepresentation(toolGroupId: string, segmentationRepresentation: ToolGroupSpecificRepresentation, suppressEvents?: boolean): void;

// @public (undocumented)
function addSegmentationRepresentations(toolGroupId: string, representationInputArray: RepresentationPublicInput[], toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig): Promise<string[]>;

// @public (undocumented)
function addSegmentations(segmentationInputArray: SegmentationPublicInput[]): void;

// @public (undocumented)
export function addTool(ToolClass: any): void;

// @public (undocumented)
function addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void;

// @public (undocumented)
interface AngleAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                angle: number;
            };
        };
    };
}

// @public (undocumented)
export class AngleTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => AngleAnnotation;
    // (undocumented)
    angleStartedNotYetCompleted: boolean;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getTextLines(data: any, targetId: any): string[];
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: AngleAnnotation, handle: ToolHandle, interactionType?: string): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: AngleAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType | EventTypes_2.MouseMoveEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: AngleAnnotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
type Annotation = {
    annotationUID?: string;
    highlighted?: boolean;
    isLocked?: boolean;
    isVisible?: boolean;
    invalidated?: boolean;
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        FrameOfReferenceUID: string;
        toolName: string;
        referencedImageId?: string;
        volumeId?: string;
    };
    data: {
        handles?: {
            points?: Types_2.Point3[];
            activeHandleIndex?: number | null;
            textBox?: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
            [key: string]: any;
        };
        [key: string]: any;
        cachedStats?: unknown;
    };
};

declare namespace annotation {
    export {
        config,
        locking,
        selection,
        state,
        visibility
    }
}
export { annotation }

// @public (undocumented)
type AnnotationAddedEventDetail = {
    viewportId: string;
    renderingEngineId: string;
    annotation: Annotation;
};

// @public (undocumented)
type AnnotationAddedEventType = Types_2.CustomEventType<AnnotationAddedEventDetail>;

// @public (undocumented)
type AnnotationCompletedEventDetail = {
    annotation: Annotation;
};

// @public (undocumented)
type AnnotationCompletedEventType = Types_2.CustomEventType<AnnotationCompletedEventDetail>;

// @public (undocumented)
type AnnotationHandle = Types_2.Point3;

// @public (undocumented)
type AnnotationLockChangeEventDetail = {
    added: Array<Annotation>;
    removed: Array<Annotation>;
    locked: Array<Annotation>;
};

// @public (undocumented)
type AnnotationLockChangeEventType = Types_2.CustomEventType<AnnotationLockChangeEventDetail>;

// @public (undocumented)
type AnnotationModifiedEventDetail = {
    viewportId: string;
    renderingEngineId: string;
    annotation: Annotation;
};

// @public (undocumented)
type AnnotationModifiedEventType = Types_2.CustomEventType<AnnotationModifiedEventDetail>;

// @public (undocumented)
type AnnotationRemovedEventDetail = {
    annotation: Annotation;
    annotationManagerUID: string;
};

// @public (undocumented)
type AnnotationRemovedEventType = Types_2.CustomEventType<AnnotationRemovedEventDetail>;

// @public (undocumented)
type AnnotationRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type AnnotationRenderedEventType = Types_2.CustomEventType<AnnotationRenderedEventDetail>;

// @public (undocumented)
type Annotations = Array<Annotation>;

// @public (undocumented)
type AnnotationSelectionChangeEventDetail = {
    added: Array<string>;
    removed: Array<string>;
    selection: Array<string>;
};

// @public (undocumented)
type AnnotationSelectionChangeEventType = Types_2.CustomEventType<AnnotationSelectionChangeEventDetail>;

// @public (undocumented)
type AnnotationState = {
    [key: string]: FrameOfReferenceSpecificAnnotations;
};

declare namespace AnnotationStyle {
    export {
        AnnotationStyle_2 as AnnotationStyle,
        ToolStyleConfig,
        StyleConfig,
        StyleSpecifier
    }
}

// @public (undocumented)
type AnnotationStyle_2 = {
    [key in `${Properties}${States}${Modes}`]?: string;
};

// @public (undocumented)
enum AnnotationStyleStates {
    // (undocumented)
    Default = "",
    // (undocumented)
    Highlighted = "Highlighted",
    // (undocumented)
    Locked = "Locked",
    // (undocumented)
    Selected = "Selected"
}

// @public (undocumented)
export abstract class AnnotationTool extends BaseTool {
    // (undocumented)
    abstract addNewAnnotation(evt: EventTypes_2.MouseDownActivateEventType, interactionType: InteractionTypes): Annotation;
    // (undocumented)
    abstract cancel(element: HTMLDivElement): any;
    // (undocumented)
    filterInteractableAnnotationsForElement(element: HTMLDivElement, annotations: Annotations): Annotations | undefined;
    // (undocumented)
    getHandleNearImagePoint(element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    getLinkedTextBoxStyle(specifications: StyleSpecifier, annotation?: Annotation): Record<string, unknown>;
    // (undocumented)
    protected getReferencedImageId(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, worldPos: Types_2.Point3, viewPlaneNormal: Types_2.Point3, viewUp: Types_2.Point3): string;
    // (undocumented)
    getStyle(property: string, specifications: StyleSpecifier, annotation?: Annotation): unknown;
    // (undocumented)
    abstract handleSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: Annotation, handle: ToolHandle, interactionType: InteractionTypes): void;
    // (undocumented)
    abstract isPointNearTool(element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number, interactionType: string): boolean;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.MouseMoveEventType, filteredAnnotations?: Annotations) => boolean;
    // (undocumented)
    onImageSpacingCalibrated: (evt: Types_2.EventTypes.ImageSpacingCalibratedEvent) => void;
    // (undocumented)
    abstract renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    abstract toolSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: Annotation, interactionType: InteractionTypes): void;
}

// @public (undocumented)
type AnnotationVisibilityChangeEventDetail = {
    lastHidden: Array<string>;
    lastVisible: Array<string>;
    hidden: Array<string>;
};

// @public (undocumented)
type AnnotationVisibilityChangeEventType = Types_2.CustomEventType<AnnotationVisibilityChangeEventDetail>;

// @public (undocumented)
export class ArrowAnnotateTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => ArrowAnnotation;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _doneChangingTextCallback(element: any, annotation: any, updatedText: any): void;
    // (undocumented)
    doubleClickCallback: (evt: EventTypes_2.MouseUpEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: ArrowAnnotation, handle: ToolHandle, interactionType?: string): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume(index1: any, index2: any, dimensions: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: ArrowAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType | EventTypes_2.MouseMoveEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: ArrowAnnotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
interface ArrowAnnotation extends Annotation {
    // (undocumented)
    data: {
        text: string;
        handles: {
            points: Types_2.Point3[];
            arrowFirst: boolean;
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
    };
}

// @public (undocumented)
export abstract class BaseTool implements IBaseTool {
    constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps);
    // (undocumented)
    applyActiveStrategy(enabledElement: Types_2.IEnabledElement, operationData: unknown): any;
    // (undocumented)
    configuration: Record<string, any>;
    // (undocumented)
    protected getTargetId(viewport: Types_2.IViewport): string | undefined;
    // (undocumented)
    protected getTargetIdImage(targetId: string, renderingEngine: Types_2.IRenderingEngine): Types_2.IImageData | Types_2.CPUIImageData | Types_2.IImageVolume;
    // (undocumented)
    getToolName(): string;
    // (undocumented)
    mode: ToolModes;
    // (undocumented)
    setActiveStrategy(strategyName: string): void;
    // (undocumented)
    setConfiguration(newConfiguration: Record<string, any>): void;
    // (undocumented)
    supportedInteractionTypes: InteractionTypes[];
    // (undocumented)
    toolGroupId: string;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
interface BidirectionalAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                length: number;
                width: number;
                unit: string;
            };
        };
    };
}

// @public (undocumented)
export class BidirectionalTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation(evt: EventTypes_2.MouseDownActivateEventType): BidirectionalAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    _calculateLength(pos1: any, pos2: any): number;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getTextLines: (data: any, targetId: any) => string[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: BidirectionalAnnotation, handle: ToolHandle, interactionType?: string) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, index3: any, index4: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: BidirectionalAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragDrawCallback: (evt: MouseMoveEventType | MouseDragEventType) => void;
    // (undocumented)
    _mouseDragModifyCallback: (evt: MouseDragEventType) => void;
    // (undocumented)
    _mouseDragModifyHandle: (evt: any) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    _movingLongAxisWouldPutItThroughShortAxis: (proposedFirstLineSegment: any, secondLineSegment: any) => boolean;
    // (undocumented)
    preventHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: BidirectionalAnnotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace boundingBox {
    export {
        extend2DBoundingBoxInViewAxis,
        getBoundingBoxAroundShape
    }
}

// @public (undocumented)
type BoundsIJK = [Types_2.Point2, Types_2.Point2, Types_2.Point2];

// @public (undocumented)
export class BrushTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.MouseMoveEventType) => void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.MouseDownActivateEventType) => boolean;
    // (undocumented)
    renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): void;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
function calculateAreaOfPoints(points: Types_2.Point2[]): number;

// @public (undocumented)
function calibrateImageSpacing(imageId: string, renderingEngine: Types_2.IRenderingEngine, rowPixelSpacing: number, columnPixelSpacing: number): void;

// @public
type CameraModifiedEvent = CustomEvent_2<CameraModifiedEventDetail>;

// @public
type CameraModifiedEventDetail = {
    previousCamera: ICamera;
    camera: ICamera;
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    rotation?: number;
};

// @public (undocumented)
export function cancelActiveManipulations(element: HTMLDivElement): string | undefined;

// @public (undocumented)
function checkAndDefineIsLockedProperty(annotation: Annotation): void;

// @public (undocumented)
function checkAndDefineIsVisibleProperty(annotation: Annotation): void;

declare namespace cine {
    export {
        playClip,
        stopClip,
        Events_2 as Events,
        getToolState,
        addToolState
    }
}

declare namespace CINETypes {
    export {
        PlayClipOptions,
        ToolData
    }
}

// @public (undocumented)
export class CircleScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentation: any;
        segmentIndex: number;
        segmentationId: string;
        segmentsLocked: number[];
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        centerCanvas?: Array<number>;
    } | null;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.MouseDownActivateEventType) => boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
function clip(a: any, b: any, box: any, da?: any, db?: any): 0 | 1;

// @public (undocumented)
function clip_2(val: number, low: number, high: number): number;

// @public (undocumented)
type Color = [number, number, number, number];

declare namespace color {
    export {
        getColorForSegmentIndex,
        addColorLUT_2 as addColorLUT,
        setColorLUT
    }
}

// @public (undocumented)
type ColorLUT = Array<Color>;

declare namespace config {
    export {
        getState,
        getFont,
        toolStyle as style
    }
}

declare namespace config_2 {
    export {
        color,
        visibility_2 as visibility,
        getGlobalConfig_2 as getGlobalConfig,
        getGlobalRepresentationConfig,
        getToolGroupSpecificConfig_2 as getToolGroupSpecificConfig,
        setGlobalConfig_2 as setGlobalConfig,
        setGlobalRepresentationConfig,
        setToolGroupSpecificConfig_2 as setToolGroupSpecificConfig
    }
}

declare namespace CONSTANTS {
    export {
        CORNERSTONE_COLOR_LUT as COLOR_LUT
    }
}
export { CONSTANTS }

// @public (undocumented)
const CORNERSTONE_COLOR_LUT: number[][];

// @public (undocumented)
interface CPUFallbackColormap {
    // (undocumented)
    addColor: (rgba: Point4) => void;
    // (undocumented)
    buildLookupTable: (lut: CPUFallbackLookupTable) => void;
    // (undocumented)
    clearColors: () => void;
    // (undocumented)
    createLookupTable: () => CPUFallbackLookupTable;
    // (undocumented)
    getColor: (index: number) => Point4;
    // (undocumented)
    getColorRepeating: (index: number) => Point4;
    // (undocumented)
    getColorSchemeName: () => string;
    getId: () => string;
    // (undocumented)
    getNumberOfColors: () => number;
    // (undocumented)
    insertColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    isValidIndex: (index: number) => boolean;
    // (undocumented)
    removeColor: (index: number) => void;
    // (undocumented)
    setColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    setColorSchemeName: (name: string) => void;
    // (undocumented)
    setNumberOfColors: (numColors: number) => void;
}

// @public (undocumented)
type CPUFallbackColormapData = {
    name: string;
    numOfColors?: number;
    colors?: Point4[];
    segmentedData?: unknown;
    numColors?: number;
    gamma?: number;
};

// @public (undocumented)
type CPUFallbackColormapsData = {
    [key: string]: CPUFallbackColormapData;
};

// @public (undocumented)
interface CPUFallbackEnabledElement {
    // (undocumented)
    canvas?: HTMLCanvasElement;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    image?: IImage;
    // (undocumented)
    invalid?: boolean;
    // (undocumented)
    metadata?: {
        direction?: Float32Array;
        dimensions?: Point3;
        spacing?: Point3;
        origin?: Point3;
        imagePlaneModule?: {
            frameOfReferenceUID: string;
            rows: number;
            columns: number;
            imageOrientationPatient: number[];
            rowCosines: Point3;
            columnCosines: Point3;
            imagePositionPatient: number[];
            sliceThickness?: number;
            sliceLocation?: number;
            pixelSpacing: Point2;
            rowPixelSpacing: number;
            columnPixelSpacing: number;
        };
        imagePixelModule?: {
            samplesPerPixel: number;
            photometricInterpretation: string;
            rows: number;
            columns: number;
            bitsAllocated: number;
            bitsStored: number;
            highBit: number;
            pixelRepresentation: number;
            planarConfiguration?: number;
            pixelAspectRatio?: number;
            smallestPixelValue?: number;
            largestPixelValue?: number;
            redPaletteColorLookupTableDescriptor?: number[];
            greenPaletteColorLookupTableDescriptor?: number[];
            bluePaletteColorLookupTableDescriptor?: number[];
            redPaletteColorLookupTableData: number[];
            greenPaletteColorLookupTableData: number[];
            bluePaletteColorLookupTableData: number[];
        };
    };
    // (undocumented)
    needsRedraw?: boolean;
    // (undocumented)
    options?: {
        [key: string]: unknown;
        colormap?: CPUFallbackColormap;
    };
    // (undocumented)
    pan?: Point2;
    // (undocumented)
    renderingTools?: CPUFallbackRenderingTools;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    transform?: CPUFallbackTransform;
    // (undocumented)
    viewport?: CPUFallbackViewport;
    // (undocumented)
    zoom?: number;
}

// @public (undocumented)
interface CPUFallbackLookupTable {
    // (undocumented)
    build: (force: boolean) => void;
    // (undocumented)
    getColor: (scalar: number) => Point4;
    // (undocumented)
    setAlphaRange: (start: number, end: number) => void;
    // (undocumented)
    setHueRange: (start: number, end: number) => void;
    // (undocumented)
    setNumberOfTableValues: (number: number) => void;
    // (undocumented)
    setRamp: (ramp: string) => void;
    // (undocumented)
    setRange: (start: number, end: number) => void;
    // (undocumented)
    setSaturationRange: (start: number, end: number) => void;
    // (undocumented)
    setTableRange: (start: number, end: number) => void;
    // (undocumented)
    setTableValue(index: number, rgba: Point4);
    // (undocumented)
    setValueRange: (start: number, end: number) => void;
}

// @public (undocumented)
type CPUFallbackLUT = {
    lut: number[];
};

// @public (undocumented)
type CPUFallbackRenderingTools = {
    renderCanvas?: HTMLCanvasElement;
    lastRenderedIsColor?: boolean;
    lastRenderedImageId?: string;
    lastRenderedViewport?: {
        windowWidth: number | number[];
        windowCenter: number | number[];
        invert: boolean;
        rotation: number;
        hflip: boolean;
        vflip: boolean;
        modalityLUT: CPUFallbackLUT;
        voiLUT: CPUFallbackLUT;
        colormap: unknown;
    };
    renderCanvasContext?: {
        putImageData: (
        renderCanvasData: unknown,
        dx: number,
        dy: number
        ) => unknown;
    };
    colormapId?: string;
    colorLUT?: CPUFallbackLookupTable;
    renderCanvasData?: {
        data: Uint8ClampedArray;
    };
};

// @public (undocumented)
interface CPUFallbackTransform {
    // (undocumented)
    clone: () => CPUFallbackTransform;
    // (undocumented)
    getMatrix: () => TransformMatrix2D;
    // (undocumented)
    invert: () => void;
    // (undocumented)
    multiply: (matrix: TransformMatrix2D) => void;
    // (undocumented)
    reset: () => void;
    // (undocumented)
    rotate: (rad: number) => void;
    // (undocumented)
    scale: (sx: number, sy: number) => void;
    // (undocumented)
    transformPoint: (point: Point2) => Point2;
    // (undocumented)
    translate: (x: number, y: number) => void;
}

// @public (undocumented)
type CPUFallbackViewport = {
    scale?: number;
    parallelScale?: number;
    focalPoint?: number[];
    translation?: {
        x: number;
        y: number;
    };
    voi?: {
        windowWidth: number;
        windowCenter: number;
    };
    invert?: boolean;
    pixelReplication?: boolean;
    rotation?: number;
    hflip?: boolean;
    vflip?: boolean;
    modalityLUT?: CPUFallbackLUT;
    voiLUT?: CPUFallbackLUT;
    colormap?: CPUFallbackColormap;
    displayedArea?: CPUFallbackViewportDisplayedArea;
    modality?: string;
};

// @public (undocumented)
type CPUFallbackViewportDisplayedArea = {
    tlhc: {
        x: number;
        y: number;
    };
    brhc: {
        x: number;
        y: number;
    };
    rowPixelSpacing: number;
    columnPixelSpacing: number;
    presentationSizeMode: string;
};

// @public (undocumented)
type CPUIImageData = {
    dimensions: Point3;
    direction: Float32Array;
    spacing: Point3;
    origin: Point3;
    imageData: CPUImageData;
    metadata: { Modality: string };
    scalarData: number[];
    scaling: Scaling;
    hasPixelSpacing?: boolean;
};

// @public (undocumented)
type CPUImageData = {
    worldToIndex?: (point: Point3) => Point3;
    indexToWorld?: (point: Point3) => Point3;
    getWorldToIndex?: () => Point3;
    getIndexToWorld?: () => Point3;
    getSpacing?: () => Point3;
    getDirection?: () => Float32Array;
    getScalarData?: () => number[];
    getDimensions?: () => Point3;
};

// @public (undocumented)
function createCameraPositionSynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
function createLabelmapVolumeForViewport(input: {
    viewportId: string;
    renderingEngineId: string;
    segmentationId?: string;
    options?: {
        volumeId?: string;
        scalarData?: Float32Array | Uint8Array;
        targetBuffer?: {
            type: 'Float32Array' | 'Uint8Array';
        };
        metadata?: any;
        dimensions?: Types_2.Point3;
        spacing?: Types_2.Point3;
        origin?: Types_2.Point3;
        direction?: Float32Array;
    };
}): Promise<string>;

// @public (undocumented)
function createMergedLabelmapForIndex(labelmaps: Array<Types_2.IImageVolume>, segmentIndex?: number, volumeId?: string): Types_2.IImageVolume;

// @public (undocumented)
function createSynchronizer(synchronizerId: string, eventName: string, eventHandler: ISynchronizerEventHandler): Synchronizer;

// @public (undocumented)
function createToolGroup(toolGroupId: string): IToolGroup | undefined;

// @public (undocumented)
function createVOISynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
export class CrosshairsTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType, interactionType: string) => CrosshairsAnnotation;
    // (undocumented)
    _applyDeltaShiftToSelectedViewportCameras(renderingEngine: any, viewportsAnnotationsToUpdate: any, delta: any): void;
    // (undocumented)
    _applyDeltaShiftToViewportCamera(renderingEngine: Types_2.IRenderingEngine, annotation: any, delta: any): void;
    // (undocumented)
    _areViewportIdArraysEqual: (viewportIdArrayOne: any, viewportIdArrayTwo: any) => boolean;
    // (undocumented)
    _autoPanViewportIfNecessary(viewportId: string, renderingEngine: Types_2.IRenderingEngine): void;
    // (undocumented)
    cancel: () => void;
    // (undocumented)
    _checkIfViewportsRenderingSameScene: (viewport: any, otherViewport: any) => boolean;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
    } | null;
    // (undocumented)
    _filterAnnotationsByUniqueViewportOrientations: (enabledElement: any, annotations: any) => any[];
    // (undocumented)
    filterInteractableAnnotationsForElement: (element: any, annotations: any) => any;
    // (undocumented)
    _filterViewportWithSameOrientation: (enabledElement: any, referenceAnnotation: any, annotations: any) => any;
    // (undocumented)
    _getAnnotationsForViewportsWithDifferentCameras: (enabledElement: any, annotations: any) => any;
    // (undocumented)
    getHandleNearImagePoint(element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    _getReferenceLineColor?: (viewportId: string) => string;
    // (undocumented)
    _getReferenceLineControllable?: (viewportId: string) => boolean;
    // (undocumented)
    _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;
    // (undocumented)
    _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;
    // (undocumented)
    _getRotationHandleNearImagePoint(viewport: any, annotation: any, canvasCoords: any, proximity: any): any;
    // (undocumented)
    _getSlabThicknessHandleNearImagePoint(viewport: any, annotation: any, canvasCoords: any, proximity: any): any;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: Annotation, handle: ToolHandle, interactionType?: string) => void;
    // (undocumented)
    init: () => void;
    // (undocumented)
    initializeViewport: ({ renderingEngineId, viewportId, }: Types_2.IViewportId) => {
        normal: Types_2.Point3;
        point: Types_2.Point3;
    };
    // (undocumented)
    _isClockWise(a: any, b: any, c: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: CrosshairsAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    _jump: (enabledElement: any, jumpWorld: any) => boolean;
    // (undocumented)
    _mouseDragCallback: (evt: MouseDragEventType) => void;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.MouseMoveEventType, filteredToolAnnotations: Annotations) => boolean;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    onCameraModified: (evt: any) => void;
    // (undocumented)
    onSetToolActive(): void;
    // (undocumented)
    onSetToolEnabled(): void;
    // (undocumented)
    onSetToolPassive(): void;
    // (undocumented)
    _pointNearReferenceLine: (annotation: any, canvasCoords: any, proximity: any, lineViewport: any) => boolean;
    // (undocumented)
    _pointNearTool(element: any, annotation: any, canvasCoords: any, proximity: any): boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    setSlabThickness(viewport: any, slabThickness: any): void;
    // (undocumented)
    toolCenter: Types_2.Point3;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: Annotation, interactionType: InteractionTypes) => void;
}

// @public (undocumented)
const CursorNames: string[];

declare namespace cursors {
    export {
        MouseCursor,
        ImageMouseCursor,
        SVGMouseCursor,
        elementCursor,
        registerCursor,
        CursorNames,
        setCursorForElement
    }
}
export { cursors }

// @public (undocumented)
interface CustomEvent_2<T = any> extends Event {
    readonly detail: T;
    // (undocumented)
    initCustomEvent(
    typeArg: string,
    canBubbleArg: boolean,
    cancelableArg: boolean,
    detailArg: T
    ): void;
}

// @public (undocumented)
function debounce(func: Function, wait?: number, options?: {
    leading?: boolean;
    maxWait?: number;
    trailing?: boolean;
}): Function;

// @public (undocumented)
function deepmerge(target?: {}, source?: {}, optionsArgument?: any): any;

// @public (undocumented)
const _default: {
    filterAnnotationsWithinSlice: typeof filterAnnotationsWithinSlice;
    getWorldWidthAndHeightFromCorners: typeof getWorldWidthAndHeightFromCorners;
    filterAnnotationsForDisplay: typeof filterAnnotationsForDisplay;
    getPointInLineOfSightWithCriteria: typeof getPointInLineOfSightWithCriteria;
};

// @public (undocumented)
function deselectAnnotation(annotationUID?: string): void;

// @public (undocumented)
export function destroy(): void;

// @public (undocumented)
function destroy_2(): void;

// @public (undocumented)
function destroy_3(): void;

// @public (undocumented)
function destroySynchronizer(synchronizerId: string): void;

// @public (undocumented)
function destroyToolGroup(toolGroupId: string): void;

// @public (undocumented)
function disable(element: any): void;

// @public (undocumented)
function distanceToPoint(lineStart: Types_2.Point2, lineEnd: Types_2.Point2, point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPoint_2(rect: number[], point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPoint_3(p1: Types_2.Point2, p2: Types_2.Point2): number;

// @public (undocumented)
function distanceToPointSquared(lineStart: Types_2.Point2, lineEnd: Types_2.Point2, point: Types_2.Point2): number;

// @public (undocumented)
export class DragProbeTool extends ProbeTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        newAnnotation?: boolean;
    } | null;
    // (undocumented)
    eventDispatchDetail: {
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    postMouseDownCallback: (evt: EventTypes_2.MouseDownActivateEventType) => ProbeAnnotation;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function draw(element: HTMLDivElement, fn: (svgDrawingElement: any) => any): void;

// @public (undocumented)
function drawArrow(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, arrowUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}): void;

// @public (undocumented)
function drawCircle(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, circleUID: string, center: Types_2.Point2, radius: number, options?: {}): void;

// @public (undocumented)
function drawEllipse(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, ellipseUID: string, corner1: Types_2.Point2, corner2: Types_2.Point2, options?: {}): void;

// @public (undocumented)
function drawHandles(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, handleGroupUID: string, handlePoints: Array<Types_2.Point2>, options?: {}): void;

declare namespace drawing {
    export {
        draw,
        drawCircle,
        drawEllipse,
        drawHandles,
        drawLine,
        drawPolyline,
        drawLinkedTextBox,
        drawRect,
        drawTextBox,
        drawArrow
    }
}
export { drawing }

declare namespace drawing_2 {
    export {
        getTextBoxCoordsCanvas
    }
}

// @public (undocumented)
function drawLine(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, lineUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}): void;

// @public (undocumented)
function drawLinkedTextBox(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, textBoxUID: string, textLines: Array<string>, textBoxPosition: Types_2.Point2, annotationAnchorPoints: Array<Types_2.Point2>, textBox: unknown, options?: {}): SVGRect;

// @public (undocumented)
function drawPolyline(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, polylineUID: string, points: Types_2.Point2[], options: {
    color?: string;
    width?: number;
    lineWidth?: number;
    lineDash?: string;
    connectLastToFirst?: boolean;
}): void;

// @public (undocumented)
function drawRect(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, rectangleUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}): void;

// @public (undocumented)
function drawTextBox(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, textUID: string, textLines: Array<string>, position: Types_2.Point2, options?: {}): SVGRect;

declare namespace elementCursor {
    export {
        initElementCursor,
        resetElementCursor,
        hideElementCursor,
        _setElementCursor as setElementCursor
    }
}

// @public
type ElementDisabledEvent = CustomEvent_2<ElementDisabledEventDetail>;

// @public
type ElementDisabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public
type ElementEnabledEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public
type ElementEnabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

declare namespace ellipse {
    export {
        pointInEllipse,
        getCanvasEllipseCorners
    }
}

// @public (undocumented)
interface EllipticalROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: [Types_2.Point3, Types_2.Point3, Types_2.Point3, Types_2.Point3];
            activeHandleIndex: number | null;
            textBox?: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats?: ROICachedStats;
    };
}

// @public (undocumented)
export class EllipticalROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => EllipticalROIAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewport: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragHandle: (evt: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        movingTextBox?: boolean;
        centerCanvas?: Array<number>;
        canvasWidth?: number;
        canvasHeight?: number;
        originalHandleCanvas?: Array<number>;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getTextLines: (data: any, targetId: any) => any[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: EllipticalROIAnnotation, handle: ToolHandle, interactionType?: string) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: EllipticalROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragDrawCallback: (evt: MouseMoveEventType | MouseDragEventType) => void;
    // (undocumented)
    _mouseDragModifyCallback: (evt: MouseDragEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    _pointInEllipseCanvas(ellipse: any, location: Types_2.Point2): boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: EllipticalROIAnnotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function enable(element: any): void;

declare namespace Enums {
    export {
        MouseBindings,
        KeyboardBindings,
        ToolModes,
        AnnotationStyleStates,
        Events,
        SegmentationRepresentations
    }
}
export { Enums }

// @public (undocumented)
enum Events {
    // (undocumented)
    ANNOTATION_ADDED = "CORNERSTONE_TOOLS_ANNOTATION_ADDED",
    // (undocumented)
    ANNOTATION_COMPLETED = "CORNERSTONE_TOOLS_ANNOTATION_COMPLETED",
    // (undocumented)
    ANNOTATION_LOCK_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE",
    // (undocumented)
    ANNOTATION_MODIFIED = "CORNERSTONE_TOOLS_ANNOTATION_MODIFIED",
    // (undocumented)
    ANNOTATION_REMOVED = "CORNERSTONE_TOOLS_ANNOTATION_REMOVED",
    // (undocumented)
    ANNOTATION_RENDERED = "CORNERSTONE_TOOLS_ANNOTATION_RENDERED",
    // (undocumented)
    ANNOTATION_SELECTION_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE",
    // (undocumented)
    ANNOTATION_VISIBILITY_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE",
    // (undocumented)
    KEY_DOWN = "CORNERSTONE_TOOLS_KEY_DOWN",
    // (undocumented)
    KEY_UP = "CORNERSTONE_TOOLS_KEY_UP",
    // (undocumented)
    MOUSE_CLICK = "CORNERSTONE_TOOLS_MOUSE_CLICK",
    // (undocumented)
    MOUSE_DOUBLE_CLICK = "CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK",
    // (undocumented)
    MOUSE_DOWN = "CORNERSTONE_TOOLS_MOUSE_DOWN",
    // (undocumented)
    MOUSE_DOWN_ACTIVATE = "CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE",
    // (undocumented)
    MOUSE_DRAG = "CORNERSTONE_TOOLS_MOUSE_DRAG",
    // (undocumented)
    MOUSE_MOVE = "CORNERSTONE_TOOLS_MOUSE_MOVE",
    // (undocumented)
    MOUSE_UP = "CORNERSTONE_TOOLS_MOUSE_UP",
    // (undocumented)
    MOUSE_WHEEL = "CORNERSTONE_TOOLS_MOUSE_WHEEL",
    // (undocumented)
    SEGMENTATION_DATA_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED",
    // (undocumented)
    SEGMENTATION_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED",
    // (undocumented)
    SEGMENTATION_REMOVED = "CORNERSTONE_TOOLS_SEGMENTATION_REMOVED",
    // (undocumented)
    SEGMENTATION_RENDERED = "CORNERSTONE_TOOLS_SEGMENTATION_RENDERED",
    // (undocumented)
    SEGMENTATION_REPRESENTATION_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED",
    // (undocumented)
    SEGMENTATION_REPRESENTATION_REMOVED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED"
}

// @public (undocumented)
enum Events_2 {
    // (undocumented)
    CLIP_STARTED = "CORNERSTONE_CINE_TOOL_STARTED",
    // (undocumented)
    CLIP_STOPPED = "CORNERSTONE_CINE_TOOL_STOPPED"
}

declare namespace EventTypes {
    export {
        CameraModifiedEventDetail,
        CameraModifiedEvent,
        VoiModifiedEvent,
        VoiModifiedEventDetail,
        ElementDisabledEvent,
        ElementDisabledEventDetail,
        ElementEnabledEvent,
        ElementEnabledEventDetail,
        ImageRenderedEventDetail,
        ImageRenderedEvent,
        ImageVolumeModifiedEvent,
        ImageVolumeModifiedEventDetail,
        ImageLoadedEvent,
        ImageLoadedEventDetail,
        ImageLoadedFailedEventDetail,
        ImageLoadedFailedEvent,
        VolumeLoadedEvent,
        VolumeLoadedEventDetail,
        VolumeLoadedFailedEvent,
        VolumeLoadedFailedEventDetail,
        ImageCacheImageAddedEvent,
        ImageCacheImageAddedEventDetail,
        ImageCacheImageRemovedEvent,
        ImageCacheImageRemovedEventDetail,
        VolumeCacheVolumeAddedEvent,
        VolumeCacheVolumeAddedEventDetail,
        VolumeCacheVolumeRemovedEvent,
        VolumeCacheVolumeRemovedEventDetail,
        StackNewImageEvent,
        StackNewImageEventDetail,
        PreStackNewImageEvent,
        PreStackNewImageEventDetail,
        ImageSpacingCalibratedEvent,
        ImageSpacingCalibratedEventDetail,
        ImageLoadProgressEvent,
        ImageLoadProgressEventDetail,
        VolumeNewImageEvent,
        VolumeNewImageEventDetail,
        StackViewportNewStackEvent,
        StackViewportNewStackEventDetail,
        StackViewportScrollEvent,
        StackViewportScrollEventDetail
    }
}

declare namespace EventTypes_2 {
    export {
        NormalizedMouseEventDetail,
        NormalizedMouseEventType,
        AnnotationAddedEventDetail,
        AnnotationAddedEventType,
        AnnotationCompletedEventDetail,
        AnnotationCompletedEventType,
        AnnotationModifiedEventDetail,
        AnnotationModifiedEventType,
        AnnotationRemovedEventDetail,
        AnnotationRemovedEventType,
        AnnotationSelectionChangeEventDetail,
        AnnotationSelectionChangeEventType,
        AnnotationRenderedEventDetail,
        AnnotationRenderedEventType,
        AnnotationLockChangeEventDetail,
        AnnotationVisibilityChangeEventDetail,
        AnnotationLockChangeEventType,
        AnnotationVisibilityChangeEventType,
        SegmentationDataModifiedEventType,
        SegmentationRepresentationModifiedEventDetail,
        SegmentationRepresentationModifiedEventType,
        SegmentationRepresentationRemovedEventDetail,
        SegmentationRepresentationRemovedEventType,
        SegmentationRemovedEventType,
        SegmentationRemovedEventDetail,
        SegmentationDataModifiedEventDetail,
        SegmentationRenderedEventType,
        SegmentationRenderedEventDetail,
        SegmentationModifiedEventType,
        SegmentationModifiedEventDetail,
        KeyDownEventDetail,
        KeyDownEventType,
        KeyUpEventDetail,
        KeyUpEventType,
        MouseDownEventDetail,
        MouseDownEventType,
        MouseDownActivateEventDetail,
        MouseDownActivateEventType,
        MouseDragEventDetail,
        MouseDragEventType,
        MouseUpEventDetail,
        MouseUpEventType,
        MouseClickEventDetail,
        MouseClickEventType,
        MouseMoveEventDetail,
        MouseMoveEventType,
        MouseDoubleClickEventDetail,
        MouseDoubleClickEventType,
        MouseWheelEventDetail,
        MouseWheelEventType
    }
}

// @public (undocumented)
function extend2DBoundingBoxInViewAxis(boundsIJK: [Types_2.Point2, Types_2.Point2, Types_2.Point2], numSlicesToProject: number): [Types_2.Point2, Types_2.Point2, Types_2.Point2];

// @public (undocumented)
function filterAnnotationsForDisplay(viewport: Types_2.IViewport, annotations: Annotations): Annotations;

// @public (undocumented)
function filterAnnotationsWithinSlice(annotations: Annotations, camera: Types_2.ICamera, spacingInNormalDirection: number): Annotations;

// @public (undocumented)
function filterViewportsWithFrameOfReferenceUID(viewports: Array<Types_2.IStackViewport | Types_2.IVolumeViewport>, FrameOfReferenceUID: string): Array<Types_2.IStackViewport | Types_2.IVolumeViewport>;

// @public (undocumented)
function filterViewportsWithToolEnabled(viewports: Array<Types_2.IStackViewport | Types_2.IVolumeViewport>, toolName: string): Array<Types_2.IStackViewport | Types_2.IVolumeViewport>;

// @public (undocumented)
function findClosestPoint(sourcePoints: Array<Types_2.Point2>, targetPoint: Types_2.Point2): Types_2.Point2;

// @public
type FlipDirection = {
    flipHorizontal?: boolean;
    flipVertical?: boolean;
};

// @public (undocumented)
type FrameOfReferenceSpecificAnnotations = {
    [key: string]: Annotations;
};

// @public (undocumented)
function getActiveSegmentationRepresentation(toolGroupId: string): ToolGroupSpecificRepresentation;

// @public (undocumented)
function getActiveSegmentIndex(segmentationId: string): number | undefined;

// @public (undocumented)
function getAllSynchronizers(): Array<Synchronizer>;

// @public (undocumented)
function getAllToolGroups(): Array<IToolGroup>;

// @public (undocumented)
function getAnnotation(annotationUID: string, element?: HTMLDivElement): Annotation;

// @public (undocumented)
function getAnnotationNearPoint(element: HTMLDivElement, canvasPoint: Types_2.Point2, proximity?: number): Annotation | null;

// @public (undocumented)
function getAnnotationNearPointOnEnabledElement(enabledElement: Types_2.IEnabledElement, point: Types_2.Point2, proximity: number): Annotation | null;

// @public (undocumented)
function getAnnotations(element: HTMLDivElement, toolName: string): Annotations;

// @public (undocumented)
function getAnnotationsLocked(): Array<Annotation>;

// @public (undocumented)
function getAnnotationsLockedCount(): number;

// @public (undocumented)
function getAnnotationsSelected(): Array<string>;

// @public (undocumented)
function getAnnotationsSelectedByToolName(toolName: string): Array<string>;

// @public (undocumented)
function getAnnotationsSelectedCount(): number;

// @public (undocumented)
function getBoundingBoxAroundShape(points: Types_2.Point3[], dimensions?: Types_2.Point3): [Types_2.Point2, Types_2.Point2, Types_2.Point2];

// @public (undocumented)
function getBoundsIJKFromRectangleAnnotations(annotations: any, referenceVolume: any, options?: Options): any;

// @public (undocumented)
function getCanvasEllipseCorners(ellipseCanvasPoints: canvasCoordinates): Array<Types_2.Point2>;

// @public (undocumented)
function getClosestIntersectionWithPolyline(points: Types_2.Point2[], p1: Types_2.Point2, q1: Types_2.Point2, closed?: boolean): {
    segment: Types_2.Point2;
    distance: number;
} | undefined;

// @public (undocumented)
function getColorForSegmentIndex(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number): Color;

// @public (undocumented)
function getColorLUT(index: number): ColorLUT | undefined;

// @public (undocumented)
function getConfiguration(): {
    maxImagesToPrefetch: number;
    preserveExistingPool: boolean;
};

// @public (undocumented)
function getDefaultAnnotationManager(): FrameOfReferenceSpecificAnnotationManager;

// @public (undocumented)
function getDefaultRepresentationConfig(segmentation: Segmentation): LabelmapConfig;

// @public (undocumented)
function getDefaultSegmentationStateManager(): SegmentationStateManager;

// @public (undocumented)
function getFirstIntersectionWithPolyline(points: Types_2.Point2[], p1: Types_2.Point2, q1: Types_2.Point2, closed?: boolean): Types_2.Point2 | undefined;

// @public (undocumented)
function getFont(styleSpecifier: StyleSpecifier, state?: AnnotationStyleStates, mode?: ToolModes): string;

// @public (undocumented)
function getGlobalConfig(): SegmentationRepresentationConfig;

// @public (undocumented)
function getGlobalConfig_2(): SegmentationRepresentationConfig;

// @public (undocumented)
function getGlobalRepresentationConfig(representationType: SegmentationRepresentations): RepresentationConfig['LABELMAP'];

// @public (undocumented)
function getLockedSegments(segmentationId: string): number[] | [];

// @public (undocumented)
function getOrientationStringLPS(vector: Types_2.Point3): string;

// @public (undocumented)
function getPointInLineOfSightWithCriteria(viewport: Types_2.IVolumeViewport, worldPos: Types_2.Point3, targetVolumeId: string, criteriaFunction: (intensity: number, point: Types_2.Point3) => Types_2.Point3, stepSize?: number): Types_2.Point3;

// @public (undocumented)
function getSegmentation(segmentationId: string): Segmentation | undefined;

// @public (undocumented)
function getSegmentationRepresentationByUID(toolGroupId: string, segmentationRepresentationUID: string): ToolGroupSpecificRepresentation | undefined;

// @public (undocumented)
function getSegmentationRepresentations(toolGroupId: string): ToolGroupSpecificRepresentations | [];

// @public (undocumented)
function getSegmentations(): Segmentation[] | [];

// @public (undocumented)
function getSegmentationVisibility(toolGroupId: string, segmentationRepresentationUID: string): boolean | undefined;

// @public (undocumented)
function getState(annotation?: Annotation): AnnotationStyleStates;

// @public (undocumented)
const getSubPixelSpacingAndXYDirections: (viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, subPixelResolution: number) => {
    spacing: Types_2.Point2;
    xDir: Types_2.Point3;
    yDir: Types_2.Point3;
};

// @public (undocumented)
function getSynchronizer(synchronizerId: string): Synchronizer | void;

// @public (undocumented)
function getSynchronizersForViewport(viewportId: string, renderingEngineId: string): Array<Synchronizer>;

// @public (undocumented)
function getTextBoxCoordsCanvas(annotationCanvasPoints: Array<Types_2.Point2>): Types_2.Point2;

// @public (undocumented)
function getToolGroup(toolGroupId: string): IToolGroup | undefined;

// @public (undocumented)
function getToolGroupForViewport(viewportId: string, renderingEngineId: string): IToolGroup | undefined;

// @public (undocumented)
function getToolGroupSpecificConfig(toolGroupId: string): SegmentationRepresentationConfig;

// @public (undocumented)
function getToolGroupSpecificConfig_2(toolGroupId: string): SegmentationRepresentationConfig;

// @public (undocumented)
function getToolGroupsWithSegmentation(segmentationId: string): string[];

// @public (undocumented)
function getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined;

// @public (undocumented)
function getViewportIdsWithToolToRender(element: HTMLDivElement, toolName: string, requireSameOrientation?: boolean): string[];

// @public (undocumented)
function getViewportSpecificAnnotationManager(element?: Types_2.IEnabledElement | HTMLDivElement): FrameOfReferenceSpecificAnnotationManager;

// @public (undocumented)
function getWorldWidthAndHeightFromCorners(viewPlaneNormal: Types_2.Point3, viewUp: Types_2.Point3, topLeftWorld: Types_2.Point3, bottomRightWorld: Types_2.Point3): {
    worldWidth: number;
    worldHeight: number;
};

// @public (undocumented)
function hideElementCursor(element: HTMLDivElement): void;

// @public (undocumented)
interface ICache {
    getCacheSize: () => number;
    getImageLoadObject: (imageId: string) => IImageLoadObject | void;
    getMaxCacheSize: () => number;
    getVolumeLoadObject: (volumeId: string) => IVolumeLoadObject | void;
    purgeCache: () => void;
    putImageLoadObject: (
    imageId: string,
    imageLoadObject: IImageLoadObject
    ) => Promise<any>;
    putVolumeLoadObject: (
    volumeId: string,
    volumeLoadObject: IVolumeLoadObject
    ) => Promise<any>;
    setMaxCacheSize: (maxCacheSize: number) => void;
}

// @public (undocumented)
interface ICachedImage {
    // (undocumented)
    image?: IImage;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageLoadObject: IImageLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedVolume {
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
    // (undocumented)
    volume?: IImageVolume;
    // (undocumented)
    volumeId: string;
    // (undocumented)
    volumeLoadObject: IVolumeLoadObject;
}

// @public
interface ICamera {
    flipHorizontal?: boolean;
    flipVertical?: boolean;
    focalPoint?: Point3;
    parallelProjection?: boolean;
    parallelScale?: number;
    position?: Point3;
    scale?: number;
    viewAngle?: number;
    viewPlaneNormal?: Point3;
    viewUp?: Point3;
}

// @public
interface IEnabledElement {
    FrameOfReferenceUID: string;
    renderingEngine: IRenderingEngine;
    renderingEngineId: string;
    viewport: IStackViewport | IVolumeViewport;
    viewportId: string;
}

// @public
interface IImage {
    cachedLut?: {
        windowWidth?: number | number[];
        windowCenter?: number | number[];
        invert?: boolean;
        lutArray?: Uint8ClampedArray;
        modalityLUT?: unknown;
        voiLUT?: CPUFallbackLUT;
    };
    color: boolean;
    colormap?: CPUFallbackColormap;
    columnPixelSpacing: number;
    columns: number;
    // (undocumented)
    getCanvas: () => HTMLCanvasElement;
    getPixelData: () => Array<number>;
    height: number;
    imageId: string;
    intercept: number;
    invert: boolean;
    isPreScaled?: boolean;
    // (undocumented)
    maxPixelValue: number;
    minPixelValue: number;
    modalityLUT?: CPUFallbackLUT;
    numComps: number;
    render?: (
    enabledElement: CPUFallbackEnabledElement,
    invalidated: boolean
    ) => unknown;
    rgba: boolean;
    rowPixelSpacing: number;
    rows: number;
    scaling?: {
        PET?: {
            // @TODO: Do these values exist?
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            // accessed in ProbeTool
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sharedCacheKey?: string;
    sizeInBytes: number;
    sliceThickness?: number;
    slope: number;
    stats?: {
        lastStoredPixelDataToCanvasImageDataTime?: number;
        lastGetPixelDataTime?: number;
        lastPutImageDataTime?: number;
        lastLutGenerateTime?: number;
        lastRenderedViewport?: unknown;
        lastRenderTime?: number;
    };
    voiLUT?: CPUFallbackLUT;
    width: number;
    windowCenter: number[] | number;
    windowWidth: number[] | number;
}

// @public
interface IImageData {
    dimensions: Point3;
    direction: Float32Array;
    hasPixelSpacing?: boolean;
    imageData: vtkImageData;
    metadata: { Modality: string };
    origin: Point3;
    scalarData: Float32Array;
    scaling?: Scaling;
    spacing: Point3;
}

// @public
interface IImageLoadObject {
    cancel?: () => void;
    decache?: () => void;
    promise: Promise<IImage>;
}

// @public
interface IImageVolume {
    convertToCornerstoneImage?: (
    imageId: string,
    imageIdIndex: number
    ) => IImageLoadObject;
    dimensions: Point3;
    direction: Float32Array;
    hasPixelSpacing: boolean;
    imageData?: vtkImageData;
    imageIds?: Array<string>;
    isPrescaled: boolean;
    loadStatus?: Record<string, any>;
    metadata: Metadata;
    numVoxels: number;
    origin: Point3;
    referencedVolumeId?: string;
    scalarData: any;
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    sizeInBytes?: number;
    spacing: Point3;
    readonly volumeId: string;
    vtkOpenGLTexture: any;
}

// @public
type ImageCacheImageAddedEvent =
CustomEvent_2<ImageCacheImageAddedEventDetail>;

// @public
type ImageCacheImageAddedEventDetail = {
    image: ICachedImage;
};

// @public
type ImageCacheImageRemovedEvent =
CustomEvent_2<ImageCacheImageRemovedEventDetail>;

// @public
type ImageCacheImageRemovedEventDetail = {
    imageId: string;
};

// @public
type ImageLoadedEvent = CustomEvent_2<ImageLoadedEventDetail>;

// @public
type ImageLoadedEventDetail = {
    image: IImage;
};

// @public
type ImageLoadedFailedEvent = CustomEvent_2<ImageLoadedFailedEventDetail>;

// @public
type ImageLoadedFailedEventDetail = {
    imageId: string;
    error: unknown;
};

// @public
type ImageLoaderFn = (
imageId: string,
options?: Record<string, any>
) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public
type ImageLoadProgressEvent = CustomEvent_2<ImageLoadProgressEventDetail>;

// @public
type ImageLoadProgressEventDetail = {
    url: string;
    imageId: string;
    loaded: number;
    total: number;
    percent: number;
};

// @public (undocumented)
class ImageMouseCursor extends MouseCursor {
    constructor(url: string, x?: number, y?: number, name?: string | undefined, fallback?: MouseCursor | undefined);
    // (undocumented)
    getStyleProperty(): string;
    // (undocumented)
    static getUniqueInstanceName(prefix: string): string;
}

// @public
type ImageRenderedEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public
type ImageRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    suppressEvents?: boolean;
};

// @public (undocumented)
type ImageSliceData = {
    numberOfSlices: number;
    imageIndex: number;
};

// @public
type ImageSpacingCalibratedEvent =
CustomEvent_2<ImageSpacingCalibratedEventDetail>;

// @public
type ImageSpacingCalibratedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    imageId: string;
    rowScale: number;
    columnScale: number;
    imageData: vtkImageData;
    worldToIndex: mat4;
};

// @public
type ImageVolumeModifiedEvent = CustomEvent_2<ImageVolumeModifiedEventDetail>;

// @public
type ImageVolumeModifiedEventDetail = {
    imageVolume: IImageVolume;
    FrameOfReferenceUID: string;
};

// @public (undocumented)
export function init(defaultConfiguration?: {}): void;

// @public (undocumented)
function initElementCursor(element: HTMLDivElement, cursor: MouseCursor | null): void;

// @public (undocumented)
type InteractionTypes = 'Mouse';

// @public (undocumented)
function intersectLine(line1Start: Types_2.Point2, line1End: Types_2.Point2, line2Start: Types_2.Point2, line2End: Types_2.Point2): number[];

// @public (undocumented)
function invertOrientationStringLPS(orientationString: string): string;

// @public (undocumented)
type IPoints = {
    page: Types_2.Point2;
    client: Types_2.Point2;
    canvas: Types_2.Point2;
    world: Types_2.Point3;
};

// @public
interface IRegisterImageLoader {
    // (undocumented)
    registerImageLoader: (scheme: string, imageLoader: ImageLoaderFn) => void;
}

// @public (undocumented)
interface IRenderingEngine {
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(
    canvas: HTMLCanvasElement,
    backgroundColor: [number, number, number]
    ): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getViewport(id: string): IStackViewport | IVolumeViewport;
    // (undocumented)
    getViewports(): Array<IStackViewport | IVolumeViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference(FrameOfReferenceUID: string): void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, resetPan?: boolean, resetZoom?: boolean): void;
    // (undocumented)
    setViewports(viewports: Array<PublicViewportInput>): void;
}

// @public (undocumented)
function isAnnotationLocked(annotation: Annotation): boolean;

// @public (undocumented)
function isAnnotationSelected(annotationUID: string): boolean;

// @public (undocumented)
function isAnnotationVisible(annotationUID: string): boolean | undefined;

// @public (undocumented)
function isObject(value: any): boolean;

// @public (undocumented)
function isSegmentIndexLocked(segmentationId: string, segmentIndex: number): boolean;

// @public
interface IStackViewport extends IViewport {
    calibrateSpacing(imageId: string): void;
    canvasToWorld: (canvasPos: Point2) => Point3;
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
    };
    getCamera(): ICamera;
    getCurrentImageId: () => string;
    getCurrentImageIdIndex: () => number;
    getFrameOfReferenceUID: () => string;
    getImageData(): IImageData | CPUIImageData;
    getImageIds: () => string[];
    getProperties: () => StackViewportProperties;
    getRenderer(): any;
    hasImageId: (imageId: string) => boolean;
    hasImageURI: (imageURI: string) => boolean;
    isImagePreScaled(imageId: string): boolean;
    // (undocumented)
    modality: string;
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    resetProperties(): void;
    resize: () => void;
    scaling: Scaling;
    setCamera(cameraInterface: ICamera): void;
    setColormap(colormap: CPUFallbackColormapData): void;
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    setProperties(
        { voiRange, invert, interpolationType, rotation }: StackViewportProperties,
    suppressEvents?: boolean
    ): void;
    setStack(
    imageIds: Array<string>,
    currentImageIdIndex?: number
    ): Promise<string>;
    unsetColormap(): void;
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public
interface IStreamingImageVolume extends ImageVolume {
    clearLoadCallbacks(): void;
    convertToCornerstoneImage(imageId: string, imageIdIndex: number): any;
    decache(completelyRemove: boolean): void;
}

// @public (undocumented)
interface IStreamingVolumeProperties {
    imageIds: Array<string>;
    loadStatus: {
        loaded: boolean;
        loading: boolean;
        cachedFrames: Array<boolean>;
        callbacks: Array<() => void>;
    };
}

// @public (undocumented)
function isValidRepresentationConfig(representationType: string, config: RepresentationConfig): boolean;

// @public (undocumented)
type IToolBinding = {
    mouseButton: ToolBindingMouseType;
    modifierKey?: ToolBindingKeyboardType;
};

// @public (undocumented)
interface IToolGroup {
    // (undocumented)
    addTool: {
        (toolName: string, toolConfiguration?: any): void;
    };
    // (undocumented)
    addViewport: {
        (viewportId: string, renderingEngineId?: string): void;
    };
    // (undocumented)
    getActivePrimaryMouseButtonTool: {
        (): undefined | string;
    };
    // (undocumented)
    getToolConfiguration: {
        (toolName: string, configurationPath: string): any;
    };
    // (undocumented)
    getToolInstance: {
        (toolName: string): any;
    };
    // (undocumented)
    getToolOptions: {
        (toolName: string): ToolOptionsType;
    };
    // (undocumented)
    getViewportIds: () => string[];
    // (undocumented)
    getViewportsInfo: () => Array<Types_2.IViewportId>;
    // (undocumented)
    id: string;
    // (undocumented)
    removeViewports: {
        (renderingEngineId: string, viewportId?: string): void;
    };
    // (undocumented)
    setToolActive: {
        (toolName: string, toolBindingsOption?: SetToolBindingsType): void;
    };
    // (undocumented)
    setToolConfiguration: {
        (toolName: string, configuration: Record<any, any>, overwrite?: boolean): void;
    };
    // (undocumented)
    setToolDisabled: {
        (toolName: string): void;
    };
    // (undocumented)
    setToolEnabled: {
        (toolName: string): void;
    };
    // (undocumented)
    setToolPassive: {
        (toolName: string): void;
    };
    // (undocumented)
    setViewportsCursorByToolName: {
        (toolName: string, strategyName?: string): void;
    };
    // (undocumented)
    _toolInstances: Record<string, any>;
    // (undocumented)
    toolOptions: Record<string, any>;
    // (undocumented)
    viewportsInfo: Array<Types_2.IViewportId>;
}

// @public
interface IViewport {
    _actors: Map<string, any>;
    addActor(actorEntry: ActorEntry): void;
    addActors(actors: Array<ActorEntry>): void;
    canvas: HTMLCanvasElement;
    canvasToWorld: (canvasPos: Point2) => Point3;
    customRenderViewportToCanvas: () => unknown;
    defaultOptions: any;
    element: HTMLDivElement;
    getActor(actorUID: string): ActorEntry;
    getActorByIndex(index: number): ActorEntry;
    getActors(): Array<ActorEntry>;
    getActorUIDByIndex(index: number): string;
    getCamera(): ICamera;
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    getDefaultActor(): ActorEntry;
    getFrameOfReferenceUID: () => string;
    getRenderer(): void;
    getRenderingEngine(): any;
    id: string;
    options: ViewportInputOptions;
    removeAllActors(): void;
    render(): void;
    renderingEngineId: string;
    reset(immediate: boolean): void;
    setActors(actors: Array<ActorEntry>): void;
    setCamera(cameraInterface: ICamera): void;
    setOptions(options: ViewportInputOptions, immediate: boolean): void;
    sHeight: number;
    suppressEvents: boolean;
    sWidth: number;
    sx: number;
    sy: number;
    type: ViewportType;
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public
interface IViewportId {
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public
interface IVolume {
    dimensions: Point3;
    direction: Float32Array;
    imageData?: vtkImageData;
    metadata: Metadata;
    origin: Point3;
    referencedVolumeId?: string;
    scalarData: Float32Array | Uint8Array;
    scaling?: {
        PET?: {
            // @TODO: Do these values exist?
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            // accessed in ProbeTool
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    sizeInBytes?: number;
    spacing: Point3;
    volumeId: string;
}

// @public
interface IVolumeInput {
    // (undocumented)
    actorUID?: string;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    blendMode?: BlendModes;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    callback?: VolumeInputCallback;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    slabThickness?: number;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    visibility?: boolean;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    volumeId: string;
}

// @public
interface IVolumeLoadObject {
    cancel?: () => void;
    decache?: () => void;
    promise: Promise<ImageVolume>;
}

// @public
interface IVolumeViewport extends IViewport {
    addVolumes(
    volumeInputArray: Array<IVolumeInput>,
    immediate?: boolean,
    suppressEvents?: boolean
    ): Promise<void>;
    canvasToWorld: (canvasPos: Point2) => Point3;
    flip(flipDirection: FlipDirection): void;
    getBounds(): any;
    getCurrentImageId: () => string;
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    getImageData(): IImageData | undefined;
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    getProperties: () => any;
    getSlabThickness(): number;
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    setBlendMode(
    blendMode: BlendModes,
    filterActorUIDs?: Array<string>,
    immediate?: boolean
    ): void;
    setProperties(
        { voiRange }: VolumeViewportProperties,
    volumeId?: string,
    suppressEvents?: boolean
    ): void;
    setSlabThickness(
    slabThickness: number,
    filterActorUIDs?: Array<string>
    ): void;
    setVolumes(
    volumeInputArray: Array<IVolumeInput>,
    immediate?: boolean,
    suppressEvents?: boolean
    ): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
function jumpToSlice(element: HTMLDivElement, options?: JumpToSliceOptions): Promise<void>;

// @public (undocumented)
type JumpToSliceOptions = {
    imageIndex: number;
    debounceLoading?: boolean;
};

// @public (undocumented)
enum KeyboardBindings {
    // (undocumented)
    Alt = 17,
    // (undocumented)
    Ctrl = 18,
    // (undocumented)
    Shift = 16
}

// @public (undocumented)
type KeyDownEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    key: string;
    keyCode: number;
};

// @public (undocumented)
type KeyDownEventType = Types_2.CustomEventType<KeyDownEventDetail>;

// @public (undocumented)
type KeyUpEventDetail = KeyDownEventDetail;

// @public (undocumented)
type KeyUpEventType = Types_2.CustomEventType<KeyUpEventDetail>;

// @public (undocumented)
type LabelmapConfig = {
    renderOutline?: boolean;
    outlineWidthActive?: number;
    outlineWidthInactive?: number;
    renderFill?: boolean;
    renderFillInactive?: boolean;
    fillAlpha?: number;
    fillAlphaInactive?: number;
};

// @public (undocumented)
type LabelmapRenderingConfig = {
    cfun?: vtkColorTransferFunction;
    ofun?: vtkPiecewiseFunction;
};

// @public (undocumented)
type LabelmapSegmentationData = {
    volumeId: string;
    referencedVolumeId?: string;
};

declare namespace LabelmapTypes {
    export {
        LabelmapConfig,
        LabelmapRenderingConfig,
        LabelmapSegmentationData
    }
}

// @public (undocumented)
interface LengthAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                length: number;
                unit: string;
            };
        };
    };
}

// @public (undocumented)
export class LengthTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => LengthAnnotation;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    _calculateLength(pos1: any, pos2: any): number;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getTextLines(data: any, targetId: any): string[];
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: LengthAnnotation, handle: ToolHandle, interactionType?: string): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume(index1: any, index2: any, dimensions: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: LengthAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType | EventTypes_2.MouseMoveEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: LengthAnnotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace lineSegment {
    export {
        distanceToPoint,
        distanceToPointSquared,
        intersectLine
    }
}

declare namespace locking {
    export {
        setAnnotationLocked,
        getAnnotationsLocked,
        getAnnotationsLockedCount,
        unlockAllAnnotations,
        isAnnotationLocked,
        checkAndDefineIsLockedProperty
    }
}

// @public (undocumented)
export class MagnifyTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _bounds: any;
    // (undocumented)
    _createMagnificationViewport: () => void;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    editData: {
        referencedImageId: string;
        viewportIdsToRender: string[];
        enabledElement: Types_2.IEnabledElement;
        renderingEngine: Types_2.IRenderingEngine;
        currentPoints: IPoints;
    } | null;
    // (undocumented)
    _getReferencedImageId(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport): string;
    // (undocumented)
    mouseDragCallback: () => void;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType) => void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.MouseDownActivateEventType) => boolean;
    // (undocumented)
    static toolName: string;
}

declare namespace math {
    export {
        vec2,
        ellipse,
        lineSegment,
        rectangle,
        polyline,
        point
    }
}

// @public
type Metadata = {
    BitsAllocated: number;
    BitsStored: number;
    SamplesPerPixel: number;
    HighBit: number;
    PhotometricInterpretation: string;
    PixelRepresentation: number;
    Modality: string;
    SeriesInstanceUID?: string;
    ImageOrientationPatient: Array<number>;
    PixelSpacing: Array<number>;
    FrameOfReferenceUID: string;
    Columns: number;
    Rows: number;
    voiLut: Array<VOI>;
};

// @public (undocumented)
export class MIPJumpToClickTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _bounds: any;
    // (undocumented)
    mouseClickCallback(evt: any): void;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
enum MouseBindings {
    // (undocumented)
    Auxiliary = 4,
    // (undocumented)
    Fifth_Button = 16,
    // (undocumented)
    Fourth_Button = 8,
    // (undocumented)
    Primary = 1,
    // (undocumented)
    Primary_And_Auxiliary = 5,
    // (undocumented)
    Primary_And_Secondary = 3,
    // (undocumented)
    Primary_And_Secondary_And_Auxiliary = 7,
    // (undocumented)
    Secondary = 2,
    // (undocumented)
    Secondary_And_Auxiliary = 6
}

// @public (undocumented)
type MouseClickEventDetail = NormalizedMouseEventDetail & {
    mouseButton: number;
    startPoints: IPoints;
    lastPoints: IPoints;
    currentPoints: IPoints;
    deltaPoints: IPoints;
};

// @public (undocumented)
type MouseClickEventType = Types_2.CustomEventType<MouseClickEventDetail>;

// @public (undocumented)
class MouseCursor {
    constructor(name: string, fallback?: MouseCursor | undefined);
    // (undocumented)
    addFallbackStyleProperty(style: string): string;
    // (undocumented)
    static getDefinedCursor(name: string): MouseCursor | undefined;
    // (undocumented)
    getName(): string;
    // (undocumented)
    getStyleProperty(): string;
    // (undocumented)
    static setDefinedCursor(name: string, cursor: MouseCursor): boolean;
}

// @public (undocumented)
type MouseDoubleClickEventDetail = NormalizedMouseEventDetail & {
    startPoints: IPoints;
    lastPoints: IPoints;
    currentPoints: IPoints;
    deltaPoints: IPoints;
};

// @public (undocumented)
type MouseDoubleClickEventType = Types_2.CustomEventType<MouseDoubleClickEventDetail>;

// @public (undocumented)
type MouseDownActivateEventDetail = NormalizedMouseEventDetail & {
    mouseButton: number;
    startPoints: IPoints;
    lastPoints: IPoints;
    currentPoints: IPoints;
    deltaPoints: IPoints;
};

// @public (undocumented)
type MouseDownActivateEventType = Types_2.CustomEventType<MouseDownActivateEventDetail>;

// @public (undocumented)
type MouseDownEventDetail = NormalizedMouseEventDetail & {
    mouseButton: number;
    startPoints: IPoints;
    lastPoints: IPoints;
    currentPoints: IPoints;
    deltaPoints: IPoints;
};

// @public (undocumented)
type MouseDownEventType = Types_2.CustomEventType<MouseDownEventDetail>;

// @public (undocumented)
type MouseDragEventDetail = NormalizedMouseEventDetail & {
    mouseButton: number;
    startPoints: IPoints;
    lastPoints: IPoints;
    currentPoints: IPoints;
    deltaPoints: IPoints;
};

// @public (undocumented)
type MouseDragEventType = Types_2.CustomEventType<MouseDragEventDetail>;

// @public (undocumented)
type MouseMoveEventDetail = NormalizedMouseEventDetail & {
    currentPoints: IPoints;
};

// @public (undocumented)
type MouseMoveEventType = Types_2.CustomEventType<MouseMoveEventDetail>;

// @public (undocumented)
type MouseUpEventDetail = NormalizedMouseEventDetail & {
    mouseButton: number;
    startPoints: IPoints;
    lastPoints: IPoints;
    currentPoints: IPoints;
    deltaPoints: IPoints;
};

// @public (undocumented)
type MouseUpEventType = Types_2.CustomEventType<MouseUpEventDetail>;

// @public (undocumented)
type MouseWheelEventDetail = NormalizedMouseEventDetail & {
    detail: Record<string, any>;
    wheel: {
        spinX: number;
        spinY: number;
        pixelX: number;
        pixelY: number;
        direction: number;
    };
    points: IPoints;
};

// @public (undocumented)
type MouseWheelEventType = Types_2.CustomEventType<MouseWheelEventDetail>;

// @public (undocumented)
type NormalizedMouseEventDetail = {
    event: Record<string, unknown> | MouseEvent;
    eventName: string;
    renderingEngineId: string;
    viewportId: string;
    camera: Record<string, unknown>;
    element: HTMLDivElement;
};

// @public (undocumented)
type NormalizedMouseEventType = Types_2.CustomEventType<NormalizedMouseEventDetail>;

// @public (undocumented)
type Orientation = {
    sliceNormal: Point3;
    viewUp: Point3;
};

declare namespace orientation_2 {
    export {
        getOrientationStringLPS,
        invertOrientationStringLPS
    }
}

// @public (undocumented)
export class PanTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: any): void;
    // (undocumented)
    mouseDragCallback: () => void;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    touchDragCallback: () => void;
}

declare namespace planar {
    export {
        _default as default,
        filterAnnotationsWithinSlice,
        getWorldWidthAndHeightFromCorners,
        filterAnnotationsForDisplay,
        getPointInLineOfSightWithCriteria
    }
}

// @public (undocumented)
type PlanarBoundingBox = {
    x: number;
    y: number;
    width: number;
    height: number;
};

// @public (undocumented)
interface PlanarFreehandROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        polyline: Types_2.Point3[];
        label?: string;
        isOpenContour?: boolean;
        isOpenUShapeContour?: boolean;
        openUShapeContourVectorToPeak?: Types_2.Point3[];
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
    };
    // (undocumented)
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        annotationUID?: string;
        FrameOfReferenceUID: string;
        referencedImageId?: string;
        toolName: string;
    };
}

// @public (undocumented)
export class PlanarFreehandROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => PlanarFreehandROIAnnotation;
    // (undocumented)
    cancel: (element: HTMLDivElement) => void;
    // (undocumented)
    filterInteractableAnnotationsForElement(element: HTMLDivElement, annotations: Annotations): Annotations | undefined;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: PlanarFreehandROIAnnotation, handle: ToolHandle, interactionType?: string) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isEditingClosed: boolean;
    // (undocumented)
    isEditingOpen: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: PlanarFreehandROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: PlanarFreehandROIAnnotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    touchDragCallback: any;
    // (undocumented)
    triggerAnnotationCompleted: (annotation: PlanarFreehandROIAnnotation) => void;
    // (undocumented)
    triggerAnnotationModified: (annotation: PlanarFreehandROIAnnotation, enabledElement: Types_2.IEnabledElement) => void;
}

// @public
type Plane = [number, number, number, number];

// @public (undocumented)
function playClip(element: HTMLDivElement, playClipOptions: CINETypes.PlayClipOptions): void;

// @public (undocumented)
type PlayClipOptions = {
    framesPerSecond?: number;
    frameTimeVector?: number[];
    reverse?: boolean;
    loop?: boolean;
    frameTimeVectorSpeedMultiplier?: number;
};

declare namespace point {
    export {
        distanceToPoint_3 as distanceToPoint
    }
}

// @public
type Point2 = [number, number];

// @public
type Point3 = [number, number, number];

// @public
type Point4 = [number, number, number, number];

// @public (undocumented)
const pointCanProjectOnLine: (p: Types_2.Point2, p1: Types_2.Point2, p2: Types_2.Point2, proximity: number) => boolean;

// @public (undocumented)
function pointInEllipse(ellipse: Ellipse, pointLPS: Types_2.Point3): boolean;

// @public (undocumented)
function pointInShapeCallback(imageData: vtkImageData | Types_2.CPUImageData, pointInShapeFn: ShapeFnCriteria, callback: PointInShapeCallback, boundsIJK?: BoundsIJK): void;

// @public (undocumented)
function pointInSurroundingSphereCallback(imageData: vtkImageData, circlePoints: [Types_2.Point3, Types_2.Point3], callback: PointInShapeCallback, viewport?: Types_2.IVolumeViewport): void;

// @public (undocumented)
const pointsAreWithinCloseContourProximity: (p1: Types_2.Point2, p2: Types_2.Point2, closeContourProximity: number) => boolean;

declare namespace polyline {
    export {
        getFirstIntersectionWithPolyline,
        getClosestIntersectionWithPolyline,
        getSubPixelSpacingAndXYDirections,
        pointsAreWithinCloseContourProximity,
        addCanvasPointsToArray,
        pointCanProjectOnLine,
        calculateAreaOfPoints
    }
}

// @public
type PreStackNewImageEvent = CustomEvent_2<PreStackNewImageEventDetail>;

// @public
type PreStackNewImageEventDetail = {
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
interface ProbeAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
        };
        cachedStats: {
            [targetId: string]: {
                Modality: string;
                index: Types_2.Point3;
                value: number;
            };
        };
        label: string;
    };
}

// @public (undocumented)
export class ProbeTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => ProbeAnnotation;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        newAnnotation?: boolean;
    } | null;
    // (undocumented)
    eventDispatchDetail: {
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getHandleNearImagePoint(element: HTMLDivElement, annotation: ProbeAnnotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    _getTextLines(data: any, targetId: any): any[];
    // (undocumented)
    _getValueForModality(value: any, imageVolume: any, modality: any): {};
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: ProbeAnnotation, handle: ToolHandle, interactionType?: string): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool(): boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragCallback: (evt: any) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback(): void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
type PTScaling = {
    suvbwToSuvlbm?: number;
    suvbwToSuvbsa?: number;
};

// @public (undocumented)
type PublicToolProps = SharedToolProp & {
    name?: string;
};

// @public
type PublicViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions?: ViewportInputOptions;
};

declare namespace rectangle {
    export {
        distanceToPoint_2 as distanceToPoint
    }
}

// @public (undocumented)
interface RectangleROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats?: ROICachedStats | {
            projectionPoints?: Types_2.Point3[];
            projectionPointsImageIds?: string[];
        };
    };
}

// @public (undocumented)
interface RectangleROIStartEndThresholdAnnotation extends Annotation {
    // (undocumented)
    data: {
        label: string;
        startSlice: number;
        endSlice: number;
        cachedStats: {
            projectionPoints: Types_2.Point3[][];
            projectionPointsImageIds: string[];
        };
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
        };
    };
    // (undocumented)
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        annotationUID?: string;
        FrameOfReferenceUID: string;
        referencedImageId?: string;
        toolName: string;
        enabledElement: any;
        volumeId: string;
        spacingInNormal: number;
    };
}

// @public (undocumented)
export class RectangleROIStartEndThresholdTool extends RectangleROITool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => {
        highlighted: boolean;
        invalidated: boolean;
        metadata: {
            viewPlaneNormal: Types_2.Point3;
            enabledElement: Types_2.IEnabledElement;
            viewUp: Types_2.Point3;
            FrameOfReferenceUID: string;
            referencedImageId: any;
            toolName: string;
            volumeId: any;
            spacingInNormal: number;
        };
        data: {
            label: string;
            startSlice: number;
            endSlice: number;
            cachedStats: {
                projectionPoints: any[];
                projectionPointsImageIds: any[];
            };
            handles: {
                textBox: {
                    hasMoved: boolean;
                    worldPosition: any;
                    worldBoundingBox: any;
                };
                points: Types_2.Point3[];
                activeHandleIndex: any;
            };
            labelmapUID: any;
        };
    };
    // (undocumented)
    _calculateCachedStatsTool(annotation: any, enabledElement: any): any;
    // (undocumented)
    _computeProjectionPoints(annotation: RectangleROIStartEndThresholdAnnotation, imageVolume: Types_2.IImageVolume): void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getEndSliceIndex(imageVolume: Types_2.IImageVolume, worldPos: Types_2.Point3, spacingInNormal: number, viewPlaneNormal: Types_2.Point3): number | undefined;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
interface RectangleROIThresholdAnnotation extends Annotation {
    // (undocumented)
    data: {
        label: string;
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
        };
    };
    // (undocumented)
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        annotationUID?: string;
        FrameOfReferenceUID: string;
        referencedImageId?: string;
        toolName: string;
        enabledElement: Types_2.IEnabledElement;
        volumeId: string;
    };
}

// @public (undocumented)
export class RectangleROIThresholdTool extends RectangleROITool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => {
        highlighted: boolean;
        invalidated: boolean;
        metadata: {
            viewPlaneNormal: Types_2.Point3;
            enabledElement: Types_2.IEnabledElement;
            viewUp: Types_2.Point3;
            FrameOfReferenceUID: string;
            referencedImageId: any;
            toolName: string;
            volumeId: any;
        };
        data: {
            label: string;
            handles: {
                textBox: {
                    hasMoved: boolean;
                    worldPosition: any;
                    worldBoundingBox: any;
                };
                points: Types_2.Point3[];
                activeHandleIndex: any;
            };
            segmentationId: any;
        };
    };
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
function rectangleROIThresholdVolumeByRange(annotationUIDs: string[], segmentationVolume: Types_2.IImageVolume, referenceVolumes: Types_2.IImageVolume[], options: ThresholdRangeOptions_2): Types_2.IImageVolume;

// @public (undocumented)
export class RectangleROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => RectangleROIAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewPlaneNormal: any, viewUp: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getRectangleImageCoordinates: (points: Array<Types_2.Point2>) => {
        left: number;
        top: number;
        width: number;
        height: number;
    };
    // (undocumented)
    _getTextLines: (data: any, targetId: string) => any[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: RectangleROIAnnotation, handle: ToolHandle, interactionType?: string) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: RectangleROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseMoveEventType | EventTypes_2.MouseDragEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: RectangleROIAnnotation, interactionType: InteractionTypes) => void;
}

declare namespace rectangleROITool {
    export {
        getBoundsIJKFromRectangleAnnotations
    }
}

// @public (undocumented)
export class RectangleScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentationId: string;
        segmentation: any;
        segmentIndex: number;
        segmentsLocked: number[];
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.MouseDownActivateEventType) => boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
function registerCursor(toolName: string, iconContent: string, viewBox: {
    x: number;
    y: number;
}): void;

// @public (undocumented)
function removeAllAnnotations(element?: HTMLDivElement): void;

// @public (undocumented)
function removeAnnotation(annotationUID: string, element?: HTMLDivElement): void;

// @public (undocumented)
function removeSegmentation(segmentationId: string): void;

// @public (undocumented)
function removeSegmentationRepresentation(toolGroupId: string, segmentationRepresentationUID: string): void;

// @public (undocumented)
function removeSegmentationsFromToolGroup(toolGroupId: string, segmentationRepresentationUIDs?: string[] | undefined): void;

// @public (undocumented)
export function removeTool(ToolClass: any): void;

// @public (undocumented)
type RepresentationConfig = {
    LABELMAP?: LabelmapConfig;
};

// @public (undocumented)
type RepresentationPublicInput = {
    segmentationId: string;
    type: Enums.SegmentationRepresentations;
};

// @public (undocumented)
function resetElementCursor(element: HTMLDivElement): void;

// @public (undocumented)
type Scaling = {
    PET?: PTScaling;
};

// @public (undocumented)
type ScalingParameters = {
    rescaleSlope: number;
    rescaleIntercept: number;
    modality: string;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
function scroll_2(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, options: ScrollOptions_2): void;

// @public (undocumented)
type ScrollOptions_2 = {
    delta: number;
    volumeId?: string;
    debounceLoading?: boolean;
};

// @public (undocumented)
type Segmentation = {
    segmentationId: string;
    type: Enums.SegmentationRepresentations;
    label: string;
    activeSegmentIndex: number;
    segmentsLocked: Set<number>;
    cachedStats: {
        [key: string]: number;
    };
    representationData: SegmentationRepresentationData;
};

declare namespace segmentation {
    export {
        state_2 as state,
        addSegmentations,
        activeSegmentation,
        addSegmentationRepresentations,
        removeSegmentationsFromToolGroup,
        segmentLocking,
        config_2 as config,
        segmentIndex,
        triggerSegmentationEvents
    }
}
export { segmentation }

declare namespace segmentation_2 {
    export {
        thresholdVolumeByRange,
        createMergedLabelmapForIndex,
        isValidRepresentationConfig,
        getDefaultRepresentationConfig,
        createLabelmapVolumeForViewport,
        rectangleROIThresholdVolumeByRange
    }
}

// @public (undocumented)
type SegmentationDataModifiedEventDetail = {
    segmentationId: string;
    modifiedSlicesToUse?: number[];
};

// @public (undocumented)
type SegmentationDataModifiedEventType = Types_2.CustomEventType<SegmentationDataModifiedEventDetail>;

// @public (undocumented)
export class SegmentationDisplayTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _getMergedRepresentationsConfig(toolGroupId: string): SegmentationRepresentationConfig;
    // (undocumented)
    onSetToolDisabled(): void;
    // (undocumented)
    onSetToolEnabled(): void;
    // (undocumented)
    renderSegmentation: (toolGroupId: string) => void;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
type SegmentationModifiedEventDetail = {
    segmentationId: string;
};

// @public (undocumented)
type SegmentationModifiedEventType = Types_2.CustomEventType<SegmentationModifiedEventDetail>;

// @public (undocumented)
type SegmentationRemovedEventDetail = {
    segmentationId: string;
};

// @public (undocumented)
type SegmentationRemovedEventType = Types_2.CustomEventType<SegmentationRemovedEventDetail>;

// @public (undocumented)
type SegmentationRenderedEventDetail = {
    viewportId: string;
    toolGroupId: string;
};

// @public (undocumented)
type SegmentationRenderedEventType = Types_2.CustomEventType<SegmentationRenderedEventDetail>;

// @public (undocumented)
type SegmentationRepresentationConfig = {
    renderInactiveSegmentations: boolean;
    representations: RepresentationConfig;
};

// @public (undocumented)
type SegmentationRepresentationData = {
    LABELMAP?: LabelmapSegmentationData;
};

// @public (undocumented)
type SegmentationRepresentationModifiedEventDetail = {
    toolGroupId: string;
    segmentationRepresentationUID: string;
};

// @public (undocumented)
type SegmentationRepresentationModifiedEventType = Types_2.CustomEventType<SegmentationRepresentationModifiedEventDetail>;

// @public (undocumented)
type SegmentationRepresentationRemovedEventDetail = {
    toolGroupId: string;
    segmentationRepresentationUID: string;
};

// @public (undocumented)
type SegmentationRepresentationRemovedEventType = Types_2.CustomEventType<SegmentationRepresentationRemovedEventDetail>;

// @public (undocumented)
enum SegmentationRepresentations {
    // (undocumented)
    Labelmap = "LABELMAP"
}

// @public (undocumented)
type SegmentationState = {
    colorLUT: ColorLUT[];
    segmentations: Segmentation[];
    globalConfig: SegmentationRepresentationConfig;
    toolGroups: {
        [key: string]: {
            segmentationRepresentations: ToolGroupSpecificRepresentations;
            config: SegmentationRepresentationConfig;
        };
    };
};

declare namespace segmentIndex {
    export {
        getActiveSegmentIndex,
        setActiveSegmentIndex
    }
}

declare namespace segmentLocking {
    export {
        isSegmentIndexLocked,
        setSegmentIndexLocked,
        getLockedSegments
    }
}

declare namespace selection {
    export {
        setAnnotationSelected,
        getAnnotationsSelected,
        getAnnotationsSelectedByToolName,
        getAnnotationsSelectedCount,
        deselectAnnotation,
        isAnnotationSelected
    }
}

// @public (undocumented)
function setActiveSegmentationRepresentation(toolGroupId: string, segmentationRepresentationUID: string): void;

// @public (undocumented)
function setActiveSegmentIndex(segmentationId: string, segmentIndex: number): void;

// @public (undocumented)
function setAnnotationLocked(annotation: Annotation, locked?: boolean): void;

// @public (undocumented)
function setAnnotationSelected(annotationUID: string, selected?: boolean, preserveSelected?: boolean): void;

// @public (undocumented)
function setAnnotationVisibility(annotationUID: string, visible?: boolean): void;

// @public (undocumented)
function setColorLUT(toolGroupId: string, segmentationRepresentationUID: string, colorLUTIndex: number): void;

// @public (undocumented)
function setConfiguration(config: any): void;

// @public (undocumented)
function setCursorForElement(element: HTMLDivElement, cursorName: string): void;

// @public (undocumented)
function _setElementCursor(element: HTMLDivElement, cursor: MouseCursor | null): void;

// @public (undocumented)
function setGlobalConfig(config: SegmentationRepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setGlobalConfig_2(segmentationConfig: SegmentationRepresentationConfig): void;

// @public (undocumented)
function setGlobalRepresentationConfig(representationType: SegmentationRepresentations, config: RepresentationConfig['LABELMAP']): void;

// @public (undocumented)
function setSegmentationVisibility(toolGroupId: string, segmentationRepresentationUID: string, visibility: boolean): void;

// @public (undocumented)
function setSegmentIndexLocked(segmentationId: string, segmentIndex: number, locked?: boolean): void;

// @public (undocumented)
type SetToolBindingsType = {
    bindings: IToolBinding[];
};

// @public (undocumented)
function setToolGroupSpecificConfig(toolGroupId: string, config: SegmentationRepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setToolGroupSpecificConfig_2(toolGroupId: string, segmentationRepresentationConfig: SegmentationRepresentationConfig): void;

// @public (undocumented)
function showAllAnnotations(): void;

// @public (undocumented)
export class SphereScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentation: any;
        segmentIndex: number;
        segmentsLocked: number[];
        segmentationId: string;
        toolGroupId: string;
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        centerCanvas?: Array<number>;
    } | null;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.MouseDownActivateEventType) => true;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: string;
}

// @public
type StackNewImageEvent = CustomEvent_2<StackNewImageEventDetail>;

// @public
type StackNewImageEventDetail = {
    image: IImage;
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

declare namespace stackPrefetch {
    export {
        enable,
        disable,
        setConfiguration,
        getConfiguration
    }
}

// @public (undocumented)
export class StackScrollMouseWheelTool extends BaseTool {
    constructor(toolProps?: {}, defaultToolProps?: {
        supportedInteractionTypes: string[];
        configuration: {
            invert: boolean;
            debounceIfNotLoaded: boolean;
        };
    });
    // (undocumented)
    _configuration: any;
    // (undocumented)
    mouseWheelCallback(evt: MouseWheelEventType): void;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
export class StackScrollTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    deltaY: number;
    // (undocumented)
    _dragCallback(evt: EventTypes_2.MouseDragEventType): void;
    // (undocumented)
    _getNumberOfSlices(viewport: any): number;
    // (undocumented)
    _getPixelPerImage(viewport: any): number;
    // (undocumented)
    mouseDragCallback: () => void;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    touchDragCallback: () => void;
}

// @public
type StackViewportNewStackEvent =
CustomEvent_2<StackViewportNewStackEventDetail>;

// @public
type StackViewportNewStackEventDetail = {
    imageIds: string[];
    viewportId: string;
    element: HTMLDivElement;
    currentImageIdIndex: number;
};

// @public
type StackViewportProperties = {
    voiRange?: VOIRange;
    invert?: boolean;
    interpolationType?: InterpolationType;
    rotation?: number;
    suppressEvents?: boolean;
};

// @public (undocumented)
type StackViewportScrollEvent = CustomEvent_2<StackViewportScrollEventDetail>;

// @public
type StackViewportScrollEventDetail = {
    newImageIdIndex: number;
    imageId: string;
    direction: number;
};

declare namespace state {
    export {
        getAnnotations,
        addAnnotation,
        getAnnotation,
        removeAnnotation,
        removeAllAnnotations,
        getViewportSpecificAnnotationManager,
        getDefaultAnnotationManager
    }
}

declare namespace state_2 {
    export {
        getDefaultSegmentationStateManager,
        getSegmentation,
        getSegmentations,
        addSegmentation,
        removeSegmentation,
        getSegmentationRepresentations,
        addSegmentationRepresentation,
        removeSegmentationRepresentation,
        getToolGroupSpecificConfig,
        setToolGroupSpecificConfig,
        getGlobalConfig,
        setGlobalConfig,
        getToolGroupsWithSegmentation,
        getSegmentationRepresentationByUID,
        addColorLUT,
        getColorLUT
    }
}

// @public (undocumented)
function stopClip(element: HTMLDivElement): void;

// @public (undocumented)
type StyleConfig = {
    annotations?: {
        [annotationUID: string]: AnnotationStyle_2;
    };
    viewports?: {
        [viewportId: string]: ToolStyleConfig;
    };
    toolGroups?: {
        [toolGroupId: string]: ToolStyleConfig;
    };
    default: ToolStyleConfig;
};

// @public (undocumented)
type StyleSpecifier = {
    viewportId?: string;
    toolGroupId?: string;
    toolName?: string;
    annotationUID?: string;
};

// @public (undocumented)
type SVGCursorDescriptor = {
    iconContent: string;
    iconSize: number;
    viewBox: SVGPoint_2;
    mousePoint: SVGPoint_2;
    mousePointerGroupString: string;
};

// @public (undocumented)
type SVGDrawingHelper = {
    svgLayerElement: HTMLDivElement;
    svgNodeCacheForCanvas: Record<string, unknown>;
    getSvgNode: (cacheKey: string) => SVGGElement | undefined;
    appendNode: (svgNode: SVGElement, cacheKey: string) => void;
    setNodeTouched: (cacheKey: string) => void;
    clearUntouched: () => void;
};

// @public (undocumented)
class SVGMouseCursor extends ImageMouseCursor {
    constructor(url: string, x?: number, y?: number, name?: string | undefined, fallback?: MouseCursor | undefined);
    // (undocumented)
    static getDefinedCursor(name: string, pointer?: boolean, color?: string): MouseCursor;
}

// @public (undocumented)
type SVGPoint_2 = {
    x: number;
    y: number;
};

// @public (undocumented)
export class Synchronizer {
    constructor(synchronizerId: string, eventName: string, eventHandler: ISynchronizerEventHandler);
    // (undocumented)
    add(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    addSource(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    addTarget(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    getSourceViewports(): Array<Types_2.IViewportId>;
    // (undocumented)
    getTargetViewports(): Array<Types_2.IViewportId>;
    // (undocumented)
    hasSourceViewport(renderingEngineId: string, viewportId: string): boolean;
    // (undocumented)
    hasTargetViewport(renderingEngineId: string, viewportId: string): boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    isDisabled(): boolean;
    // (undocumented)
    remove(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    removeSource(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    removeTarget(viewportInfo: Types_2.IViewportId): void;
}

declare namespace SynchronizerManager {
    export {
        createSynchronizer,
        destroy_2 as destroy,
        getSynchronizer,
        getSynchronizersForViewport,
        getAllSynchronizers,
        destroySynchronizer
    }
}
export { SynchronizerManager }

declare namespace synchronizers {
    export {
        createCameraPositionSynchronizer,
        createVOISynchronizer
    }
}
export { synchronizers }

// @public (undocumented)
type TextBoxHandle = {
    hasMoved: boolean;
    worldBoundingBox: {
        bottomLeft: Types_2.Point3;
        bottomRight: Types_2.Point3;
        topLeft: Types_2.Point3;
        topRight: Types_2.Point3;
    };
    worldPosition: Types_2.Point3;
};

// @public (undocumented)
function thresholdVolumeByRange(segmentationVolume: Types_2.IImageVolume, referenceVolume: Types_2.IImageVolume, options: ThresholdRangeOptions): Types_2.IImageVolume;

// @public (undocumented)
function throttle(func: Function, wait?: number, options?: {
    leading?: boolean;
    trailing?: boolean;
}): Function;

// @public (undocumented)
interface ToolData {
    // (undocumented)
    framesPerSecond: number;
    // (undocumented)
    frameTimeVector: number[] | undefined;
    // (undocumented)
    ignoreFrameTimeVector: boolean;
    // (undocumented)
    intervalId: number | undefined;
    // (undocumented)
    lastFrameTimeStamp: number | undefined;
    // (undocumented)
    loop: boolean;
    // (undocumented)
    reverse: boolean;
    // (undocumented)
    speed: number;
    // (undocumented)
    usingFrameTimeVector: boolean;
}

declare namespace ToolGroupManager {
    export {
        createToolGroup,
        destroy_3 as destroy,
        destroyToolGroup,
        getToolGroup,
        getToolGroupForViewport,
        getAllToolGroups
    }
}
export { ToolGroupManager }

// @public (undocumented)
type ToolGroupSpecificLabelmapRepresentation = ToolGroupSpecificRepresentationState & {
    config: LabelmapRenderingConfig;
};

// @public (undocumented)
type ToolGroupSpecificRepresentation = ToolGroupSpecificLabelmapRepresentation;

// @public (undocumented)
type ToolGroupSpecificRepresentationState = {
    segmentationRepresentationUID: string;
    segmentationId: string;
    type: Enums.SegmentationRepresentations;
    active: boolean;
    segmentsHidden: Set<number>;
    visibility: boolean;
    colorLUTIndex: number;
};

// @public (undocumented)
type ToolHandle = AnnotationHandle | TextBoxHandle;

// @public (undocumented)
enum ToolModes {
    // (undocumented)
    Active = "Active",
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled",
    // (undocumented)
    Passive = "Passive"
}

// @public (undocumented)
type ToolOptionsType = {
    bindings: IToolBinding[];
    mode: ToolModes;
};

// @public (undocumented)
type ToolProps = SharedToolProp;

declare namespace ToolSpecificAnnotationTypes {
    export {
        RectangleROIAnnotation,
        ProbeAnnotation,
        LengthAnnotation,
        EllipticalROIAnnotation,
        BidirectionalAnnotation,
        RectangleROIThresholdAnnotation,
        RectangleROIStartEndThresholdAnnotation,
        PlanarFreehandROIAnnotation,
        ArrowAnnotation,
        AngleAnnotation
    }
}

// @public (undocumented)
const toolStyle: ToolStyle;

// @public (undocumented)
type ToolStyleConfig = {
    [toolName: string]: AnnotationStyle_2;
    global?: AnnotationStyle_2;
};

// @public (undocumented)
export class TrackballRotateTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: any): void;
    // (undocumented)
    mouseDragCallback: () => void;
    // (undocumented)
    rotateCamera: (viewport: any, centerWorld: any, axis: any, angle: any) => void;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    touchDragCallback: () => void;
}

// @public
type TransformMatrix2D = [number, number, number, number, number, number];

// @public (undocumented)
function triggerAnnotationRenderForViewportIds(renderingEngine: Types_2.IRenderingEngine, viewportIdsToRender: string[]): void;

// @public
function triggerEvent(
el: EventTarget = eventTarget,
type: string,
detail: unknown = null
): boolean {
    if (!type) {
        throw new Error('Event type was not defined');
    }

    const // (undocumented)
    event = new CustomEvent(type, {
        detail,
        cancelable: true,
    });

    return el.dispatchEvent(event);
}

// @public (undocumented)
function triggerSegmentationDataModified(segmentationId: string, modifiedSlicesToUse?: number[]): void;

declare namespace triggerSegmentationEvents {
    export {
        triggerSegmentationRepresentationModified,
        triggerSegmentationRepresentationRemoved,
        triggerSegmentationDataModified,
        triggerSegmentationModified,
        triggerSegmentationRemoved
    }
}

// @public (undocumented)
function triggerSegmentationModified(segmentationId?: string): void;

// @public (undocumented)
function triggerSegmentationRemoved(segmentationId: string): void;

// @public (undocumented)
function triggerSegmentationRepresentationModified(toolGroupId: string, segmentationRepresentationUID?: string): void;

// @public (undocumented)
function triggerSegmentationRepresentationRemoved(toolGroupId: string, segmentationRepresentationUID: string): void;

declare namespace Types {
    export {
        Annotation,
        Annotations,
        FrameOfReferenceSpecificAnnotations,
        AnnotationState,
        AnnotationStyle,
        ToolSpecificAnnotationTypes,
        JumpToSliceOptions,
        PlanarBoundingBox,
        ToolProps,
        PublicToolProps,
        EventTypes_2 as EventTypes,
        IPoints,
        IToolBinding,
        SetToolBindingsType,
        ToolOptionsType,
        InteractionTypes,
        IToolGroup,
        ToolHandle,
        AnnotationHandle,
        TextBoxHandle,
        Segmentation,
        SegmentationState,
        SegmentationRepresentationData,
        SegmentationRepresentationConfig,
        RepresentationConfig,
        ToolGroupSpecificRepresentationState,
        ToolGroupSpecificLabelmapRepresentation,
        ToolGroupSpecificRepresentation,
        RepresentationPublicInput,
        Color,
        ColorLUT,
        LabelmapTypes,
        SVGCursorDescriptor,
        SVGPoint_2 as SVGPoint,
        ScrollOptions_2 as ScrollOptions,
        CINETypes,
        BoundsIJK,
        SVGDrawingHelper
    }
}
export { Types }

// @public (undocumented)
function unlockAllAnnotations(): void;

declare namespace utilities {
    export {
        math,
        planar,
        viewportFilters,
        drawing_2 as drawing,
        debounce,
        deepmerge as deepMerge,
        throttle,
        orientation_2 as orientation,
        isObject,
        triggerEvent,
        calibrateImageSpacing,
        segmentation_2 as segmentation,
        triggerAnnotationRenderForViewportIds,
        pointInShapeCallback,
        pointInSurroundingSphereCallback,
        getAnnotationNearPoint,
        getAnnotationNearPointOnEnabledElement,
        jumpToSlice,
        cine,
        clip_2 as clip,
        boundingBox,
        rectangleROITool,
        stackPrefetch,
        scroll_2 as scroll
    }
}
export { utilities }

declare namespace vec2 {
    export {
        findClosestPoint,
        clip as liangBarksyClip
    }
}

declare namespace viewportFilters {
    export {
        filterViewportsWithToolEnabled,
        filterViewportsWithFrameOfReferenceUID,
        getViewportIdsWithToolToRender
    }
}

// @public
type ViewportInputOptions = {
    background?: [number, number, number];
    orientation?: Orientation;
    suppressEvents?: boolean;
};

declare namespace visibility {
    export {
        setAnnotationVisibility,
        showAllAnnotations,
        isAnnotationVisible,
        checkAndDefineIsVisibleProperty
    }
}

declare namespace visibility_2 {
    export {
        setSegmentationVisibility,
        getSegmentationVisibility
    }
}

// @public (undocumented)
type VOI = {
    windowWidth: number;
    windowCenter: number;
};

// @public
type VoiModifiedEvent = CustomEvent_2<VoiModifiedEventDetail>;

// @public
type VoiModifiedEventDetail = {
    viewportId: string;
    range: VOIRange;
    volumeId?: string;
};

// @public (undocumented)
type VOIRange = {
    upper: number;
    lower: number;
};

// @public (undocumented)
type VolumeActor = vtkVolume;

// @public
type VolumeCacheVolumeAddedEvent =
CustomEvent_2<VolumeCacheVolumeAddedEventDetail>;

// @public
type VolumeCacheVolumeAddedEventDetail = {
    volume: ICachedVolume;
};

// @public
type VolumeCacheVolumeRemovedEvent =
CustomEvent_2<VolumeCacheVolumeRemovedEventDetail>;

// @public
type VolumeCacheVolumeRemovedEventDetail = {
    volumeId: string;
};

// @public
type VolumeInputCallback = (params: {
    volumeActor: VolumeActor;
    volumeId: string;
}) => unknown;

// @public
type VolumeLoadedEvent = CustomEvent_2<VolumeLoadedEventDetail>;

// @public
type VolumeLoadedEventDetail = {
    volume: IImageVolume;
};

// @public
type VolumeLoadedFailedEvent = CustomEvent_2<VolumeLoadedFailedEventDetail>;

// @public
type VolumeLoadedFailedEventDetail = {
    volumeId: string;
    error: unknown;
};

// @public
type VolumeLoaderFn = (
volumeId: string,
options?: Record<string, any>
) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public
type VolumeNewImageEvent = CustomEvent_2<VolumeNewImageEventDetail>;

// @public
type VolumeNewImageEventDetail = {
    imageIndex: number;
    numberOfSlices: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
export class VolumeRotateMouseWheelTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _configuration: any;
    // (undocumented)
    mouseWheelCallback(evt: MouseWheelEventType): void;
    // (undocumented)
    static toolName: string;
}

// @public
type VolumeViewportProperties = {
    voiRange?: VOIRange;
};

// @public (undocumented)
export class WindowLevelTool extends BaseTool {
    constructor(toolProps?: {}, defaultToolProps?: {
        supportedInteractionTypes: string[];
    });
    // (undocumented)
    _dragCallback(evt: any): void;
    // (undocumented)
    _getImageDynamicRangeFromMiddleSlice: (scalarData: any, dimensions: any) => number;
    // (undocumented)
    _getImageDynamicRangeFromViewport(viewport: any): number;
    // (undocumented)
    _getMultiplierFromDynamicRange(viewport: any, volumeId: any): number;
    // (undocumented)
    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }: {
        viewport: any;
        deltaPointsCanvas: any;
        volumeId: any;
        lower: any;
        upper: any;
    }): {
        lower: number;
        upper: number;
    };
    // (undocumented)
    getPTNewRange({ deltaPointsCanvas, lower, upper, clientHeight }: {
        deltaPointsCanvas: any;
        lower: any;
        upper: any;
        clientHeight: any;
    }): {
        lower: any;
        upper: any;
    };
    // (undocumented)
    mouseDragCallback: () => void;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    touchDragCallback: () => void;
}

// @public (undocumented)
export class ZoomTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    dirVec: Types_2.Point3;
    // (undocumented)
    _dragCallback(evt: EventTypes_2.MouseDragEventType): void;
    // (undocumented)
    _dragParallelProjection: (evt: EventTypes_2.MouseDragEventType, viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, camera: Types_2.ICamera) => void;
    // (undocumented)
    _dragPerspectiveProjection: (evt: any, viewport: any, camera: any) => void;
    // (undocumented)
    initialMousePosWorld: Types_2.Point3;
    // (undocumented)
    mouseDragCallback: () => void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.MouseDownActivateEventType) => boolean;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    touchDragCallback: () => void;
}

// (No @packageDocumentation comment for this package)

```

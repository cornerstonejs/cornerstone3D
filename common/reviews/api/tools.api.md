## API Report File for "@cornerstonejs/tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Corners } from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget/Constants';
import type { GetGPUTier } from 'detect-gpu';
import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';
import { IStackViewport as IStackViewport_2 } from 'packages/core/dist/types/types';
import { IVolumeViewport as IVolumeViewport_2 } from 'packages/core/dist/types/types';
import { mat3 } from 'gl-matrix';
import { mat4 } from 'gl-matrix';
import type { TierResult } from 'detect-gpu';
import { vec3 } from 'gl-matrix';
import type vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';
import vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';
import { vtkColorTransferFunction } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';
import { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';
import vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import type { vtkPiecewiseFunction } from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';
import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';
import type vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';

declare namespace aabb {
    export {
        intersectAABB,
        distanceToPoint,
        distanceToPointSquared
    }
}

// @public (undocumented)
function acceptAutogeneratedInterpolations(annotationGroupSelector: AnnotationGroupSelector, selector: AcceptInterpolationSelector): void;

declare namespace activeSegmentation {
    export {
        getActiveSegmentationRepresentation,
        getActiveSegmentation,
        setActiveSegmentationRepresentation
    }
}

// @public (undocumented)
function addAnnotation(annotation: Annotation, annotationGroupSelector: AnnotationGroupSelector): string;

// @public (undocumented)
const addCanvasPointsToArray: (element: HTMLDivElement, canvasPoints: Types_2.Point2[], newCanvasPoint: Types_2.Point2, commonData: PlanarFreehandROICommonData) => number;

// @public (undocumented)
function addChildAnnotation(parentAnnotation: Annotation, childAnnotation: Annotation): void;

// @public (undocumented)
function addColorLUT(colorLUT: Types_2.ColorLUT, index: number): void;

// @public (undocumented)
function addColorLUT_2(colorLUT: Types_2.ColorLUT, colorLUTIndex: number): void;

// @public (undocumented)
function addContourSegmentationAnnotation(annotation: ContourSegmentationAnnotation): void;

// @public (undocumented)
function addRepresentationData({ segmentationId, type, data, }: AddRepresentationData): void;

// @public (undocumented)
function addSegmentation(segmentationInput: SegmentationPublicInput, suppressEvents?: boolean): void;

// @public (undocumented)
function addSegmentationRepresentation(toolGroupId: string, segmentationRepresentation: ToolGroupSpecificRepresentation, suppressEvents?: boolean): void;

// @public (undocumented)
function addSegmentationRepresentations(toolGroupId: string, representationInputArray: RepresentationPublicInput[], toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig): Promise<string[]>;

// @public (undocumented)
function addSegmentations(segmentationInputArray: SegmentationPublicInput[]): void;

// @public (undocumented)
export function addTool(ToolClass: any): void;

// @public (undocumented)
function addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void;

// @public (undocumented)
interface AdvancedMagnifyAnnotation extends Annotation {
    // (undocumented)
    data: {
        zoomFactor: number;
        sourceViewportId: string;
        magnifyViewportId: string;
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
        };
    };
}

// @public (undocumented)
export class AdvancedMagnifyTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    static Actions: typeof AdvancedMagnifyToolActions;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => AdvancedMagnifyAnnotation;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragDrawCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragHandle: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: AdvancedMagnifyAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: AdvancedMagnifyAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    magnifyViewportManager: AdvancedMagnifyViewportManager;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    showZoomFactorsList(evt: EventTypes_2.InteractionEventType, annotation: AdvancedMagnifyAnnotation): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: AdvancedMagnifyAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
interface AngleAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                angle: number;
            };
        };
    };
}

// @public (undocumented)
export class AngleTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => AngleAnnotation;
    // (undocumented)
    angleStartedNotYetCompleted: boolean;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: AngleAnnotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: AngleAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: AngleAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
type Annotation = {
    annotationUID?: string;
    parentAnnotationUID?: string;
    childAnnotationUIDs?: string[];
    highlighted?: boolean;
    isLocked?: boolean;
    isVisible?: boolean;
    invalidated?: boolean;
    autoGenerated?: boolean;
    metadata: Types_2.ViewReference & {
        toolName: string;
        cameraPosition?: Types_2.Point3;
        viewUp?: Types_2.Point3;
    };
    data: {
        handles?: {
            points?: Types_2.Point3[];
            activeHandleIndex?: number | null;
            textBox?: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox?: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
            [key: string]: any;
        };
        [key: string]: any;
        cachedStats?: unknown;
    };
};

declare namespace annotation {
    export {
        config,
        locking,
        selection,
        state_2 as state,
        visibility,
        FrameOfReferenceSpecificAnnotationManager,
        AnnotationGroup
    }
}
export { annotation }

// @public (undocumented)
type AnnotationAddedEventDetail = {
    viewportId?: string;
    renderingEngineId?: string;
    annotation: Annotation;
};

// @public (undocumented)
type AnnotationAddedEventType = Types_2.CustomEventType<AnnotationAddedEventDetail>;

// @public (undocumented)
type AnnotationCompletedEventDetail = {
    annotation: Annotation;
    changeType?: ChangeTypes.Completed;
};

// @public (undocumented)
type AnnotationCompletedEventType = Types_2.CustomEventType<AnnotationCompletedEventDetail>;

// @public (undocumented)
export abstract class AnnotationDisplayTool extends BaseTool {
    // (undocumented)
    filterInteractableAnnotationsForElement(element: HTMLDivElement, annotations: Annotations): Annotations | undefined;
    // (undocumented)
    protected getReferencedImageId(viewport: Types_2.IViewport, worldPos: Types_2.Point3, viewPlaneNormal: Types_2.Point3, viewUp: Types_2.Point3): string;
    // (undocumented)
    getStyle(property: string, specifications: StyleSpecifier, annotation?: Annotation): unknown;
    // (undocumented)
    onImageSpacingCalibrated: (evt: Types_2.EventTypes.ImageSpacingCalibratedEvent) => void;
    // (undocumented)
    abstract renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): any;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
class AnnotationFrameRange {
    // (undocumented)
    protected static frameRangeExtractor: RegExp;
    // (undocumented)
    protected static framesToImageId(imageId: string, range: FramesRange | string): string;
    // (undocumented)
    static framesToString(range: any): string;
    // (undocumented)
    static getFrameRange(annotation: Annotation): number | [number, number];
    // (undocumented)
    protected static imageIdToFrames(imageId: string): FramesRange;
    // (undocumented)
    static setFrameRange(annotation: Annotation, range: FramesRange | string, eventBase?: {
        viewportId: any;
        renderingEngineId: any;
    }): void;
}

// @public (undocumented)
class AnnotationGroup {
    constructor();
    // (undocumented)
    add(...annotationUIDs: string[]): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    findNearby(uid: string, direction: 1): string;
    // (undocumented)
    has(uid: string): boolean;
    // (undocumented)
    get isVisible(): boolean;
    // (undocumented)
    remove(...annotationUIDs: string[]): void;
    // (undocumented)
    setVisible(isVisible: boolean, baseEvent: BaseEventDetail, filter?: (annotationUID: string) => boolean): void;
    // (undocumented)
    protected unboundVisibleFilter(uid: string): boolean;
    // (undocumented)
    visibleFilter: (uid: string) => boolean;
}

// @public (undocumented)
type AnnotationGroupSelector = HTMLDivElement | string;

// @public (undocumented)
type AnnotationHandle = Types_2.Point3;

// @public (undocumented)
type AnnotationInterpolationCompletedEventDetail = {
    annotation: InterpolationROIAnnotation;
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type AnnotationInterpolationCompletedEventType = Types_2.CustomEventType<AnnotationInterpolationCompletedEventDetail>;

// @public (undocumented)
type AnnotationInterpolationRemovedEventDetail = {
    annotations: Array<InterpolationROIAnnotation>;
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type AnnotationInterpolationRemovedEventType = Types_2.CustomEventType<AnnotationInterpolationRemovedEventDetail>;

// @public (undocumented)
type AnnotationLockChangeEventDetail = {
    added: Array<Annotation>;
    removed: Array<Annotation>;
    locked: Array<Annotation>;
};

// @public (undocumented)
type AnnotationLockChangeEventType = Types_2.CustomEventType<AnnotationLockChangeEventDetail>;

// @public (undocumented)
type AnnotationModifiedEventDetail = {
    viewportId: string;
    renderingEngineId: string;
    annotation: Annotation;
    changeType?: ChangeTypes;
};

// @public (undocumented)
type AnnotationModifiedEventType = Types_2.CustomEventType<AnnotationModifiedEventDetail>;

// @public (undocumented)
type AnnotationRemovedEventDetail = {
    annotation: Annotation;
    annotationManagerUID: string;
};

// @public (undocumented)
type AnnotationRemovedEventType = Types_2.CustomEventType<AnnotationRemovedEventDetail>;

// @public (undocumented)
type AnnotationRenderContext = {
    enabledElement: Types_2.IEnabledElement;
    targetId: string;
    annotation: Annotation;
    annotationStyle: Record<string, any>;
    svgDrawingHelper: SVGDrawingHelper;
};

// @public (undocumented)
type AnnotationRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type AnnotationRenderedEventType = Types_2.CustomEventType<AnnotationRenderedEventDetail>;

// @public (undocumented)
type Annotations = Array<Annotation>;

// @public (undocumented)
type AnnotationSelectionChangeEventDetail = {
    added: Array<string>;
    removed: Array<string>;
    selection: Array<string>;
};

// @public (undocumented)
type AnnotationSelectionChangeEventType = Types_2.CustomEventType<AnnotationSelectionChangeEventDetail>;

// @public (undocumented)
type AnnotationState = {
    [key: string]: GroupSpecificAnnotations;
};

declare namespace AnnotationStyle {
    export {
        AnnotationStyle_2 as AnnotationStyle,
        ToolStyleConfig,
        StyleConfig,
        StyleSpecifier
    }
}

// @public (undocumented)
type AnnotationStyle_2 = {
    [key in `${Properties}${States}${Modes}`]?: string;
};

// @public (undocumented)
enum AnnotationStyleStates {
    // (undocumented)
    AutoGenerated = "AutoGenerated",
    // (undocumented)
    Default = "",
    // (undocumented)
    Highlighted = "Highlighted",
    // (undocumented)
    Locked = "Locked",
    // (undocumented)
    Selected = "Selected"
}

// @public (undocumented)
export abstract class AnnotationTool extends AnnotationDisplayTool {
    constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps);
    // (undocumented)
    abstract addNewAnnotation(evt: EventTypes_2.InteractionEventType, interactionType: InteractionTypes): Annotation;
    // (undocumented)
    abstract cancel(element: HTMLDivElement): any;
    // (undocumented)
    static createAndAddAnnotation(viewport: any, ...annotationBaseData: any[]): void;
    // (undocumented)
    static createAnnotation(...annotationBaseData: any[]): Annotation;
    // (undocumented)
    static createAnnotationForViewport(viewport: any, ...annotationBaseData: any[]): Annotation;
    // (undocumented)
    protected getAnnotationStyle(context: {
        annotation: Annotation;
        styleSpecifier: StyleSpecifier;
    }): {
        visibility: boolean;
        locked: boolean;
        color: string;
        lineWidth: number;
        lineDash: string;
        lineOpacity: number;
        fillColor: string;
        fillOpacity: number;
        shadow: boolean;
        textbox: Record<string, unknown>;
    };
    // (undocumented)
    getHandleNearImagePoint(element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    getLinkedTextBoxStyle(specifications: StyleSpecifier, annotation?: Annotation): Record<string, unknown>;
    // (undocumented)
    abstract handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: Annotation, handle: ToolHandle, interactionType: InteractionTypes): void;
    // (undocumented)
    abstract isPointNearTool(element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number, interactionType: string): boolean;
    // (undocumented)
    isSuvScaled(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, targetId: string, imageId?: string): boolean;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.MouseMoveEventType, filteredAnnotations?: Annotations) => boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    abstract toolSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: Annotation, interactionType: InteractionTypes, canvasCoords?: Types_2.Point2): void;
}

// @public (undocumented)
class AnnotationToPointData {
    constructor();
    // (undocumented)
    static convert(annotation: any, index: any, metadataProvider: any): {
        ReferencedROINumber: any;
        ROIDisplayColor: number[];
        ContourSequence: any;
    };
    // (undocumented)
    static register(toolClass: any): void;
    // (undocumented)
    static TOOL_NAMES: Record<string, any>;
}

// @public (undocumented)
type AnnotationVisibilityChangeEventDetail = {
    lastHidden: Array<string>;
    lastVisible: Array<string>;
    hidden: Array<string>;
};

// @public (undocumented)
type AnnotationVisibilityChangeEventType = Types_2.CustomEventType<AnnotationVisibilityChangeEventDetail>;

// @public (undocumented)
function areCoplanarContours(firstAnnotation: ContourAnnotation, secondAnnotation: ContourAnnotation): boolean;

// @public (undocumented)
function areSameSegment(firstAnnotation: ContourSegmentationAnnotation, secondAnnotation: ContourSegmentationAnnotation): boolean;

// @public (undocumented)
export class ArrowAnnotateTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => ArrowAnnotation;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _doneChangingTextCallback(element: any, annotation: any, updatedText: any): void;
    // (undocumented)
    doubleClickCallback: (evt: EventTypes_2.TouchTapEventType) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: ArrowAnnotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume(index1: any, index2: any, dimensions: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: ArrowAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: ArrowAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
    // (undocumented)
    touchTapCallback: (evt: EventTypes_2.TouchTapEventType) => void;
}

// @public (undocumented)
interface ArrowAnnotation extends Annotation {
    // (undocumented)
    data: {
        text: string;
        handles: {
            points: Types_2.Point3[];
            arrowFirst: boolean;
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
    };
}

// @public (undocumented)
export abstract class BaseTool implements IBaseTool {
    constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps);
    // (undocumented)
    applyActiveStrategy(enabledElement: Types_2.IEnabledElement, operationData: unknown): any;
    // (undocumented)
    applyActiveStrategyCallback(enabledElement: Types_2.IEnabledElement, operationData: unknown, callbackType: StrategyCallbacks | string): any;
    // (undocumented)
    configuration: Record<string, any>;
    // (undocumented)
    protected getTargetId(viewport: Types_2.IViewport): string | undefined;
    // (undocumented)
    protected getTargetIdImage(targetId: string, renderingEngine: Types_2.IRenderingEngine): Types_2.IImageData | Types_2.CPUIImageData | Types_2.IImageVolume;
    // (undocumented)
    getToolName(): string;
    // (undocumented)
    mode: ToolModes;
    // (undocumented)
    setActiveStrategy(strategyName: string): void;
    // (undocumented)
    setConfiguration(newConfiguration: Record<string, any>): void;
    // (undocumented)
    supportedInteractionTypes: InteractionTypes[];
    // (undocumented)
    toolGroupId: string;
    // (undocumented)
    static toolName: any;
}

declare namespace BasicStatsCalculator {
    export {
        BasicStatsCalculator_2 as BasicStatsCalculator,
        Calculator
    }
}

// @public (undocumented)
class BasicStatsCalculator_2 extends Calculator {
    // (undocumented)
    static getStatistics: () => Statistics[];
    // (undocumented)
    static statsCallback: ({ value: newValue }: {
        value: any;
    }) => void;
}

// @public (undocumented)
interface BidirectionalAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                length: number;
                width: number;
                unit: string;
            };
        };
    };
}

// @public (undocumented)
type BidirectionalData = {
    majorAxis: [Types_2.Point3, Types_2.Point3];
    minorAxis: [Types_2.Point3, Types_2.Point3];
    maxMajor: number;
    maxMinor: number;
    segmentIndex: number;
    label?: string;
    color?: string | number[];
    referencedImageId: string;
    sliceIndex: number;
};

// @public (undocumented)
export class BidirectionalTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation(evt: EventTypes_2.InteractionEventType): BidirectionalAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    _calculateLength(pos1: any, pos2: any): number;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragDrawCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyHandle: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getSignedAngle: (vector1: any, vector2: any) => number;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: BidirectionalAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, index3: any, index4: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: BidirectionalAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _movingLongAxisWouldPutItThroughShortAxis: (firstLineSegment: any, secondLineSegment: any) => boolean;
    // (undocumented)
    preventHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: BidirectionalAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace boundingBox {
    export {
        extend2DBoundingBoxInViewAxis,
        getBoundingBoxAroundShapeIJK,
        getBoundingBoxAroundShapeWorld,
        getBoundingBoxAroundShapeIJK as getBoundingBoxAroundShape
    }
}

// @public (undocumented)
type BoundsIJK_2 = Types_2.BoundsIJK;

// @public (undocumented)
export class BrushTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    acceptPreview(element?: HTMLDivElement): void;
    // (undocumented)
    createEditData(element: any): {
        volumeId: string;
        referencedVolumeId: string;
        segmentsLocked: number[] | [];
        segmentationRepresentationUID: string;
        imageIdReferenceMap?: undefined;
    } | {
        imageIdReferenceMap: Map<string, string>;
        segmentsLocked: number[] | [];
        segmentationRepresentationUID: string;
        volumeId?: undefined;
        referencedVolumeId?: undefined;
    };
    // (undocumented)
    protected getOperationData(element?: any): {
        points: any;
        segmentIndex: number;
        previewColors: any;
        viewPlaneNormal: any;
        toolGroupId: string;
        segmentationId: string;
        segmentationRepresentationUID: string;
        viewUp: any;
        strategySpecificConfiguration: any;
        preview: unknown;
        segmentsLocked: number[];
        imageIdReferenceMap?: Map<string, string>;
        volumeId?: string;
        referencedVolumeId?: string;
    };
    // (undocumented)
    invalidateBrushCursor(): void;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    onSetToolDisabled: (evt: any) => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    onSetToolPassive: (evt: any) => void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.MouseDownActivateEventType) => boolean;
    // (undocumented)
    previewCallback: () => void;
    // (undocumented)
    rejectPreview(element?: HTMLDivElement): void;
    // (undocumented)
    renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    protected updateCursor(evt: EventTypes_2.InteractionEventType): void;
}

// @public (undocumented)
abstract class Calculator {
    // (undocumented)
    static getStatistics: () => Statistics[];
    // (undocumented)
    static run: ({ value }: {
        value: any;
    }) => void;
}

// @public (undocumented)
function calibrateImageSpacing(imageId: string, renderingEngine: Types_2.IRenderingEngine, calibrationOrScale: Types_2.IImageCalibration | number): void;

// @public (undocumented)
export function cancelActiveManipulations(element: HTMLDivElement): string | undefined;

// @public (undocumented)
function canComputeRequestedRepresentation(segmentationRepresentationUID: string): boolean;

// @public (undocumented)
type CanvasCoordinates = [
Types_2.Point2,
Types_2.Point2,
Types_2.Point2,
Types_2.Point2
];

// @public (undocumented)
type CardinalSplineProps = SplineProps & {
    scale?: number;
    fixedScale?: boolean;
};

// @public (undocumented)
enum ChangeTypes {
    // (undocumented)
    Completed = "Completed",
    // (undocumented)
    HandlesUpdated = "HandlesUpdated",
    // (undocumented)
    InitialSetup = "InitialSetup",
    // (undocumented)
    Interaction = "Interaction",
    // (undocumented)
    InterpolationUpdated = "InterpolationUpdated",
    // (undocumented)
    StatsUpdated = "StatsUpdated"
}

// @public (undocumented)
enum ChangeTypes_2 {
    // (undocumented)
    POLYSEG_CONTOUR_TO_LABELMAP = "polySeg/convertContourToVolumeLabelmap",
    // (undocumented)
    POLYSEG_CONTOUR_TO_SURFACE = "polySeg/convertContourToSurface",
    // (undocumented)
    POLYSEG_LABELMAP_TO_SURFACE = "polySeg/convertLabelmapToSurface",
    // (undocumented)
    POLYSEG_SURFACE_TO_LABELMAP = "polySeg/convertSurfacesToVolumeLabelmap",
    // (undocumented)
    SURFACE_CLIPPING = "surfaceClipping"
}

// @public (undocumented)
function checkAndDefineIsLockedProperty(annotation: Annotation): void;

// @public (undocumented)
function checkAndDefineIsVisibleProperty(annotation: Annotation): void;

declare namespace cine {
    export {
        playClip,
        stopClip,
        Events_2 as Events,
        getToolState,
        addToolState
    }
}

// @public (undocumented)
type CinePlayContext = {
    get numScrollSteps(): number;
    get currentStepIndex(): number;
    get frameTimeVectorEnabled(): boolean;
    waitForRenderedCount?: number;
    scroll(delta: number): void;
};

declare namespace CINETypes {
    export {
        PlayClipOptions,
        ToolData,
        CinePlayContext
    }
}

// @public (undocumented)
interface CircleROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: [Types_2.Point3, Types_2.Point3];
            activeHandleIndex: number | null;
            textBox?: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats?: (ROICachedStats & {
            [targetId: string]: {
                radius: number;
                radiusUnit: string;
                perimeter: number;
            };
        }) | {
            pointsInVolume: Types_2.Point3[];
            projectionPoints: Types_2.Point3[][];
        };
    };
}

// @public (undocumented)
interface CircleROIStartEndThresholdAnnotation extends Annotation {
    // (undocumented)
    data: {
        label: string;
        startSlice: number;
        endSlice: number;
        cachedStats?: {
            pointsInVolume: Types_2.Point3[];
            projectionPoints: Types_2.Point3[][];
        };
        handles: {
            points: [Types_2.Point3, Types_2.Point3];
            activeHandleIndex: number | null;
        };
    };
    // (undocumented)
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        annotationUID?: string;
        FrameOfReferenceUID: string;
        referencedImageId?: string;
        toolName: string;
        enabledElement: any;
        volumeId: string;
        spacingInNormal: number;
    };
}

// @public (undocumented)
export class CircleROIStartEndThresholdTool extends CircleROITool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => {
        highlighted: boolean;
        invalidated: boolean;
        metadata: {
            toolName: string;
            viewPlaneNormal: Types_2.Point3;
            viewUp: Types_2.Point3;
            FrameOfReferenceUID: string;
            referencedImageId: any;
            volumeId: any;
            spacingInNormal: number;
            enabledElement: Types_2.IEnabledElement;
        };
        data: {
            label: string;
            startSlice: number;
            endSlice: number;
            handles: {
                textBox: {
                    hasMoved: boolean;
                    worldPosition: any;
                    worldBoundingBox: any;
                };
                points: [Types_2.Point3, Types_2.Point3];
                activeHandleIndex: any;
            };
            cachedStats: {
                pointsInVolume: any[];
                projectionPoints: any[];
            };
            labelmapUID: any;
        };
    };
    // (undocumented)
    _calculateCachedStatsTool(annotation: any, enabledElement: any): any;
    // (undocumented)
    _computePointsInsideVolume(annotation: any, imageVolume: any, enabledElement: any): void;
    // (undocumented)
    _computeProjectionPoints(annotation: CircleROIStartEndThresholdAnnotation, imageVolume: Types_2.IImageVolume): void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getEndSliceIndex(imageVolume: Types_2.IImageVolume, worldPos: Types_2.Point3, spacingInNormal: number, viewPlaneNormal: Types_2.Point3): number | undefined;
    // (undocumented)
    _getImageIdIndex(imageVolume: Types_2.IImageVolume, pos: vec3, spacingInNormal: number, viewPlaneNormal: Types_2.Point3): number | undefined;
    // (undocumented)
    _getStartSliceIndex(imageVolume: Types_2.IImageVolume, worldPos: Types_2.Point3, spacingInNormal: number, viewPlaneNormal: Types_2.Point3): number | undefined;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
export class CircleROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => CircleROIAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewport: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragDrawCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragHandle: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: CircleROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: CircleROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: CircleROIAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
export class CircleScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentIndex: number;
        volumeId: string;
        referencedVolumeId: string;
        imageIdReferenceMap: Map<string, string>;
        segmentsLocked: number[];
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        centerCanvas?: Array<number>;
        segmentationRepresentationUID?: string;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
function clearParentAnnotation(annotation: Annotation): void;

// @public (undocumented)
function clip(a: any, b: any, box: any, da?: any, db?: any): 0 | 1;

// @public (undocumented)
function clip_2(val: number, low: number, high: number): number;

// @public (undocumented)
type ClosestControlPoint = ClosestPoint & {
    index: number;
};

// @public (undocumented)
type ClosestPoint = {
    point: Types_2.Point2;
    distance: number;
};

// @public (undocumented)
type ClosestSplinePoint = ClosestPoint & {
    uValue: number;
};

// @public (undocumented)
interface CobbAngleAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                angle: number;
                arc1Angle: number;
                arc2Angle: number;
                points: {
                    world: {
                        arc1Start: Types_2.Point3;
                        arc1End: Types_2.Point3;
                        arc2Start: Types_2.Point3;
                        arc2End: Types_2.Point3;
                        arc1Angle: number;
                        arc2Angle: number;
                    };
                    canvas: {
                        arc1Start: Types_2.Point2;
                        arc1End: Types_2.Point2;
                        arc2Start: Types_2.Point2;
                        arc2End: Types_2.Point2;
                        arc1Angle: number;
                        arc2Angle: number;
                    };
                };
            };
        };
    };
}

// @public (undocumented)
export class CobbAngleTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => CobbAngleAnnotation;
    // (undocumented)
    angleStartedNotYetCompleted: boolean;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    distanceToLines: ({ viewport, points, canvasCoords, proximity }: {
        viewport: any;
        points: any;
        canvasCoords: any;
        proximity: any;
    }) => {
        distanceToPoint: number;
        distanceToPoint2: number;
        isNearFirstLine: boolean;
        isNearSecondLine: boolean;
    };
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        isNearFirstLine?: boolean;
        isNearSecondLine?: boolean;
    } | null;
    // (undocumented)
    getArcsStartEndPoints: ({ firstLine, secondLine, mid1, mid2, }: {
        firstLine: any;
        secondLine: any;
        mid1: any;
        mid2: any;
    }) => {
        arc1Start: Types_2.Point2;
        arc1End: Types_2.Point2;
        arc2Start: Types_2.Point2;
        arc2End: Types_2.Point2;
        arc1Angle: number;
        arc2Angle: number;
    };
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: CobbAngleAnnotation, handle: ToolHandle, interactionType?: string): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: CobbAngleAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    _mouseDownCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType | EventTypes_2.MouseMoveEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: CobbAngleAnnotation, interactionType: InteractionTypes, canvasCoords: Types_2.Point2, proximity?: number) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace color {
    export {
        getColorForSegmentIndex,
        addColorLUT_2 as addColorLUT,
        setColorLUT,
        setColorForSegmentIndex
    }
}

// @public (undocumented)
class Colorbar extends Widget {
    constructor(props: ColorbarProps);
    // (undocumented)
    get activeColormapName(): string;
    set activeColormapName(colormapName: string);
    // (undocumented)
    protected createRootElement(): HTMLElement;
    // (undocumented)
    _createTicksBar(props: ColorbarProps): ColorbarTicks;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    protected getVOIMultipliers(): [number, number];
    // (undocumented)
    protected hideTicks(): void;
    // (undocumented)
    get imageRange(): ColorbarVOIRange;
    set imageRange(imageRange: ColorbarVOIRange);
    // (undocumented)
    protected onContainerResize(): void;
    // (undocumented)
    protected onVoiChange(voiRange: ColorbarVOIRange): void;
    // (undocumented)
    get showFullImageRange(): boolean;
    set showFullImageRange(value: boolean);
    // (undocumented)
    protected showTicks(): void;
    // (undocumented)
    get voiRange(): ColorbarVOIRange;
    set voiRange(voiRange: ColorbarVOIRange);
}

declare namespace colorbar {
    export {
        Types_3 as Types,
        Enums_2 as Enums,
        Colorbar,
        ViewportColorbar
    }
}

// @public (undocumented)
type ColorbarCommonProps = {
    imageRange?: ColorbarImageRange;
    voiRange?: ColorbarVOIRange;
    ticks?: {
        position?: ColorbarRangeTextPosition;
        style?: ColorbarTicksStyle;
    };
    showFullPixelValueRange?: boolean;
};

// @public (undocumented)
type ColorbarImageRange = {
    lower: number;
    upper: number;
};

// @public (undocumented)
type ColorbarProps = (WidgetProps & ColorbarCommonProps) & {
    colormaps: IColorMapPreset[];
    activeColormapName?: string;
};

// @public (undocumented)
enum ColorbarRangeTextPosition {
    // (undocumented)
    Bottom = "bottom",
    // (undocumented)
    Left = "left",
    // (undocumented)
    Right = "right",
    // (undocumented)
    Top = "top"
}

// @public (undocumented)
type ColorbarSize = {
    width: number;
    height: number;
};

// @public (undocumented)
type ColorbarTicksProps = ColorbarCommonProps & {
    top?: number;
    left?: number;
    size?: ColorbarSize;
    container?: HTMLElement;
};

// @public (undocumented)
type ColorbarTicksStyle = {
    font?: string;
    color?: string;
    tickSize?: number;
    tickWidth?: number;
    labelMargin?: number;
    maxNumTicks?: number;
};

// @public (undocumented)
type ColorbarVOIRange = ColorbarImageRange;

// @public (undocumented)
function computeAndAddContourRepresentation(segmentationId: string, options?: PolySegConversionOptions): Promise<{
    annotationUIDsMap: Map<number, Set<string>>;
}>;

// @public (undocumented)
function computeAndAddLabelmapRepresentation(segmentationId: string, options?: PolySegConversionOptions): Promise<RawLabelmapData>;

// @public (undocumented)
function computeAndAddSurfaceRepresentation(segmentationId: string, options?: PolySegConversionOptions): Promise<{
    geometryIds: Map<number, string>;
}>;

declare namespace config {
    export {
        getState,
        getFont,
        toolStyle as style
    }
}

declare namespace config_2 {
    export {
        color,
        visibility_2 as visibility,
        getGlobalConfig_2 as getGlobalConfig,
        getGlobalRepresentationConfig,
        getToolGroupSpecificConfig_2 as getToolGroupSpecificConfig,
        setGlobalConfig_2 as setGlobalConfig,
        setGlobalRepresentationConfig,
        setToolGroupSpecificConfig_2 as setToolGroupSpecificConfig,
        setSegmentSpecificConfig,
        getSegmentSpecificConfig,
        setSegmentationRepresentationSpecificConfig_2 as setSegmentationRepresentationSpecificConfig,
        getSegmentationRepresentationSpecificConfig_2 as getSegmentationRepresentationSpecificConfig
    }
}

declare namespace CONSTANTS {
    export {
        CORNERSTONE_COLOR_LUT as COLOR_LUT
    }
}
export { CONSTANTS }

// @public (undocumented)
function containsPoint(polyline: Types_2.Point2[], point: Types_2.Point2, options?: {
    closed?: boolean;
    holes?: Types_2.Point2[][];
}): boolean;

// @public (undocumented)
function containsPoints(polyline: Types_2.Point2[], points: Types_2.Point2[]): boolean;

// @public (undocumented)
function contourAndFindLargestBidirectional(segmentation: any): any;

// @public (undocumented)
type ContourAnnotation = Annotation & ContourAnnotationData;

// @public (undocumented)
type ContourAnnotationCompletedEventDetail = AnnotationCompletedEventDetail & {
    contourHoleProcessingEnabled: boolean;
};

// @public (undocumented)
type ContourAnnotationData = {
    data: {
        contour: {
            polyline: Types_2.Point3[];
            closed: boolean;
            windingDirection?: ContourWindingDirection;
        };
    };
    onInterpolationComplete?: () => void;
};

declare namespace contours {
    export {
        areCoplanarContours,
        _default_2 as contourFinder,
        getDeduplicatedVTKPolyDataPoints,
        _default_3 as detectContourHoles,
        generateContourSetsFromLabelmap,
        AnnotationToPointData,
        getContourHolesDataWorld,
        getContourHolesDataCanvas,
        updateContourPolyline,
        interpolation,
        acceptAutogeneratedInterpolations,
        findHandlePolylineIndex
    }
}

declare namespace contourSegmentation {
    export {
        areSameSegment,
        isContourSegmentationAnnotation,
        addContourSegmentationAnnotation,
        removeContourSegmentationAnnotation
    }
}

// @public (undocumented)
type ContourSegmentationAnnotation = ContourAnnotation & ContourSegmentationAnnotationData;

// @public (undocumented)
type ContourSegmentationAnnotationData = {
    autoGenerated?: boolean;
    interpolationUID?: string;
    interpolationCompleted?: boolean;
    data: {
        segmentation: {
            segmentationId: string;
            segmentIndex: number;
        };
        contour: {
            originalPolyline?: Types_2.Point3[];
        };
    };
    metadata?: {
        originalToolName?: string;
    };
    handles?: {
        interpolationSources?: Types_2.PointsManager<Types_2.Point3>[];
    };
    onInterpolationComplete?: (annotation: ContourSegmentationAnnotation) => unknown;
};

// @public (undocumented)
type ContourSegmentationData = {
    geometryIds?: string[];
    annotationUIDsMap?: Map<number, Set<string>>;
};

// @public (undocumented)
type ControlPointInfo = {
    index: number;
    point: Types_2.Point2;
};

// @public (undocumented)
function convertStackToVolumeSegmentation({ segmentationId, options, }: {
    segmentationId: string;
    options?: {
        toolGroupId: string;
        volumeId?: string;
        removeOriginal?: boolean;
    };
}): Promise<void>;

// @public (undocumented)
function convertVolumeToStackSegmentation({ segmentationId, options, }: {
    segmentationId: string;
    options?: {
        toolGroupId: string;
        newSegmentationId?: string;
        removeOriginal?: boolean;
    };
}): Promise<void>;

// @public (undocumented)
function copyPoints(points: ITouchPoints): ITouchPoints;

// @public (undocumented)
function copyPointsList(points: ITouchPoints[]): ITouchPoints[];

// @public (undocumented)
const CORNERSTONE_COLOR_LUT: number[][];

// @public (undocumented)
function createBidirectionalToolData(bidirectionalData: BidirectionalData, viewport: any): Annotation;

// @public (undocumented)
function createCameraPositionSynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
function createImageIdReferenceMap(imageIdsArray: string[], segmentationImageIds: string[]): Map<string, string>;

// @public (undocumented)
function createImageSliceSynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
function createLabelmapVolumeForViewport(input: {
    viewportId: string;
    renderingEngineId: string;
    segmentationId?: string;
    options?: {
        volumeId?: string;
        scalarData?: Float32Array | Uint8Array | Uint16Array | Int16Array;
        targetBuffer?: {
            type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';
        };
        metadata?: any;
        dimensions?: Types_2.Point3;
        spacing?: Types_2.Point3;
        origin?: Types_2.Point3;
        direction?: Float32Array;
    };
}): Promise<string>;

// @public (undocumented)
function createMergedLabelmapForIndex(labelmaps: Array<Types_2.IImageVolume>, segmentIndex?: number, volumeId?: string): Types_2.IImageVolume;

// @public (undocumented)
const createStackImageSynchronizer: typeof createImageSliceSynchronizer;

// @public (undocumented)
function createSynchronizer(synchronizerId: string, eventName: string, eventHandler: ISynchronizerEventHandler, options?: any): Synchronizer;

// @public (undocumented)
function createToolGroup(toolGroupId: string): IToolGroup | undefined;

// @public (undocumented)
function createVOISynchronizer(synchronizerName: string, options?: VOISynchronizerOptions): Synchronizer;

// @public (undocumented)
function createZoomPanSynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
export class CrosshairsTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => CrosshairsAnnotation;
    // (undocumented)
    _applyDeltaShiftToSelectedViewportCameras(renderingEngine: any, viewportsAnnotationsToUpdate: any, delta: any): void;
    // (undocumented)
    _applyDeltaShiftToViewportCamera(renderingEngine: Types_2.IRenderingEngine, annotation: any, delta: any): void;
    // (undocumented)
    _areViewportIdArraysEqual: (viewportIdArrayOne: any, viewportIdArrayTwo: any) => boolean;
    // (undocumented)
    _autoPanViewportIfNecessary(viewportId: string, renderingEngine: Types_2.IRenderingEngine): void;
    // (undocumented)
    cancel: () => void;
    // (undocumented)
    _checkIfViewportsRenderingSameScene: (viewport: any, otherViewport: any) => boolean;
    // (undocumented)
    computeToolCenter: (viewportsInfo: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _filterAnnotationsByUniqueViewportOrientations: (enabledElement: any, annotations: any) => any[];
    // (undocumented)
    filterInteractableAnnotationsForElement: (element: any, annotations: any) => any;
    // (undocumented)
    _filterViewportWithSameOrientation: (enabledElement: any, referenceAnnotation: any, annotations: any) => any;
    // (undocumented)
    _getAnnotations: (enabledElement: Types_2.IEnabledElement) => Annotation[];
    // (undocumented)
    _getAnnotationsForViewportsWithDifferentCameras: (enabledElement: any, annotations: any) => any;
    // (undocumented)
    getHandleNearImagePoint(element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    _getReferenceLineColor?: (viewportId: string) => string;
    // (undocumented)
    _getReferenceLineControllable?: (viewportId: string) => boolean;
    // (undocumented)
    _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;
    // (undocumented)
    _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;
    // (undocumented)
    _getRotationHandleNearImagePoint(viewport: any, annotation: any, canvasCoords: any, proximity: any): any;
    // (undocumented)
    _getSlabThicknessHandleNearImagePoint(viewport: any, annotation: any, canvasCoords: any, proximity: any): any;
    // (undocumented)
    _getViewportsInfo: () => Types_2.IViewportId[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: Annotation) => void;
    // (undocumented)
    initializeViewport: ({ renderingEngineId, viewportId, }: Types_2.IViewportId) => {
        normal: Types_2.Point3;
        point: Types_2.Point3;
    };
    // (undocumented)
    _isClockWise(a: any, b: any, c: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: CrosshairsAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    _jump: (enabledElement: any, jumpWorld: any) => boolean;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.MouseMoveEventType, filteredToolAnnotations: Annotations) => boolean;
    // (undocumented)
    onCameraModified: (evt: any) => void;
    // (undocumented)
    _onNewVolume: (e: any) => void;
    // (undocumented)
    onSetToolActive(): void;
    // (undocumented)
    onSetToolDisabled(): void;
    // (undocumented)
    onSetToolEnabled(): void;
    // (undocumented)
    onSetToolPassive(): void;
    // (undocumented)
    _pointNearReferenceLine: (annotation: any, canvasCoords: any, proximity: any, lineViewport: any) => boolean;
    // (undocumented)
    _pointNearTool(element: any, annotation: any, canvasCoords: any, proximity: any): boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    setSlabThickness(viewport: any, slabThickness: any): void;
    // (undocumented)
    _subscribeToViewportNewVolumeSet(viewports: any): void;
    // (undocumented)
    toolCenter: Types_2.Point3;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: Annotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    _unsubscribeToViewportNewVolumeSet(viewportsInfo: any): void;
}

// @public (undocumented)
const CursorNames: string[];

declare namespace cursors {
    export {
        MouseCursor,
        ImageMouseCursor,
        SVGMouseCursor,
        elementCursor,
        registerCursor,
        CursorNames,
        CursorSVG,
        setCursorForElement
    }
}
export { cursors }

// @public (undocumented)
const CursorSVG: Record<string, SVGCursorDescriptor>;

// @public (undocumented)
function debounce(func: Function, wait?: number, options?: {
    leading?: boolean;
    maxWait?: number;
    trailing?: boolean;
}): Function;

// @public (undocumented)
function decimate(polyline: Types_2.Point2[], epsilon?: number): Types_2.Point2[];

// @public (undocumented)
const _default: {
    filterAnnotationsWithinSlice: typeof filterAnnotationsWithinSlice;
    getWorldWidthAndHeightFromCorners: typeof getWorldWidthAndHeightFromCorners;
    filterAnnotationsForDisplay: typeof filterAnnotationsForDisplay;
    getPointInLineOfSightWithCriteria: typeof getPointInLineOfSightWithCriteria;
    isPlaneIntersectingAABB: (origin: any, normal: any, minX: any, minY: any, minZ: any, maxX: any, maxY: any, maxZ: any) => boolean;
};

// @public (undocumented)
const _default_2: {
    findContours: typeof findContours;
    findContoursFromReducedSet: typeof findContoursFromReducedSet;
};

// @public (undocumented)
const _default_3: {
    processContourHoles: typeof processContourHoles;
};

// @public (undocumented)
const _default_4: {
    smoothAnnotation: typeof smoothAnnotation;
};

// @public (undocumented)
function deselectAnnotation(annotationUID?: string): void;

// @public (undocumented)
export function destroy(): void;

// @public (undocumented)
function destroy_2(): void;

// @public (undocumented)
function destroy_3(): void;

// @public (undocumented)
function destroySynchronizer(synchronizerId: string): void;

// @public (undocumented)
function destroyToolGroup(toolGroupId: string): void;

// @public (undocumented)
function distanceToPoint(aabb: Types_2.AABB2, point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPoint_2(lineStart: Types_2.Point2, lineEnd: Types_2.Point2, point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPoint_3(p1: Point, p2: Point): number;

// @public (undocumented)
function distanceToPoint_4(rect: number[], point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPointSquared(aabb: Types_2.AABB2, point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPointSquared_2(lineStart: Types_2.Point2, lineEnd: Types_2.Point2, point: Types_2.Point2): number;

// @public (undocumented)
function distanceToPointSquared_3(p1: Point_2, p2: Point_2): number;

// @public (undocumented)
function distanceToPointSquaredInfo(lineStart: Types_2.Point2, lineEnd: Types_2.Point2, point: Types_2.Point2): {
    point: Types_2.Point2;
    distanceSquared: number;
};

// @public (undocumented)
export class DragProbeTool extends ProbeTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        newAnnotation?: boolean;
    } | null;
    // (undocumented)
    eventDispatchDetail: {
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    postMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => ProbeAnnotation;
    // (undocumented)
    postTouchStartCallback: (evt: EventTypes_2.InteractionEventType) => ProbeAnnotation;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function draw(element: HTMLDivElement, fn: (svgDrawingElement: any) => any): void;

// @public (undocumented)
function drawArrow(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, arrowUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}): void;

// @public (undocumented)
function drawCircle(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, circleUID: string, center: Types_2.Point2, radius: number, options?: {}, dataId?: string): void;

// @public (undocumented)
function drawEllipse(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, ellipseUID: string, corner1: Types_2.Point2, corner2: Types_2.Point2, options?: {}, dataId?: string): void;

// @public (undocumented)
function drawEllipseByCoordinates(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, ellipseUID: string, canvasCoordinates: [Types_2.Point2, Types_2.Point2, Types_2.Point2, Types_2.Point2], options?: {}, dataId?: string): void;

// @public (undocumented)
function drawHandle(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, handleGroupUID: string, handle: Types_2.Point2, options: {}, uniqueIndex: any): void;

// @public (undocumented)
function drawHandles(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, handleGroupUID: string, handlePoints: Array<Types_2.Point2>, options?: {}): void;

declare namespace drawing {
    export {
        draw,
        drawCircle,
        drawEllipse,
        drawEllipseByCoordinates,
        drawHandles,
        drawHandle,
        drawLine,
        drawPolyline,
        drawPath,
        drawLinkedTextBox,
        drawRect,
        drawTextBox,
        drawArrow,
        drawRedactionRect,
        setAttributesIfNecessary,
        setNewAttributesIfValid
    }
}
export { drawing }

declare namespace drawing_2 {
    export {
        getTextBoxCoordsCanvas
    }
}

// @public (undocumented)
function drawLine(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, lineUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}, dataId?: string): void;

// @public (undocumented)
function drawLinkedTextBox(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, textBoxUID: string, textLines: Array<string>, textBoxPosition: Types_2.Point2, annotationAnchorPoints: Array<Types_2.Point2>, textBox: unknown, options?: {}): SVGRect;

// @public (undocumented)
function drawPath(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, pathUID: string, points: Types_2.Point2[] | Types_2.Point2[][], options: {
    color?: string;
    fillColor?: string;
    fillOpacity?: number;
    width?: number;
    lineWidth?: number;
    lineDash?: string;
    closePath?: boolean;
}): void;

// @public (undocumented)
function drawPolyline(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, polylineUID: string, points: Types_2.Point2[], options: {
    color?: string;
    fillColor?: string;
    fillOpacity?: number;
    width?: number;
    lineWidth?: number;
    lineDash?: string;
    closePath?: boolean;
}): void;

// @public (undocumented)
function drawRect(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, rectangleUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}, dataId?: string): void;

// @public (undocumented)
function drawRedactionRect(svgDrawingHelper: any, annotationUID: string, rectangleUID: string, start: any, end: any, options?: {}): void;

// @public (undocumented)
function drawTextBox(svgDrawingHelper: SVGDrawingHelper, annotationUID: string, textUID: string, textLines: Array<string>, position: Types_2.Point2, options?: {}): SVGRect;

declare namespace dynamicVolume {
    export {
        getDataInTime,
        generateImageFromTimeData
    }
}

declare namespace elementCursor {
    export {
        initElementCursor,
        resetElementCursor,
        hideElementCursor,
        _setElementCursor as setElementCursor
    }
}

declare namespace ellipse {
    export {
        pointInEllipse,
        precalculatePointInEllipse,
        getCanvasEllipseCorners
    }
}

// @public (undocumented)
interface EllipticalROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: [Types_2.Point3, Types_2.Point3, Types_2.Point3, Types_2.Point3];
            activeHandleIndex: number | null;
            textBox?: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats?: ROICachedStats;
        initialRotation: number;
    };
}

// @public (undocumented)
export class EllipticalROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => EllipticalROIAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewport: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragDrawCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragHandle: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragModifyCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        movingTextBox?: boolean;
        centerWorld?: Array<number>;
        canvasWidth?: number;
        canvasHeight?: number;
        originalHandleCanvas?: Array<number>;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getCanvasEllipseCenter(ellipseCanvasPoints: Types_2.Point2[]): Types_2.Point2;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: EllipticalROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: EllipticalROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _pointInEllipseCanvas(ellipse: any, location: Types_2.Point2): boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: EllipticalROIAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace Enums {
    export {
        MouseBindings,
        KeyboardBindings,
        ToolModes,
        AnnotationStyleStates,
        Events,
        SegmentationRepresentations,
        Swipe,
        StrategyCallbacks,
        ChangeTypes,
        ChangeTypes_2 as WorkerTypes
    }
}
export { Enums }

declare namespace Enums_2 {
    export {
        ColorbarRangeTextPosition
    }
}

// @public (undocumented)
export class EraserTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _deleteNearbyAnnotations(evt: EventTypes_2.InteractionEventType, interactionType: string): boolean;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    preTouchStartCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
enum Events {
    // (undocumented)
    ANNOTATION_ADDED = "CORNERSTONE_TOOLS_ANNOTATION_ADDED",
    // (undocumented)
    ANNOTATION_COMPLETED = "CORNERSTONE_TOOLS_ANNOTATION_COMPLETED",
    // (undocumented)
    ANNOTATION_INTERPOLATION_PROCESS_COMPLETED = "CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED",
    // (undocumented)
    ANNOTATION_LOCK_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE",
    // (undocumented)
    ANNOTATION_MODIFIED = "CORNERSTONE_TOOLS_ANNOTATION_MODIFIED",
    // (undocumented)
    ANNOTATION_REMOVED = "CORNERSTONE_TOOLS_ANNOTATION_REMOVED",
    // (undocumented)
    ANNOTATION_RENDERED = "CORNERSTONE_TOOLS_ANNOTATION_RENDERED",
    // (undocumented)
    ANNOTATION_SELECTION_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE",
    // (undocumented)
    ANNOTATION_VISIBILITY_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE",
    // (undocumented)
    INTERPOLATED_ANNOTATIONS_REMOVED = "CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED",
    // (undocumented)
    KEY_DOWN = "CORNERSTONE_TOOLS_KEY_DOWN",
    // (undocumented)
    KEY_UP = "CORNERSTONE_TOOLS_KEY_UP",
    // (undocumented)
    MOUSE_CLICK = "CORNERSTONE_TOOLS_MOUSE_CLICK",
    // (undocumented)
    MOUSE_DOUBLE_CLICK = "CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK",
    // (undocumented)
    MOUSE_DOWN = "CORNERSTONE_TOOLS_MOUSE_DOWN",
    // (undocumented)
    MOUSE_DOWN_ACTIVATE = "CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE",
    // (undocumented)
    MOUSE_DRAG = "CORNERSTONE_TOOLS_MOUSE_DRAG",
    // (undocumented)
    MOUSE_MOVE = "CORNERSTONE_TOOLS_MOUSE_MOVE",
    // (undocumented)
    MOUSE_UP = "CORNERSTONE_TOOLS_MOUSE_UP",
    // (undocumented)
    MOUSE_WHEEL = "CORNERSTONE_TOOLS_MOUSE_WHEEL",
    // (undocumented)
    SEGMENTATION_DATA_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED",
    // (undocumented)
    SEGMENTATION_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED",
    // (undocumented)
    SEGMENTATION_REMOVED = "CORNERSTONE_TOOLS_SEGMENTATION_REMOVED",
    // (undocumented)
    SEGMENTATION_RENDERED = "CORNERSTONE_TOOLS_SEGMENTATION_RENDERED",
    // (undocumented)
    SEGMENTATION_REPRESENTATION_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED",
    // (undocumented)
    SEGMENTATION_REPRESENTATION_REMOVED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED",
    // (undocumented)
    TOOL_ACTIVATED = "CORNERSTONE_TOOLS_TOOL_ACTIVATED",
    // (undocumented)
    TOOL_MODE_CHANGED = "CORNERSTONE_TOOLS_TOOL_MODE_CHANGED",
    // (undocumented)
    TOUCH_DRAG = "CORNERSTONE_TOOLS_TOUCH_DRAG",
    // (undocumented)
    TOUCH_END = "CORNERSTONE_TOOLS_TOUCH_END",
    // (undocumented)
    TOUCH_PRESS = "CORNERSTONE_TOOLS_TOUCH_PRESS",
    // (undocumented)
    TOUCH_START = "CORNERSTONE_TOOLS_TOUCH_START",
    // (undocumented)
    TOUCH_START_ACTIVATE = "CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE",
    // (undocumented)
    TOUCH_SWIPE = "CORNERSTONE_TOOLS_SWIPE",
    // (undocumented)
    TOUCH_TAP = "CORNERSTONE_TOOLS_TAP"
}

// @public (undocumented)
enum Events_2 {
    // (undocumented)
    CLIP_STARTED = "CORNERSTONE_CINE_TOOL_STARTED",
    // (undocumented)
    CLIP_STOPPED = "CORNERSTONE_CINE_TOOL_STOPPED"
}

declare namespace EventTypes_2 {
    export {
        InteractionStartType,
        InteractionEndType,
        InteractionEventType,
        NormalizedInteractionEventDetail,
        NormalizedMouseEventType,
        NormalizedTouchEventType,
        ToolModeChangedEventDetail,
        ToolModeChangedEventType,
        ToolActivatedEventDetail,
        ToolActivatedEventType,
        AnnotationAddedEventDetail,
        AnnotationAddedEventType,
        AnnotationCompletedEventDetail,
        AnnotationCompletedEventType,
        AnnotationModifiedEventDetail,
        AnnotationModifiedEventType,
        AnnotationRemovedEventDetail,
        AnnotationRemovedEventType,
        AnnotationSelectionChangeEventDetail,
        AnnotationSelectionChangeEventType,
        AnnotationRenderedEventDetail,
        AnnotationRenderedEventType,
        AnnotationLockChangeEventDetail,
        AnnotationVisibilityChangeEventDetail,
        AnnotationLockChangeEventType,
        AnnotationVisibilityChangeEventType,
        AnnotationInterpolationCompletedEventDetail,
        AnnotationInterpolationCompletedEventType,
        AnnotationInterpolationRemovedEventDetail,
        AnnotationInterpolationRemovedEventType,
        ContourAnnotationCompletedEventDetail,
        SegmentationDataModifiedEventType,
        SegmentationRepresentationModifiedEventDetail,
        SegmentationRepresentationModifiedEventType,
        SegmentationRepresentationRemovedEventDetail,
        SegmentationRepresentationRemovedEventType,
        SegmentationRemovedEventType,
        SegmentationRemovedEventDetail,
        SegmentationDataModifiedEventDetail,
        SegmentationRenderedEventType,
        SegmentationRenderedEventDetail,
        SegmentationModifiedEventType,
        SegmentationModifiedEventDetail,
        KeyDownEventDetail,
        KeyDownEventType,
        KeyUpEventDetail,
        KeyUpEventType,
        MouseDownEventDetail,
        TouchStartEventDetail,
        MouseDownEventType,
        TouchStartEventType,
        MouseDownActivateEventDetail,
        TouchStartActivateEventDetail,
        MouseDownActivateEventType,
        TouchStartActivateEventType,
        MouseDragEventDetail,
        TouchDragEventDetail,
        MouseDragEventType,
        TouchDragEventType,
        MouseUpEventDetail,
        TouchEndEventDetail,
        MouseUpEventType,
        TouchEndEventType,
        MouseClickEventDetail,
        MouseClickEventType,
        TouchTapEventDetail,
        TouchTapEventType,
        TouchSwipeEventDetail,
        TouchSwipeEventType,
        TouchPressEventDetail,
        TouchPressEventType,
        MouseMoveEventDetail,
        MouseMoveEventType,
        MouseDoubleClickEventDetail,
        MouseDoubleClickEventType,
        MouseWheelEventDetail,
        MouseWheelEventType,
        VolumeScrollOutOfBoundsEventDetail,
        VolumeScrollOutOfBoundsEventType
    }
}

// @public (undocumented)
function extend2DBoundingBoxInViewAxis(boundsIJK: [Types_2.Point2, Types_2.Point2, Types_2.Point2], numSlicesToProject: number): [Types_2.Point2, Types_2.Point2, Types_2.Point2];

// @public (undocumented)
function filterAnnotationsForDisplay(viewport: Types_2.IViewport, annotations: Annotations, filterOptions?: Types_2.ReferenceCompatibleOptions): Annotations;

// @public (undocumented)
function filterAnnotationsWithinSlice(annotations: Annotations, camera: Types_2.ICamera, spacingInNormalDirection: number): Annotations;

// @public (undocumented)
function filterViewportsWithFrameOfReferenceUID(viewports: Array<Types_2.IViewport>, FrameOfReferenceUID: string): Array<Types_2.IStackViewport | Types_2.IVolumeViewport>;

// @public (undocumented)
function filterViewportsWithParallelNormals(viewports: any, camera: any, EPS?: number): any;

// @public (undocumented)
function filterViewportsWithToolEnabled(viewports: Array<Types_2.IViewport>, toolName: string): Array<Types_2.IStackViewport | Types_2.IVolumeViewport>;

// @public (undocumented)
function findClosestPoint(sourcePoints: Array<Types_2.Point2>, targetPoint: Types_2.Point2): Types_2.Point2;

// @public (undocumented)
function findHandlePolylineIndex(annotation: ContourAnnotation, handleIndex: number): number;

// @public (undocumented)
function findSegmentationRepresentationByUID(segmentationRepresentationUID: string): {
    toolGroupId: string;
    segmentationRepresentation: ToolGroupSpecificRepresentation;
};

// @public (undocumented)
function floodFill(getter: FloodFillGetter, seed: Types_2.Point2 | Types_2.Point3, options?: FloodFillOptions): FloodFillResult;

// @public (undocumented)
type FloodFillGetter = FloodFillGetter2D | FloodFillGetter3D;

// @public (undocumented)
type FloodFillOptions = {
    onFlood?: (x: number, y: number, z?: number) => void;
    onBoundary?: (x: number, y: number, z?: number) => void;
    equals?: (a: any, b: any) => boolean;
    diagonals?: boolean;
};

// @public (undocumented)
type FloodFillResult = {
    flooded: Types_2.Point2[] | Types_2.Point3[];
    boundaries: Types_2.Point2[] | Types_2.Point3[];
};

// @public (undocumented)
class FrameOfReferenceSpecificAnnotationManager implements IAnnotationManager {
    constructor(uid?: string);
    // (undocumented)
    addAnnotation: (annotation: Annotation, groupKey?: string) => void;
    // (undocumented)
    getAllAnnotations: () => Annotations;
    // (undocumented)
    getAnnotation: (annotationUID: string) => Annotation | undefined;
    // (undocumented)
    getAnnotations: (groupKey: string, toolName?: string) => GroupSpecificAnnotations | Annotations;
    // (undocumented)
    getFramesOfReference: () => Array<string>;
    // (undocumented)
    getGroupKey: (annotationGroupSelector: AnnotationGroupSelector) => string;
    // (undocumented)
    getNumberOfAllAnnotations: () => number;
    // (undocumented)
    getNumberOfAnnotations: (groupKey: string, toolName?: string) => number;
    // (undocumented)
    _imageVolumeModifiedHandler: (evt: Types_2.EventTypes.ImageVolumeModifiedEvent) => void;
    // (undocumented)
    removeAllAnnotations: () => void;
    // (undocumented)
    removeAnnotation: (annotationUID: string) => void;
    // (undocumented)
    removeAnnotations: (groupKey: string, toolName?: string) => void;
    // (undocumented)
    restoreAnnotations: (state: AnnotationState | GroupSpecificAnnotations | Annotations, groupKey?: string, toolName?: string) => void;
    // (undocumented)
    saveAnnotations: (groupKey?: string, toolName?: string) => AnnotationState | GroupSpecificAnnotations | Annotations;
    // (undocumented)
    readonly uid: string;
}

// @public (undocumented)
function generateContourSetsFromLabelmap({ segmentations }: {
    segmentations: any;
}): any[];

// @public (undocumented)
function generateImageFromTimeData(dynamicVolume: Types_2.IDynamicImageVolume, operation: string, frameNumbers?: number[]): Float32Array;

// @public (undocumented)
function getAABB(polyline: Types_2.Point2[] | Types_2.Point3[] | number[], options?: {
    numDimensions: number;
}): Types_2.AABB2 | Types_2.AABB3;

// @public (undocumented)
function getActiveSegmentation(toolGroupId: string): Segmentation;

// @public (undocumented)
function getActiveSegmentationRepresentation(toolGroupId: string): ToolGroupSpecificRepresentation;

// @public (undocumented)
function getActiveSegmentIndex(segmentationId: string): number | undefined;

// @public (undocumented)
function getAllAnnotations(): Annotations;

// @public (undocumented)
function getAllSegmentationRepresentations(): Record<string, ToolGroupSpecificRepresentation[]>;

// @public (undocumented)
function getAllSynchronizers(): Array<Synchronizer>;

// @public (undocumented)
function getAllToolGroups(): Array<IToolGroup>;

// @public (undocumented)
function getAnnotation(annotationUID: string): Annotation;

// @public (undocumented)
function getAnnotationManager(): FrameOfReferenceSpecificAnnotationManager;

// @public (undocumented)
function getAnnotationNearPoint(element: HTMLDivElement, canvasPoint: Types_2.Point2, proximity?: number): Annotation | null;

// @public (undocumented)
function getAnnotationNearPointOnEnabledElement(enabledElement: Types_2.IEnabledElement, point: Types_2.Point2, proximity: number): Annotation | null;

// @public (undocumented)
function getAnnotations(toolName: string, annotationGroupSelector: AnnotationGroupSelector): Annotations;

// @public (undocumented)
function getAnnotationsLocked(): Array<Annotation>;

// @public (undocumented)
function getAnnotationsLockedCount(): number;

// @public (undocumented)
function getAnnotationsSelected(): Array<string>;

// @public (undocumented)
function getAnnotationsSelectedByToolName(toolName: string): Array<string>;

// @public (undocumented)
function getAnnotationsSelectedCount(): number;

// @public (undocumented)
function getArea(points: Types_2.Point2[]): number;

// @public (undocumented)
function getBoundingBoxAroundShapeIJK(points: Types_2.Point2[] | Types_2.Point3[], dimensions?: Types_2.Point2 | Types_2.Point3): BoundingBox;

// @public (undocumented)
function getBoundingBoxAroundShapeWorld(points: Types_2.Point2[] | Types_2.Point3[], clipBounds?: Types_2.Point2 | Types_2.Point3): BoundingBox;

// @public (undocumented)
function getBoundsIJKFromRectangleAnnotations(annotations: any, referenceVolume: any, options?: Options_3): any;

// @public (undocumented)
function getBrushSizeForToolGroup(toolGroupId: string, toolName?: string): void;

// @public (undocumented)
function getBrushThresholdForToolGroup(toolGroupId: string): any;

// @public (undocumented)
const getCalibratedAreaUnits: (handles: any, image: any) => string;

// @public (undocumented)
const getCalibratedLengthUnits: (handles: any, image: any) => string;

// @public (undocumented)
const getCalibratedScale: (image: any, handles?: any[]) => any;

// @public (undocumented)
function getCanvasEllipseCorners(ellipseCanvasPoints: CanvasCoordinates): Array<Types_2.Point2>;

// @public (undocumented)
function getChildAnnotations(annotation: Annotation): Annotation[];

// @public (undocumented)
function getClosestLineSegmentIntersection(points: Types_2.Point2[], p1: Types_2.Point2, q1: Types_2.Point2, closed?: boolean): {
    segment: Types_2.Point2;
    distance: number;
} | undefined;

// @public (undocumented)
function getColorForSegmentIndex(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number): Types_2.Color;

// @public (undocumented)
function getColorLUT(index: number): Types_2.ColorLUT | undefined;

// @public (undocumented)
function getContourHolesDataCanvas(annotation: Annotation, viewport: Types_2.IViewport): Types_2.Point2[][];

// @public (undocumented)
function getContourHolesDataWorld(annotation: Annotation): Types_2.Point3[][];

// @public (undocumented)
function getDataInTime(dynamicVolume: Types_2.IDynamicImageVolume, options: {
    frameNumbers?: any;
    maskVolumeId?: any;
    imageCoordinate?: any;
}): number[] | number[][];

// @public (undocumented)
function getDeduplicatedVTKPolyDataPoints(polyData: any, bypass?: boolean): {
    points: any[];
    lines: {
        a: any;
        b: any;
    }[];
};

// @public (undocumented)
function getDefaultRepresentationConfig(segmentation: Segmentation): LabelmapConfig;

// @public (undocumented)
function getDefaultSegmentationStateManager(): SegmentationStateManager;

// @public (undocumented)
function getDeltaDistance(currentPoints: IPoints[], lastPoints: IPoints[]): IDistance;

// @public (undocumented)
function getDeltaDistanceBetweenIPoints(currentPoints: IPoints[], lastPoints: IPoints[]): IDistance;

// @public (undocumented)
function getDeltaPoints(currentPoints: IPoints[], lastPoints: IPoints[]): IPoints;

// @public (undocumented)
function getDeltaRotation(currentPoints: ITouchPoints[], lastPoints: ITouchPoints[]): void;

// @public (undocumented)
function getFirstLineSegmentIntersectionIndexes(points: Types_2.Point2[], p1: Types_2.Point2, q1: Types_2.Point2, closed?: boolean): Types_2.Point2 | undefined;

// @public (undocumented)
function getFont(styleSpecifier: StyleSpecifier, state?: AnnotationStyleStates, mode?: ToolModes): string;

// @public (undocumented)
function getGlobalConfig(): SegmentationRepresentationConfig;

// @public (undocumented)
function getGlobalConfig_2(): SegmentationRepresentationConfig;

// @public (undocumented)
function getGlobalRepresentationConfig(representationType: SegmentationRepresentations): RepresentationConfig['LABELMAP'];

// @public (undocumented)
function getHoveredContourSegmentationAnnotation(segmentationId: any): number;

// @public (undocumented)
function getLineSegmentIntersectionsCoordinates(points: Types_2.Point2[], p1: Types_2.Point2, q1: Types_2.Point2, closed?: boolean): Types_2.Point2[];

// @public (undocumented)
function getLineSegmentIntersectionsIndexes(polyline: Types_2.Point2[], p1: Types_2.Point2, q1: Types_2.Point2, closed?: boolean): Types_2.Point2[];

// @public (undocumented)
function getLockedSegments(segmentationId: string): number[] | [];

// @public (undocumented)
function getMeanPoints(points: IPoints[]): IPoints;

// @public (undocumented)
function getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints;

// @public (undocumented)
function getNextColorLUTIndex(): number;

// @public (undocumented)
function getNormal2(polyline: Types_2.Point2[]): Types_2.Point3;

// @public (undocumented)
function getNormal3(polyline: Types_2.Point3[]): Types_2.Point3;

// @public (undocumented)
function getNumberOfAnnotations(toolName: string, annotationGroupSelector: AnnotationGroupSelector): number;

// @public (undocumented)
function getOrientationStringLPS(vector: Types_2.Point3): string;

// @public (undocumented)
function getParentAnnotation(annotation: Annotation): Annotation;

// @public (undocumented)
function getPoint(points: any, idx: any): Types_2.Point3;

// @public (undocumented)
function getPointInLineOfSightWithCriteria(viewport: Types_2.IVolumeViewport, worldPos: Types_2.Point3, targetVolumeId: string, criteriaFunction: (intensity: number, point: Types_2.Point3) => Types_2.Point3, stepSize?: number): Types_2.Point3;

// @public (undocumented)
function getPolyDataPointIndexes(polyData: vtkPolyData): any[];

// @public (undocumented)
function getPolyDataPoints(polyData: vtkPolyData): any[];

// @public (undocumented)
function getSegmentation(segmentationId: string): Segmentation | undefined;

// @public (undocumented)
function getSegmentationIdRepresentations(segmentationId: any): any[];

// @public (undocumented)
function getSegmentationRepresentationByUID(toolGroupId: string, segmentationRepresentationUID: string): ToolGroupSpecificRepresentation | undefined;

// @public (undocumented)
function getSegmentationRepresentations(toolGroupId: string): ToolGroupSpecificRepresentations | [];

// @public (undocumented)
function getSegmentationRepresentationSpecificConfig(toolGroupId: string, segmentationRepresentationUID: string): RepresentationConfig;

// @public (undocumented)
function getSegmentationRepresentationSpecificConfig_2(toolGroupId: string, segmentationRepresentationUID: string): RepresentationConfig;

// @public (undocumented)
function getSegmentations(): Segmentation[] | [];

// @public (undocumented)
function getSegmentationVisibility(toolGroupId: string, segmentationRepresentationUID: string): boolean | undefined;

// @public (undocumented)
function getSegmentAtLabelmapBorder(segmentationId: string, worldPoint: Types_2.Point3, { viewport, searchRadius }: Options_2): number;

// @public (undocumented)
function getSegmentAtWorldPoint(segmentationId: string, worldPoint: Types_2.Point3, options?: Options): number;

// @public (undocumented)
function getSegmentSpecificConfig(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number): RepresentationConfig;

// @public (undocumented)
function getSegmentSpecificRepresentationConfig(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number): RepresentationConfig;

// @public (undocumented)
function getSegmentVisibility(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number): boolean;

// @public (undocumented)
function getSignedArea(polyline: Types_2.Point2[]): number;

// @public (undocumented)
function getSphereBoundsInfo(circlePoints: [Types_2.Point3, Types_2.Point3], imageData: vtkImageData, viewport: any): {
    boundsIJK: BoundsIJK_2;
    centerWorld: Types_2.Point3;
    radiusWorld: number;
    topLeftWorld: Types_2.Point3;
    bottomRightWorld: Types_2.Point3;
};

// @public (undocumented)
function getState(annotation?: Annotation): AnnotationStyleStates;

// @public (undocumented)
const getSubPixelSpacingAndXYDirections: (viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, subPixelResolution: number) => {
    spacing: Types_2.Point2;
    xDir: Types_2.Point3;
    yDir: Types_2.Point3;
};

// @public (undocumented)
function getSynchronizer(synchronizerId: string): Synchronizer | void;

// @public (undocumented)
function getSynchronizersForViewport(viewportId: string, renderingEngineId: string): Array<Synchronizer>;

// @public (undocumented)
function getTextBoxCoordsCanvas(annotationCanvasPoints: Array<Types_2.Point2>): Types_2.Point2;

// @public (undocumented)
function getToolGroup(toolGroupId: string): IToolGroup | undefined;

// @public (undocumented)
function getToolGroupForViewport(viewportId: string, renderingEngineId?: string): IToolGroup | undefined;

// @public (undocumented)
function getToolGroupIdsWithSegmentation(segmentationId: string): string[];

// @public (undocumented)
function getToolGroupSpecificConfig(toolGroupId: string): SegmentationRepresentationConfig;

// @public (undocumented)
function getToolGroupSpecificConfig_2(toolGroupId: string): SegmentationRepresentationConfig;

// @public (undocumented)
function getToolGroupsWithToolName(toolName: string): IToolGroup[] | [];

// @public (undocumented)
function getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined;

// @public (undocumented)
function getUniqueSegmentIndices(segmentationId: any): any;

// @public (undocumented)
function getViewportForAnnotation(annotation: Annotation): IVolumeViewport_2 | IStackViewport_2;

// @public (undocumented)
function getViewportIdsWithToolToRender(element: HTMLDivElement, toolName: string, requireParallelNormals?: boolean): string[];

// @public (undocumented)
function getWindingDirection(polyline: Types_2.Point2[]): number;

// @public (undocumented)
function getWorldWidthAndHeightFromCorners(viewPlaneNormal: Types_2.Point3, viewUp: Types_2.Point3, topLeftWorld: Types_2.Point3, bottomRightWorld: Types_2.Point3): {
    worldWidth: number;
    worldHeight: number;
};

// @public (undocumented)
type GroupSpecificAnnotations = {
    [toolName: string]: Annotations;
};

// @public (undocumented)
function hideElementCursor(element: HTMLDivElement): void;

// @public (undocumented)
interface IAnnotationManager {
    // (undocumented)
    addAnnotation: (annotation: Annotation, groupKey: string) => void;
    // (undocumented)
    getAnnotation: (annotationUID: string) => Annotation;
    // (undocumented)
    getAnnotations: (groupKey: string, toolName?: string) => GroupSpecificAnnotations | Annotations;
    // (undocumented)
    getGroupKey: (annotationGroupSelector: AnnotationGroupSelector) => string;
    // (undocumented)
    getNumberOfAllAnnotations: () => number;
    // (undocumented)
    getNumberOfAnnotations: (groupKey: string, toolName?: string) => number;
    // (undocumented)
    removeAllAnnotations: () => void;
    // (undocumented)
    removeAnnotation: (annotationUID: string) => void;
    // (undocumented)
    removeAnnotations: (groupKey: string) => void;
}

// @public (undocumented)
type IDistance = {
    page: number;
    client: number;
    canvas: number;
    world: number;
};

// @public (undocumented)
type ImageInterpolationData = {
    sliceIndex: number;
    annotations?: Annotation[];
};

// @public (undocumented)
class ImageMouseCursor extends MouseCursor {
    constructor(url: string, x?: number, y?: number, name?: string | undefined, fallback?: MouseCursor | undefined);
    // (undocumented)
    getStyleProperty(): string;
    // (undocumented)
    static getUniqueInstanceName(prefix: string): string;
}

// @public (undocumented)
export function init(defaultConfiguration?: {}): void;

// @public (undocumented)
function initElementCursor(element: HTMLDivElement, cursor: MouseCursor | null): void;

// @public (undocumented)
type InteractionEndType = Types_2.CustomEventType<InteractionEndEventDetail>;

// @public (undocumented)
type InteractionEventType = Types_2.CustomEventType<InteractionEventDetail>;

// @public (undocumented)
type InteractionStartType = Types_2.CustomEventType<InteractionStartEventDetail>;

// @public (undocumented)
type InteractionTypes = 'Mouse' | 'Touch';

declare namespace interpolation {
    export {
        InterpolationManager
    }
}

// @public (undocumented)
class InterpolationManager {
    // (undocumented)
    static acceptAutoGenerated(annotationGroupSelector: AnnotationGroupSelector, selector?: AcceptInterpolationSelector): void;
    // (undocumented)
    static addTool(toolName: string): void;
    // (undocumented)
    static handleAnnotationCompleted: (evt: AnnotationCompletedEventType) => void;
    // (undocumented)
    static handleAnnotationDelete: (evt: AnnotationRemovedEventType) => void;
    // (undocumented)
    static handleAnnotationUpdate: (evt: AnnotationModifiedEventType) => void;
    // (undocumented)
    static toolNames: any[];
}

// @public (undocumented)
type InterpolationROIAnnotation = ContourAnnotation & ContourSegmentationAnnotationData & {
    metadata: {
        annotationUID?: string;
    };
    interpolationUID?: string;
    interpolationCompleted?: boolean;
    isInterpolationUpdate?: boolean;
};

// @public (undocumented)
type InterpolationViewportData = {
    annotation: InterpolationROIAnnotation;
    interpolationUID: string;
    viewport: Types_2.IViewport;
    sliceData: Types_2.ImageSliceData;
    isInterpolationUpdate?: boolean;
};

// @public (undocumented)
function intersectAABB(aabb1: Types_2.AABB2, aabb2: Types_2.AABB2): boolean;

// @public (undocumented)
function intersectLine(line1Start: Types_2.Point2, line1End: Types_2.Point2, line2Start: Types_2.Point2, line2End: Types_2.Point2): number[];

// @public (undocumented)
function intersectPolyline(sourcePolyline: Types_2.Point2[], targetPolyline: Types_2.Point2[]): boolean;

// @public (undocumented)
function invalidateAnnotation(annotation: Annotation): void;

// @public (undocumented)
function invalidateBrushCursor(toolGroupId: string): void;

// @public (undocumented)
function invertOrientationStringLPS(orientationString: string): string;

// @public (undocumented)
type IPoints = {
    page: Types_2.Point2;
    client: Types_2.Point2;
    canvas: Types_2.Point2;
    world: Types_2.Point3;
};

// @public (undocumented)
function isAnnotationLocked(annotation: Annotation): boolean;

// @public (undocumented)
function isAnnotationSelected(annotationUID: string): boolean;

// @public (undocumented)
function isAnnotationVisible(annotationUID: string): boolean | undefined;

// @public (undocumented)
function isAxisAlignedRectangle(rectangleCornersIJK: any): boolean;

// @public (undocumented)
function isClosed(polyline: Types_2.Point2[]): boolean;

// @public (undocumented)
function isContourSegmentationAnnotation(annotation: Annotation): annotation is ContourSegmentationAnnotation;

// @public (undocumented)
function isObject(value: any): boolean;

// @public (undocumented)
const isPlaneIntersectingAABB: (origin: any, normal: any, minX: any, minY: any, minZ: any, maxX: any, maxY: any, maxZ: any) => boolean;

// @public (undocumented)
interface ISpline {
    // (undocumented)
    get aabb(): Types_2.AABB2;
    // (undocumented)
    addControlPoint(point: Types_2.Point2): void;
    // (undocumented)
    addControlPointAtU(u: number): ControlPointInfo;
    // (undocumented)
    addControlPoints(points: Types_2.Point2[]): void;
    // (undocumented)
    clearControlPoints(): void;
    // (undocumented)
    get closed(): boolean;
    set closed(closed: boolean);
    // (undocumented)
    containsPoint(point: Types_2.Point2): boolean;
    // (undocumented)
    deleteControlPointByIndex(index: number): boolean;
    // (undocumented)
    get fixedResolution(): boolean;
    // (undocumented)
    getClosestControlPoint(point: Types_2.Point2): ClosestControlPoint;
    // (undocumented)
    getClosestControlPointWithinDistance(point: Types_2.Point2, range: number): ClosestControlPoint;
    // (undocumented)
    getClosestPoint(point: Types_2.Point2): ClosestSplinePoint;
    // (undocumented)
    getClosestPointOnControlPointLines(point: Types_2.Point2): ClosestPoint;
    // (undocumented)
    getControlPoints(): Types_2.Point2[];
    // (undocumented)
    getPolylinePoints(): Types_2.Point2[];
    // (undocumented)
    getPreviewPolylinePoints(controlPointPreview: Types_2.Point2, closeDistance: number): Types_2.Point2[];
    // (undocumented)
    hasTangentPoints(): boolean;
    // (undocumented)
    get invalidated(): boolean;
    // (undocumented)
    isPointNearCurve(point: Types_2.Point2, maxDist: number): boolean;
    // (undocumented)
    get length(): number;
    // (undocumented)
    get numControlPoints(): number;
    // (undocumented)
    get resolution(): number;
    set resolution(resolution: number);
    // (undocumented)
    setControlPoints(points: Types_2.Point2[]): void;
    // (undocumented)
    updateControlPoint(index: number, newControlPoint: Types_2.Point2): void;
}

// @public (undocumented)
function isPointInsidePolyline3D(point: Types_2.Point3, polyline: Types_2.Point3[], options?: {
    holes?: Types_2.Point3[][];
}): boolean;

// @public (undocumented)
function isPointOnLineSegment(lineStart: Types_2.Point2, lineEnd: Types_2.Point2, point: Types_2.Point2): boolean;

// @public (undocumented)
function isSegmentIndexLocked(segmentationId: string, segmentIndex: number): boolean;

// @public (undocumented)
function isValidRepresentationConfig(representationType: string, config: RepresentationConfig): boolean;

// @public (undocumented)
function isViewportPreScaled(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, targetId: string): boolean;

// @public (undocumented)
interface ISynchronizerEventHandler {
    // (undocumented)
    (synchronizer: Synchronizer, sourceViewport: Types_2.IViewportId, targetViewport: Types_2.IViewportId, sourceEvent: any, options?: any): Promise<void> | void;
}

// @public (undocumented)
type IToolBinding = {
    mouseButton?: ToolBindingMouseType;
    modifierKey?: ToolBindingKeyboardType;
    numTouchPoints?: number;
};

// @public (undocumented)
type IToolClassReference = new <T extends BaseTool>(config: any) => T;

// @public (undocumented)
interface IToolGroup {
    // (undocumented)
    addTool: {
        (toolName: string, toolConfiguration?: ToolConfiguration): void;
    };
    // (undocumented)
    addToolInstance: {
        (ttoolName: string, parentClassName: string, configuration?: any): void;
    };
    // (undocumented)
    addViewport: {
        (viewportId: string, renderingEngineId?: string): void;
    };
    // (undocumented)
    clone: {
        (newToolGroupId: string, fnToolFilter: (toolName: string) => boolean): IToolGroup;
    };
    // (undocumented)
    getActivePrimaryMouseButtonTool: {
        (): undefined | string;
    };
    // (undocumented)
    getDefaultMousePrimary: {
        (): MouseBindings;
    };
    // (undocumented)
    getToolConfiguration: {
        (toolName: string, configurationPath?: string): any;
    };
    // (undocumented)
    getToolInstance: {
        (toolName: string): any;
    };
    // (undocumented)
    getToolOptions: {
        (toolName: string): ToolOptionsType;
    };
    // (undocumented)
    getViewportIds: () => string[];
    // (undocumented)
    getViewportsInfo: () => Array<Types_2.IViewportId>;
    // (undocumented)
    hasTool(toolName: string): boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    removeViewports: {
        (renderingEngineId: string, viewportId?: string): void;
    };
    // (undocumented)
    setToolActive: {
        (toolName: string, toolBindingsOption?: SetToolBindingsType): void;
    };
    // (undocumented)
    setToolConfiguration: {
        (toolName: string, configuration: ToolConfiguration, overwrite?: boolean): void;
    };
    // (undocumented)
    setToolDisabled: {
        (toolName: string): void;
    };
    // (undocumented)
    setToolEnabled: {
        (toolName: string): void;
    };
    // (undocumented)
    setToolPassive: {
        (toolName: string, options?: {
            removeAllBindings?: boolean;
        }): void;
    };
    // (undocumented)
    setViewportsCursorByToolName: {
        (toolName: string, strategyName?: string): void;
    };
    // (undocumented)
    _toolInstances: Record<string, any>;
    // (undocumented)
    toolOptions: Record<string, any>;
    // (undocumented)
    viewportsInfo: Array<Types_2.IViewportId>;
}

// @public (undocumented)
type ITouchPoints = IPoints & {
    touch: {
        identifier: string;
        radiusX: number;
        radiusY: number;
        force: number;
        rotationAngle: number;
    };
};

// @public (undocumented)
function jumpToSlice(element: HTMLDivElement, options?: JumpToSliceOptions): Promise<void>;

// @public (undocumented)
type JumpToSliceOptions = {
    imageIndex: number;
    debounceLoading?: boolean;
    volumeId?: string;
};

// @public (undocumented)
function jumpToWorld(viewport: Types_2.IVolumeViewport, jumpWorld: Types_2.Point3): true | undefined;

// @public (undocumented)
enum KeyboardBindings {
    // (undocumented)
    Alt = 18,
    // (undocumented)
    AltMeta = 1891,
    // (undocumented)
    Ctrl = 17,
    // (undocumented)
    CtrlAlt = 1718,
    // (undocumented)
    CtrlMeta = 1791,
    // (undocumented)
    Meta = 91,
    // (undocumented)
    Shift = 16,
    // (undocumented)
    ShiftAlt = 1618,
    // (undocumented)
    ShiftCtrl = 1617,
    // (undocumented)
    ShiftMeta = 1691
}

// @public (undocumented)
type KeyDownEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    key: string;
    keyCode: number;
};

// @public (undocumented)
type KeyDownEventType = Types_2.CustomEventType<KeyDownEventDetail>;

// @public (undocumented)
export class KeyImageTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => Annotation;
    // (undocumented)
    cancel(): void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _doneChangingTextCallback(element: any, annotation: any, updatedText: any): void;
    // (undocumented)
    doubleClickCallback: (evt: EventTypes_2.TouchTapEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: Annotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume(index1: any, index2: any, dimensions: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: Annotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
type KeyUpEventDetail = KeyDownEventDetail;

// @public (undocumented)
type KeyUpEventType = Types_2.CustomEventType<KeyUpEventDetail>;

// @public (undocumented)
type LabelmapConfig = {
    renderOutline?: boolean;
    outlineWidthActive?: number;
    outlineWidthInactive?: number;
    activeSegmentOutlineWidthDelta?: number;
    renderFill?: boolean;
    renderFillInactive?: boolean;
    fillAlpha?: number;
    fillAlphaInactive?: number;
    outlineOpacity?: number;
    outlineOpacityInactive?: number;
};

// @public (undocumented)
type LabelmapRenderingConfig = {
    cfun?: vtkColorTransferFunction;
    ofun?: vtkPiecewiseFunction;
};

// @public (undocumented)
type LabelmapSegmentationData = LabelmapSegmentationDataVolume | LabelmapSegmentationDataStack | {
    volumeId?: string;
    referencedVolumeId?: string;
    imageIdReferenceMap?: Map<string, string>;
};

// @public (undocumented)
type LabelmapSegmentationDataStack = {
    imageIdReferenceMap: Map<string, string>;
};

// @public (undocumented)
type LabelmapSegmentationDataVolume = {
    volumeId: string;
    referencedVolumeId?: string;
};

// @public (undocumented)
type LabelmapToolOperationData = {
    segmentationId: string;
    segmentIndex: number;
    previewColors?: Record<number, [number, number, number, number]>;
    segmentsLocked: number[];
    viewPlaneNormal: number[];
    viewUp: number[];
    strategySpecificConfiguration: any;
    segmentationRepresentationUID: string;
    points: Types_2.Point3[];
    preview: any;
    toolGroupId: string;
};

// @public (undocumented)
type LabelmapToolOperationDataStack = LabelmapToolOperationData & LabelmapSegmentationDataStack;

// @public (undocumented)
type LabelmapToolOperationDataVolume = LabelmapToolOperationData & LabelmapSegmentationDataVolume;

declare namespace LabelmapTypes {
    export {
        LabelmapConfig,
        LabelmapRenderingConfig,
        LabelmapSegmentationDataVolume,
        LabelmapSegmentationDataStack,
        LabelmapSegmentationData
    }
}

// @public (undocumented)
interface LengthAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                length: number;
                unit: string;
            };
        };
    };
}

// @public (undocumented)
export class LengthTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => LengthAnnotation;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    _calculateLength(pos1: any, pos2: any): number;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: LengthAnnotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume(index1: any, index2: any, dimensions: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: LengthAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: LengthAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace lineSegment {
    export {
        distanceToPoint_2 as distanceToPoint,
        distanceToPointSquared_2 as distanceToPointSquared,
        distanceToPointSquaredInfo,
        intersectLine,
        isPointOnLineSegment
    }
}

// @public (undocumented)
type LivewireContourAnnotation = ContourAnnotation;

// @public (undocumented)
type LivewireContourSegmentationAnnotation = LivewireContourAnnotation & ContourSegmentationAnnotationData;

// @public (undocumented)
export class LivewireContourSegmentationTool extends LivewireContourTool {
    // (undocumented)
    protected isContourSegmentationTool(): boolean;
    // (undocumented)
    protected renderAnnotationInstance(renderContext: any): boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    updateInterpolatedAnnotation(annotation: ContourSegmentationAnnotation, enabledElement: Types_2.IEnabledElement): void;
}

// @public (undocumented)
export class LivewireContourTool extends ContourSegmentationBaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation(evt: EventTypes_2.InteractionEventType): LivewireContourAnnotation;
    // (undocumented)
    cancel: (element: HTMLDivElement) => string;
    // (undocumented)
    protected clearEditData(): void;
    // (undocumented)
    protected createAnnotation(evt: EventTypes_2.InteractionEventType): ContourAnnotation;
    // (undocumented)
    editData: {
        annotation: LivewireContourAnnotation;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        lastCanvasPoint?: Types_2.Point2;
        confirmedPath?: LivewirePath;
        currentPath?: LivewirePath;
        confirmedPathRight?: LivewirePath;
        closed?: boolean;
        worldToSlice?: (point: Types_2.Point3) => Types_2.Point2;
        sliceToWorld?: (point: Types_2.Point2) => Types_2.Point3;
        originalPath?: Types_2.Point3[];
        contourHoleProcessingEnabled?: boolean;
    } | null;
    // (undocumented)
    editHandle(worldPos: Types_2.Point3, element: any, annotation: any, handleIndex: number): void;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType, clearAnnotation?: boolean) => void;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: LivewireContourAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    protected isContourSegmentationTool(): boolean;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: LivewireContourAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): boolean;
    // (undocumented)
    protected renderAnnotationInstance(renderContext: {
        enabledElement: Types_2.IEnabledElement;
        targetId: string;
        annotation: LivewireContourAnnotation;
        annotationStyle: Record<string, any>;
        svgDrawingHelper: SVGDrawingHelper;
    }): boolean;
    // (undocumented)
    protected scissors: LivewireScissors;
    // (undocumented)
    protected scissorsRight: LivewireScissors;
    // (undocumented)
    protected setupBaseEditData(worldPos: any, element: any, annotation: any, rightPos?: any, contourHoleProcessingEnabled?: any): void;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: LivewireContourAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
    // (undocumented)
    triggerChangeEvent: (annotation: LivewireContourAnnotation, enabledElement: Types_2.IEnabledElement, changeType?: ChangeTypes, contourHoleProcessingEnabled?: boolean) => void;
    // (undocumented)
    undo(element: any, config: any, evt: any): void;
    // (undocumented)
    protected updateAnnotation(livewirePath: LivewirePath): void;
}

declare namespace locking {
    export {
        setAnnotationLocked,
        getAnnotationsLocked,
        getAnnotationsLockedCount,
        unlockAllAnnotations,
        isAnnotationLocked,
        checkAndDefineIsLockedProperty
    }
}

// @public (undocumented)
export class MagnifyTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _bounds: any;
    // (undocumented)
    _createMagnificationViewport: () => void;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _dragEndCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        referencedImageId: string;
        viewportIdsToRender: string[];
        enabledElement: Types_2.IEnabledElement;
        renderingEngine: Types_2.IRenderingEngine;
        currentPoints: IPoints;
    } | null;
    // (undocumented)
    _getReferencedImageId(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport): string;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    preTouchStartCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    static toolName: any;
}

declare namespace math {
    export {
        aabb,
        BasicStatsCalculator,
        ellipse,
        lineSegment,
        point,
        polyline,
        rectangle,
        vec2
    }
}

// @public (undocumented)
function mergePolylines(targetPolyline: Types_2.Point2[], sourcePolyline: Types_2.Point2[]): Types_2.Point2[];

// @public (undocumented)
export class MIPJumpToClickTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _bounds: any;
    // (undocumented)
    mouseClickCallback(evt: any): void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
function mirror(mirrorPoint: Types_2.Point2, staticPoint: Types_2.Point2): Types_2.Point2;

// @public (undocumented)
enum MouseBindings {
    // (undocumented)
    Auxiliary = 4,
    // (undocumented)
    Fifth_Button = 16,
    // (undocumented)
    Fourth_Button = 8,
    // (undocumented)
    Primary = 1,
    // (undocumented)
    Primary_And_Auxiliary = 5,
    // (undocumented)
    Primary_And_Secondary = 3,
    // (undocumented)
    Primary_And_Secondary_And_Auxiliary = 7,
    // (undocumented)
    Secondary = 2,
    // (undocumented)
    Secondary_And_Auxiliary = 6
}

// @public (undocumented)
type MouseClickEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseClickEventType = Types_2.CustomEventType<MouseClickEventDetail>;

// @public (undocumented)
class MouseCursor {
    constructor(name: string, fallback?: MouseCursor | undefined);
    // (undocumented)
    addFallbackStyleProperty(style: string): string;
    // (undocumented)
    static getDefinedCursor(name: string): MouseCursor | undefined;
    // (undocumented)
    getName(): string;
    // (undocumented)
    getStyleProperty(): string;
    // (undocumented)
    static setDefinedCursor(name: string, cursor: MouseCursor): boolean;
}

// @public (undocumented)
type MouseDoubleClickEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail;

// @public (undocumented)
type MouseDoubleClickEventType = Types_2.CustomEventType<MouseDoubleClickEventDetail>;

// @public (undocumented)
type MouseDownActivateEventDetail = NormalizedInteractionEventDetail & MousePointsDetail & MouseCustomEventDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseDownActivateEventType = Types_2.CustomEventType<MouseDownActivateEventDetail>;

// @public (undocumented)
type MouseDownEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseDownEventType = Types_2.CustomEventType<MouseDownEventDetail>;

// @public (undocumented)
type MouseDragEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseDragEventType = Types_2.CustomEventType<MouseDragEventDetail>;

// @public (undocumented)
type MouseMoveEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & {
    currentPoints: IPoints;
};

// @public (undocumented)
type MouseMoveEventType = Types_2.CustomEventType<MouseMoveEventDetail>;

// @public (undocumented)
type MouseUpEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & MousePointsDetail & {
    mouseButton: number;
};

// @public (undocumented)
type MouseUpEventType = Types_2.CustomEventType<MouseUpEventDetail>;

// @public (undocumented)
type MouseWheelEventDetail = NormalizedInteractionEventDetail & MouseCustomEventDetail & {
    detail: Record<string, any>;
    wheel: {
        spinX: number;
        spinY: number;
        pixelX: number;
        pixelY: number;
        direction: number;
    };
    points: IPoints;
};

// @public (undocumented)
type MouseWheelEventType = Types_2.CustomEventType<MouseWheelEventDetail>;

// @public (undocumented)
type NormalizedInteractionEventDetail = {
    eventName: string;
    renderingEngineId: string;
    viewportId: string;
    camera: Record<string, unknown>;
    element: HTMLDivElement;
};

// @public (undocumented)
type NormalizedMouseEventType = Types_2.CustomEventType<MouseCustomEventDetail>;

// @public (undocumented)
type NormalizedTouchEventType = Types_2.CustomEventType<TouchCustomEventDetail>;

declare namespace orientation_2 {
    export {
        getOrientationStringLPS,
        invertOrientationStringLPS
    }
}

// @public (undocumented)
export class OrientationMarkerTool extends BaseTool {
    constructor(toolProps?: {}, defaultToolProps?: {
        configuration: {
            orientationWidget: {
                enabled: boolean;
                viewportCorner: Corners;
                viewportSize: number;
                minPixelSize: number;
                maxPixelSize: number;
            };
            overlayMarkerType: number;
            overlayConfiguration: {
                [x: number]: {
                    faceProperties: {
                        xPlus: {
                            text: string;
                            faceColor: string;
                            faceRotation: number;
                        };
                        xMinus: {
                            text: string;
                            faceColor: string;
                            faceRotation: number;
                        };
                        yPlus: {
                            text: string;
                            faceColor: string;
                            fontColor: string;
                            faceRotation: number;
                        };
                        yMinus: {
                            text: string;
                            faceColor: string;
                            fontColor: string;
                        };
                        zPlus: {
                            text: string;
                        };
                        zMinus: {
                            text: string;
                        };
                    };
                    defaultStyle: {
                        fontStyle: string;
                        fontFamily: string;
                        fontColor: string;
                        fontSizeScale: (res: any) => number;
                        faceColor: string;
                        edgeThickness: number;
                        edgeColor: string;
                        resolution: number;
                    };
                    polyDataURL?: undefined;
                } | {
                    faceProperties?: undefined;
                    defaultStyle?: undefined;
                    polyDataURL?: undefined;
                } | {
                    polyDataURL: string;
                    faceProperties?: undefined;
                    defaultStyle?: undefined;
                };
            };
        };
    });
    // (undocumented)
    addAxisActorInViewport(viewport: any): Promise<void>;
    // (undocumented)
    static AXIS: number;
    // (undocumented)
    configuration_invalidated: boolean;
    // (undocumented)
    createAnnotatedCubeActor(): Promise<vtkAnnotatedCubeActor>;
    // (undocumented)
    static CUBE: number;
    // (undocumented)
    onSetToolActive: () => void;
    // (undocumented)
    onSetToolDisabled: () => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    orientationMarkers: any;
    // (undocumented)
    static OVERLAY_MARKER_TYPES: {
        ANNOTATED_CUBE: number;
        AXES: number;
        CUSTOM: number;
    };
    // (undocumented)
    polyDataURL: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    static VTPFILE: number;
}

// @public (undocumented)
export class OverlayGridTool extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    calculateImageIdPointSets: (imageId: string) => {
        pointSet1: Types_2.Point3[];
        pointSet2: Types_2.Point3[];
    };
    // (undocumented)
    _init: () => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    onSetToolActive: () => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
export class PaintFillTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
export class PanTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    mouseDragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback(evt: EventTypes_2.InteractionEventType): void;
}

declare namespace planar {
    export {
        _default as default,
        filterAnnotationsWithinSlice,
        getWorldWidthAndHeightFromCorners,
        filterAnnotationsForDisplay,
        getPointInLineOfSightWithCriteria,
        isPlaneIntersectingAABB
    }
}

// @public (undocumented)
type PlanarBoundingBox = {
    x: number;
    y: number;
    width: number;
    height: number;
};

// @public (undocumented)
type PlanarFreehandContourSegmentationAnnotation = PlanarFreehandROIAnnotation & ContourSegmentationAnnotationData;

// @public (undocumented)
export class PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {
    constructor(toolProps: PublicToolProps);
    // (undocumented)
    protected isContourSegmentationTool(): boolean;
    // (undocumented)
    protected renderAnnotationInstance(renderContext: AnnotationRenderContext): boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
type PlanarFreehandROIAnnotation = ContourAnnotation & {
    data: {
        label?: string;
        isOpenContour?: boolean;
        isOpenUShapeContour?: boolean;
        openUShapeContourVectorToPeak?: Types_2.Point3[];
        cachedStats?: ROICachedStats;
    };
};

// @public (undocumented)
export class PlanarFreehandROITool extends ContourSegmentationBaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    protected activateDraw: (evt: EventTypes_2.InteractionEventType, annotation: PlanarFreehandROIAnnotation, viewportIdsToRender: string[]) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => PlanarFreehandROIAnnotation;
    // (undocumented)
    _calculateStatsIfActive(annotation: PlanarFreehandROIAnnotation, targetId: string, viewport: any, renderingEngine: any, enabledElement: any): void;
    // (undocumented)
    cancel: (element: HTMLDivElement) => void;
    // (undocumented)
    protected createAnnotation(evt: EventTypes_2.InteractionEventType): Annotation;
    // (undocumented)
    filterInteractableAnnotationsForElement(element: HTMLDivElement, annotations: Annotations): Annotations | undefined;
    // (undocumented)
    protected getAnnotationStyle(context: any): any;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: PlanarFreehandROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    protected isContourSegmentationTool(): boolean;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isEditingClosed: boolean;
    // (undocumented)
    isEditingOpen: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: PlanarFreehandROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    protected renderAnnotationInstance(renderContext: AnnotationRenderContext): boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: PlanarFreehandROIAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
}

declare namespace planarFreehandROITool {
    export {
        _default_4 as default,
        smoothAnnotation
    }
}

// @public (undocumented)
export class PlanarRotateTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: EventTypes_2.MouseDragEventType): void;
    // (undocumented)
    mouseDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
}

// @public (undocumented)
function playClip(element: HTMLDivElement, playClipOptions: CINETypes.PlayClipOptions): void;

// @public (undocumented)
type PlayClipOptions = {
    framesPerSecond?: number;
    frameTimeVector?: number[];
    reverse?: boolean;
    loop?: boolean;
    dynamicCineEnabled?: boolean;
    frameTimeVectorSpeedMultiplier?: number;
    waitForRendered?: number;
};

declare namespace point {
    export {
        distanceToPoint_3 as distanceToPoint,
        distanceToPointSquared_3 as distanceToPointSquared,
        mirror
    }
}

// @public (undocumented)
const pointCanProjectOnLine: (p: Types_2.Point2, p1: Types_2.Point2, p2: Types_2.Point2, proximity: number) => boolean;

// @public (undocumented)
function pointInEllipse(ellipse: any, pointLPS: any, inverts?: Inverts): boolean;

// @public (undocumented)
function pointInShapeCallback(imageData: vtkImageData | Types_2.CPUImageData, pointInShapeFn: ShapeFnCriteria, callback?: PointInShapeCallback, boundsIJK?: BoundsIJK_2): Array<PointInShape>;

// @public (undocumented)
function pointInSurroundingSphereCallback(imageData: vtkImageData, circlePoints: [Types_2.Point3, Types_2.Point3], callback: PointInShapeCallback, viewport?: Types_2.IVolumeViewport): void;

// @public (undocumented)
const pointsAreWithinCloseContourProximity: (p1: Types_2.Point2, p2: Types_2.Point2, closeContourProximity: number) => boolean;

// @public (undocumented)
function pointToString(point: any, decimals?: number): string;

declare namespace polyDataUtils {
    export {
        getPoint,
        getPolyDataPointIndexes,
        getPolyDataPoints
    }
}

declare namespace polyline {
    export {
        isClosed,
        containsPoint,
        containsPoints,
        getAABB,
        getArea,
        getSignedArea,
        getWindingDirection,
        getNormal3,
        getNormal2,
        intersectPolyline,
        decimate,
        getFirstLineSegmentIntersectionIndexes,
        getLineSegmentIntersectionsIndexes,
        getLineSegmentIntersectionsCoordinates,
        getClosestLineSegmentIntersection,
        getSubPixelSpacingAndXYDirections,
        pointsAreWithinCloseContourProximity,
        addCanvasPointsToArray,
        pointCanProjectOnLine,
        mergePolylines,
        subtractPolylines,
        isPointInsidePolyline3D,
        projectTo2D
    }
}

// @public (undocumented)
type PolySegConversionOptions = {
    segmentIndices?: number[];
    segmentationRepresentationUID?: string;
    viewport?: Types_2.IStackViewport | Types_2.IVolumeViewport;
};

declare namespace polySegManager {
    export {
        canComputeRequestedRepresentation,
        computeAndAddSurfaceRepresentation,
        computeAndAddLabelmapRepresentation,
        computeAndAddContourRepresentation
    }
}

// @public (undocumented)
const precalculatePointInEllipse: (ellipse: any, inverts?: Inverts) => Inverts;

// @public (undocumented)
interface ProbeAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
        };
        cachedStats: {
            [targetId: string]: {
                Modality: string;
                index: Types_2.Point3;
                value: number;
            };
        };
        label: string;
    };
}

// @public (undocumented)
export class ProbeTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => ProbeAnnotation;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        newAnnotation?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    eventDispatchDetail: {
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getHandleNearImagePoint(element: HTMLDivElement, annotation: ProbeAnnotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: ProbeAnnotation): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool(): boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback(): void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function projectTo2D(polyline: Types_2.Point3[]): {
    sharedDimensionIndex: any;
    projectedPolyline: Types_2.Point2[];
};

// @public (undocumented)
type PublicToolProps = SharedToolProp & {
    name?: string;
};

declare namespace rectangle {
    export {
        distanceToPoint_4 as distanceToPoint
    }
}

// @public (undocumented)
interface RectangleROIAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats?: ROICachedStats | {
            pointsInVolume?: Types_2.Point3[];
            projectionPoints?: Types_2.Point3[];
            projectionPointsImageIds?: string[];
        };
    };
}

// @public (undocumented)
interface RectangleROIStartEndThresholdAnnotation extends Annotation {
    // (undocumented)
    data: {
        label: string;
        startSlice: number;
        endSlice: number;
        cachedStats: {
            pointsInVolume: Types_2.Point3[];
            projectionPoints: Types_2.Point3[][];
            projectionPointsImageIds: string[];
        };
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
        };
    };
    // (undocumented)
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        annotationUID?: string;
        FrameOfReferenceUID: string;
        referencedImageId?: string;
        toolName: string;
        enabledElement: any;
        volumeId: string;
        spacingInNormal: number;
    };
}

// @public (undocumented)
export class RectangleROIStartEndThresholdTool extends RectangleROITool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => {
        highlighted: boolean;
        invalidated: boolean;
        metadata: {
            viewPlaneNormal: Types_2.Point3;
            enabledElement: Types_2.IEnabledElement;
            viewUp: Types_2.Point3;
            FrameOfReferenceUID: string;
            referencedImageId: any;
            toolName: string;
            volumeId: any;
            spacingInNormal: number;
        };
        data: {
            label: string;
            startSlice: number;
            endSlice: number;
            cachedStats: {
                pointsInVolume: any[];
                projectionPoints: any[];
                projectionPointsImageIds: any[];
            };
            handles: {
                textBox: {
                    hasMoved: boolean;
                    worldPosition: any;
                    worldBoundingBox: any;
                };
                points: Types_2.Point3[];
                activeHandleIndex: any;
            };
            labelmapUID: any;
        };
    };
    // (undocumented)
    _calculateCachedStatsTool(annotation: any, enabledElement: any): any;
    // (undocumented)
    _computePointsInsideVolume(annotation: any, imageVolume: any, enabledElement: any): void;
    // (undocumented)
    _computeProjectionPoints(annotation: RectangleROIStartEndThresholdAnnotation, imageVolume: Types_2.IImageVolume): void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getEndSliceIndex(imageVolume: Types_2.IImageVolume, worldPos: Types_2.Point3, spacingInNormal: number, viewPlaneNormal: Types_2.Point3): number | undefined;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
interface RectangleROIThresholdAnnotation extends Annotation {
    // (undocumented)
    data: {
        label: string;
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
        };
    };
    // (undocumented)
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        annotationUID?: string;
        FrameOfReferenceUID: string;
        referencedImageId?: string;
        toolName: string;
        enabledElement: Types_2.IEnabledElement;
        volumeId: string;
    };
}

// @public (undocumented)
export class RectangleROIThresholdTool extends RectangleROITool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => {
        highlighted: boolean;
        invalidated: boolean;
        metadata: {
            viewPlaneNormal: Types_2.Point3;
            enabledElement: Types_2.IEnabledElement;
            viewUp: Types_2.Point3;
            FrameOfReferenceUID: string;
            referencedImageId: any;
            toolName: string;
            volumeId: any;
        };
        data: {
            label: string;
            handles: {
                textBox: {
                    hasMoved: boolean;
                    worldPosition: any;
                    worldBoundingBox: any;
                };
                points: Types_2.Point3[];
                activeHandleIndex: any;
            };
            segmentationId: any;
        };
    };
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
function rectangleROIThresholdVolumeByRange(annotationUIDs: string[], segmentationVolume: Types_2.IImageVolume, thresholdVolumeInformation: ThresholdInformation[], options: ThresholdOptions): Types_2.IImageVolume;

// @public (undocumented)
export class RectangleROITool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => RectangleROIAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewPlaneNormal: any, viewUp: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _getRectangleImageCoordinates: (points: Array<Types_2.Point2>) => {
        left: number;
        top: number;
        width: number;
        height: number;
    };
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: RectangleROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: RectangleROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: RectangleROIAnnotation) => void;
}

declare namespace rectangleROITool {
    export {
        getBoundsIJKFromRectangleAnnotations,
        isAxisAlignedRectangle
    }
}

// @public (undocumented)
export class RectangleScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        imageIdReferenceMap: Map<string, string>;
        volumeId: string;
        referencedVolumeId: string;
        annotation: any;
        segmentationId: string;
        segmentIndex: number;
        segmentsLocked: number[];
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
interface ReferenceCursor extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: [Types_2.Point3];
        };
    };
}

// @public (undocumented)
export class ReferenceCursors extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    createInitialAnnotation: (worldPos: Types_2.Point3, element: HTMLDivElement) => void;
    // (undocumented)
    _currentCanvasPosition: null | Types_2.Point2;
    // (undocumented)
    _currentCursorWorldPosition: null | Types_2.Point3;
    // (undocumented)
    _disableCursorEnabled: boolean;
    // (undocumented)
    _elementWithCursor: null | HTMLDivElement;
    // (undocumented)
    filterInteractableAnnotationsForElement(element: HTMLDivElement, annotations: Annotations): Annotations;
    // (undocumented)
    getActiveAnnotation(element: HTMLDivElement): null | Annotation;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    onCameraModified: (evt: any) => void;
    // (undocumented)
    onSetToolActive(): void;
    // (undocumented)
    onSetToolDisabled(): void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
    // (undocumented)
    updateAnnotationPosition(element: HTMLDivElement, annotation: Annotation): void;
    // (undocumented)
    updateViewportImage(viewport: Types_2.IStackViewport | Types_2.IVolumeViewport): void;
}

// @public (undocumented)
interface ReferenceLineAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
        };
    };
}

// @public (undocumented)
class ReferenceLines extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    editData: {
        renderingEngine: any;
        sourceViewport: any;
        annotation: ReferenceLineAnnotation;
    } | null;
    // (undocumented)
    _init: () => void;
    // (undocumented)
    intersectInfiniteLines(line1Start: Types_2.Point2, line1End: Types_2.Point2, line2Start: Types_2.Point2, line2End: Types_2.Point2): number[];
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isInBound(point: number[], dimensions: Types_2.Point3): boolean;
    // (undocumented)
    isParallel(vec1: Types_2.Point3, vec2: Types_2.Point3): boolean;
    // (undocumented)
    isPerpendicular: (vec1: Types_2.Point3, vec2: Types_2.Point3) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    onCameraModified: (evt: Types_2.EventTypes.CameraModifiedEvent) => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}
export { ReferenceLines }
export { ReferenceLines as ReferenceLinesTool }

// @public (undocumented)
function registerCursor(toolName: string, iconContent: string, viewBox: {
    x: number;
    y: number;
}): void;

// @public (undocumented)
function removeAllAnnotations(): void;

// @public (undocumented)
function removeAnnotation(annotationUID: string): void;

// @public (undocumented)
function removeColorLUT(colorLUTIndex: number): void;

// @public (undocumented)
function removeContourSegmentationAnnotation(annotation: ContourSegmentationAnnotation): void;

// @public (undocumented)
function removeSegmentation(segmentationId: string): void;

// @public (undocumented)
function removeSegmentationRepresentation(toolGroupId: string, segmentationRepresentationUID: string): void;

// @public (undocumented)
function removeSegmentationRepresentations(toolGroupId: string): void;

// @public (undocumented)
function removeSegmentationsFromToolGroup(toolGroupId: string, segmentationRepresentationUIDs?: string[] | undefined, immediate?: boolean): void;

// @public (undocumented)
export function removeTool(ToolClass: any): void;

// @public (undocumented)
type RepresentationConfig = {
    LABELMAP?: LabelmapConfig;
    CONTOUR?: ContourConfig;
    SURFACE?: any;
};

// @public (undocumented)
type RepresentationPublicInput = {
    segmentationId: string;
    type: Enums.SegmentationRepresentations;
    options?: RepresentationPublicInputOptions;
};

// @public (undocumented)
function resetAnnotationManager(): void;

// @public (undocumented)
function resetElementCursor(element: HTMLDivElement): void;

// @public (undocumented)
const roundNumber: typeof utilities_2.roundNumber;

// @public (undocumented)
interface ScaleOverlayAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
        };
        viewportId: string;
    };
}

// @public (undocumented)
export class ScaleOverlayTool extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    computeCanvasScaleCoordinates: (canvasSize: any, canvasCoordinates: any, vscaleBounds: any, hscaleBounds: any, location: any) => any;
    // (undocumented)
    computeEndScaleTicks: (canvasCoordinates: any, location: any) => {
        endTick1: any[][];
        endTick2: any[][];
    };
    // (undocumented)
    computeInnerScaleTicks: (scaleSize: number, location: string, annotationUID: string, leftTick: any[][], rightTick: any[][]) => {
        tickIds: any[];
        tickUIDs: any[];
        tickCoordinates: any[];
    };
    // (undocumented)
    computeScaleBounds: (canvasSize: any, horizontalReduction: any, verticalReduction: any, location: any) => {
        height: any;
        width: any;
    };
    // (undocumented)
    computeScaleSize: (worldWidthViewport: number, worldHeightViewport: number, location: any) => any;
    // (undocumented)
    computeWorldScaleCoordinates: (scaleSize: any, location: any, pointSet: any) => any;
    // (undocumented)
    editData: {
        renderingEngine: any;
        viewport: any;
        annotation: ScaleOverlayAnnotation;
    } | null;
    // (undocumented)
    _getTextLines(scaleSize: number): string[] | undefined;
    // (undocumented)
    _init: () => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    onCameraModified: (evt: Types_2.EventTypes.CameraModifiedEvent) => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function scroll_2(viewport: Types_2.IViewport, options: ScrollOptions_2): void;

// @public (undocumented)
type ScrollOptions_2 = {
    delta: number;
    volumeId?: string;
    debounceLoading?: boolean;
    loop?: boolean;
    scrollSlabs?: boolean;
};

// @public (undocumented)
type Segmentation = {
    segmentationId: string;
    type: Enums.SegmentationRepresentations;
    label: string;
    activeSegmentIndex: number;
    segmentsLocked: Set<number>;
    cachedStats: {
        [key: string]: number;
    };
    segmentLabels: {
        [key: string]: string;
    };
    representationData: SegmentationRepresentationData;
};

declare namespace segmentation {
    export {
        addSegmentations,
        addSegmentationRepresentations,
        removeSegmentationsFromToolGroup,
        addRepresentationData,
        state_3 as state,
        activeSegmentation,
        segmentLocking,
        config_2 as config,
        segmentIndex,
        triggerSegmentationEvents,
        convertStackToVolumeSegmentation,
        convertVolumeToStackSegmentation,
        polySegManager as polySeg
    }
}
export { segmentation }

declare namespace segmentation_2 {
    export {
        thresholdVolumeByRange,
        createMergedLabelmapForIndex,
        isValidRepresentationConfig,
        getDefaultRepresentationConfig,
        createLabelmapVolumeForViewport,
        rectangleROIThresholdVolumeByRange,
        triggerSegmentationRender,
        floodFill,
        getBrushSizeForToolGroup,
        setBrushSizeForToolGroup,
        getBrushThresholdForToolGroup,
        setBrushThresholdForToolGroup,
        thresholdSegmentationByRange,
        createImageIdReferenceMap,
        contourAndFindLargestBidirectional,
        createBidirectionalToolData,
        segmentContourAction,
        invalidateBrushCursor,
        getUniqueSegmentIndices,
        getSegmentAtWorldPoint,
        getSegmentAtLabelmapBorder,
        getHoveredContourSegmentationAnnotation
    }
}

// @public (undocumented)
type SegmentationDataModifiedEventDetail = {
    segmentationId: string;
    modifiedSlicesToUse?: number[];
};

// @public (undocumented)
type SegmentationDataModifiedEventType = Types_2.CustomEventType<SegmentationDataModifiedEventDetail>;

// @public (undocumented)
export class SegmentationDisplayTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addPlanarFreeHandToolIfAbsent(toolGroupId: any): void;
    // (undocumented)
    _getMergedRepresentationsConfig(toolGroupId: string): SegmentationRepresentationConfig;
    // (undocumented)
    onSetToolDisabled(): void;
    // (undocumented)
    onSetToolEnabled(): void;
    // (undocumented)
    renderSegmentation: (toolGroupId: string) => void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
export class SegmentationIntersectionTool extends AnnotationDisplayTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _init: () => void;
    // (undocumented)
    onCameraModified: (evt: Types_2.EventTypes.CameraModifiedEvent) => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
type SegmentationModifiedEventDetail = {
    segmentationId: string;
};

// @public (undocumented)
type SegmentationModifiedEventType = Types_2.CustomEventType<SegmentationModifiedEventDetail>;

// @public (undocumented)
type SegmentationRemovedEventDetail = {
    segmentationId: string;
};

// @public (undocumented)
type SegmentationRemovedEventType = Types_2.CustomEventType<SegmentationRemovedEventDetail>;

// @public (undocumented)
type SegmentationRenderedEventDetail = {
    viewportId: string;
    toolGroupId: string;
};

// @public (undocumented)
type SegmentationRenderedEventType = Types_2.CustomEventType<SegmentationRenderedEventDetail>;

// @public (undocumented)
type SegmentationRepresentationConfig = {
    renderInactiveSegmentations: boolean;
    representations: RepresentationConfig;
};

// @public (undocumented)
type SegmentationRepresentationData = {
    LABELMAP?: LabelmapSegmentationData;
    CONTOUR?: ContourSegmentationData;
    SURFACE?: SurfaceSegmentationData;
};

// @public (undocumented)
type SegmentationRepresentationModifiedEventDetail = {
    toolGroupId: string;
    segmentationRepresentationUID: string;
};

// @public (undocumented)
type SegmentationRepresentationModifiedEventType = Types_2.CustomEventType<SegmentationRepresentationModifiedEventDetail>;

// @public (undocumented)
type SegmentationRepresentationRemovedEventDetail = {
    toolGroupId: string;
    segmentationRepresentationUID: string;
};

// @public (undocumented)
type SegmentationRepresentationRemovedEventType = Types_2.CustomEventType<SegmentationRepresentationRemovedEventDetail>;

// @public (undocumented)
enum SegmentationRepresentations {
    // (undocumented)
    Contour = "CONTOUR",
    // (undocumented)
    Labelmap = "LABELMAP",
    // (undocumented)
    Surface = "SURFACE"
}

// @public (undocumented)
type SegmentationState = {
    colorLUT: Types_2.ColorLUT[];
    segmentations: Segmentation[];
    globalConfig: SegmentationRepresentationConfig;
    toolGroups: {
        [key: string]: {
            segmentationRepresentations: ToolGroupSpecificRepresentations;
            config: SegmentationRepresentationConfig;
        };
    };
};

// @public (undocumented)
function segmentContourAction(element: HTMLDivElement, configuration: any): any;

declare namespace segmentIndex {
    export {
        getActiveSegmentIndex,
        setActiveSegmentIndex
    }
}

declare namespace segmentLocking {
    export {
        isSegmentIndexLocked,
        setSegmentIndexLocked,
        getLockedSegments
    }
}

// @public (undocumented)
export class SegmentSelectTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    onSetToolActive: () => void;
    // (undocumented)
    onSetToolDisabled: () => void;
    // (undocumented)
    onSetToolEnabled: () => void;
    // (undocumented)
    static SelectMode: {
        Inside: string;
        Border: string;
    };
    // (undocumented)
    _setActiveSegment(evt?: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    _setActiveSegmentForType(activeSegmentationReps: ToolGroupSpecificRepresentation, worldPoint: Types_2.Point3, viewport: Types_2.IStackViewport | Types_2.IVolumeViewport): void;
    // (undocumented)
    static toolName: any;
}

declare namespace selection {
    export {
        setAnnotationSelected,
        getAnnotationsSelected,
        getAnnotationsSelectedByToolName,
        getAnnotationsSelectedCount,
        deselectAnnotation,
        isAnnotationSelected
    }
}

// @public (undocumented)
function setActiveSegmentationRepresentation(toolGroupId: string, segmentationRepresentationUID: string): void;

// @public (undocumented)
function setActiveSegmentIndex(segmentationId: string, segmentIndex: number): void;

// @public (undocumented)
function setAnnotationLocked(annotation: Annotation, locked?: boolean): void;

// @public (undocumented)
function setAnnotationManager(annotationManager: any): void;

// @public (undocumented)
function setAnnotationSelected(annotationUID: string, selected?: boolean, preserveSelected?: boolean): void;

// @public (undocumented)
function setAnnotationVisibility(annotationUID: string, visible?: boolean): void;

// @public (undocumented)
function setAttributesIfNecessary(attributes: any, svgNode: any): void;

// @public (undocumented)
function setBrushSizeForToolGroup(toolGroupId: string, brushSize: number, toolName?: string): void;

// @public (undocumented)
function setBrushThresholdForToolGroup(toolGroupId: string, threshold: Types_2.Point2, otherArgs?: Record<string, unknown>): void;

// @public (undocumented)
function setColorForSegmentIndex(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number, color: Types_2.Color): void;

// @public (undocumented)
function setColorLUT(toolGroupId: string, segmentationRepresentationUID: string, colorLUTIndex: number): void;

// @public (undocumented)
function setCursorForElement(element: HTMLDivElement, cursorName: string): void;

// @public (undocumented)
function _setElementCursor(element: HTMLDivElement, cursor: MouseCursor | null): void;

// @public (undocumented)
function setGlobalConfig(config: SegmentationRepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setGlobalConfig_2(segmentationConfig: SegmentationRepresentationConfig): void;

// @public (undocumented)
function setGlobalRepresentationConfig(representationType: SegmentationRepresentations, config: RepresentationConfig['LABELMAP']): void;

// @public (undocumented)
function setNewAttributesIfValid(attributes: any, svgNode: any): void;

// @public (undocumented)
function setSegmentationRepresentationSpecificConfig(toolGroupId: string, segmentationRepresentationUID: string, config: RepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setSegmentationRepresentationSpecificConfig_2(toolGroupId: string, segmentationRepresentationUID: string, config: RepresentationConfig): void;

// @public (undocumented)
function setSegmentationVisibility(toolGroupId: string, segmentationRepresentationUID: string, visibility: boolean): void;

// @public (undocumented)
function setSegmentIndexLocked(segmentationId: string, segmentIndex: number, locked?: boolean): void;

// @public (undocumented)
function setSegmentSpecificConfig(toolGroupId: string, segmentationRepresentationUID: string, config: SegmentSpecificRepresentationConfig): void;

// @public (undocumented)
function setSegmentSpecificRepresentationConfig(toolGroupId: string, segmentationRepresentationUID: string, config: SegmentSpecificRepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setSegmentsVisibility(toolGroupId: string, segmentationRepresentationUID: string, segmentIndices: number[], visibility: boolean): void;

// @public (undocumented)
function setSegmentVisibility(toolGroupId: string, segmentationRepresentationUID: string, segmentIndex: number, visibility: boolean): void;

// @public (undocumented)
type SetToolBindingsType = {
    bindings: IToolBinding[];
};

// @public (undocumented)
function setToolGroupSpecificConfig(toolGroupId: string, config: SegmentationRepresentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setToolGroupSpecificConfig_2(toolGroupId: string, segmentationRepresentationConfig: SegmentationRepresentationConfig): void;

// @public (undocumented)
function showAllAnnotations(): void;

// @public (undocumented)
function smoothAnnotation(enabledElement: Types_2.IEnabledElement, annotation: PlanarFreehandROIAnnotation, knotsRatioPercentage: number): boolean;

// @public (undocumented)
export class SphereScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentIndex: number;
        segmentsLocked: number[];
        segmentationRepresentationUID: string;
        volumeId: string;
        referencedVolumeId: string;
        imageIdReferenceMap: Map<string, string>;
        toolGroupId: string;
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        centerCanvas?: Array<number>;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => true;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
type SplineContourSegmentationAnnotation = SplineROIAnnotation & ContourSegmentationAnnotationData;

// @public (undocumented)
export class SplineContourSegmentationTool extends SplineROITool {
    constructor(toolProps: PublicToolProps);
    // (undocumented)
    protected isContourSegmentationTool(): boolean;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
type SplineCurveSegment = {
    controlPoints: {
        p0: Types_2.Point2;
        p1: Types_2.Point2;
        p2: Types_2.Point2;
        p3: Types_2.Point2;
    };
    aabb: Types_2.AABB2;
    length: number;
    previousCurveSegmentsLength: number;
    lineSegments: SplineLineSegment[];
};

// @public (undocumented)
type SplineLineSegment = {
    points: {
        start: Types_2.Point2;
        end: Types_2.Point2;
    };
    aabb: Types_2.AABB2;
    length: number;
    previousLineSegmentsLength: number;
};

// @public (undocumented)
type SplineProps = {
    resolution?: number;
    fixedResolution?: boolean;
    closed?: boolean;
};

// @public (undocumented)
type SplineROIAnnotation = ContourAnnotation & {
    data: {
        label?: string;
        spline: {
            type: string;
            instance: ISpline;
            resolution: number;
        };
        cachedStats?: {
            [targetId: string]: {
                Modality: string;
                area: number;
                areaUnit: string;
            };
        };
    };
};

// @public (undocumented)
export class SplineROITool extends ContourSegmentationBaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    static Actions: typeof SplineToolActions;
    // (undocumented)
    addControlPointCallback: (evt: EventTypes_2.InteractionEventType, annotation: SplineROIAnnotation) => void;
    // (undocumented)
    addNewAnnotation(evt: EventTypes_2.InteractionEventType): SplineROIAnnotation;
    // (undocumented)
    cancel(element: HTMLDivElement): string;
    // (undocumented)
    protected createAnnotation(evt: EventTypes_2.InteractionEventType): Annotation;
    // (undocumented)
    protected createInterpolatedSplineControl(annotation: any): void;
    // (undocumented)
    deleteControlPointCallback: (evt: EventTypes_2.InteractionEventType, annotation: SplineROIAnnotation) => void;
    // (undocumented)
    editData: {
        annotation: SplineROIAnnotation;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        lastCanvasPoint?: Types_2.Point2;
        contourHoleProcessingEnabled?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    fireChangeOnUpdate: {
        annotationUID: string;
        changeType: ChangeTypes;
        contourHoleProcessingEnabled: boolean;
    };
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: SplineROIAnnotation, handle: ToolHandle) => void;
    // (undocumented)
    protected isContourSegmentationTool(): boolean;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: SplineROIAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    _isSplineROIAnnotation(annotation: Annotation): annotation is SplineROIAnnotation;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    protected renderAnnotationInstance(renderContext: AnnotationRenderContext): boolean;
    // (undocumented)
    static SplineTypes: typeof SplineTypesEnum;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.InteractionEventType, annotation: SplineROIAnnotation) => void;
    // (undocumented)
    touchDragCallback: any;
    // (undocumented)
    triggerAnnotationCompleted: (annotation: SplineROIAnnotation, contourHoleProcessingEnabled: boolean) => void;
    // (undocumented)
    triggerAnnotationModified: (annotation: SplineROIAnnotation, enabledElement: Types_2.IEnabledElement, changeType?: ChangeTypes) => void;
    // (undocumented)
    triggerChangeEvent: (annotation: SplineROIAnnotation, enabledElement: Types_2.IEnabledElement, changeType: ChangeTypes, contourHoleProcessingEnabled: any) => void;
}

// @public (undocumented)
const stackContextPrefetch: {
    enable: (element: any) => void;
    disable: typeof disable_2;
    getConfiguration: typeof getConfiguration_2;
    setConfiguration: typeof setConfiguration_2;
};

// @public (undocumented)
const stackPrefetch: {
    enable: typeof enable;
    disable: typeof disable;
    getConfiguration: typeof getConfiguration;
    setConfiguration: typeof setConfiguration;
};

// @public (undocumented)
export class StackScrollMouseWheelTool extends BaseTool {
    constructor(toolProps?: {}, defaultToolProps?: {
        supportedInteractionTypes: string[];
        configuration: {
            invert: boolean;
            debounceIfNotLoaded: boolean;
            loop: boolean;
            scrollSlabs: boolean;
        };
    });
    // (undocumented)
    _configuration: any;
    // (undocumented)
    mouseWheelCallback(evt: MouseWheelEventType): void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
export class StackScrollTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    deltaY: number;
    // (undocumented)
    _dragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    _getPixelPerImage(viewport: any): number;
    // (undocumented)
    mouseDragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback(evt: EventTypes_2.InteractionEventType): void;
}

// @public (undocumented)
export let state: ICornerstoneTools3dState;

declare namespace state_2 {
    export {
        getAllAnnotations,
        getAnnotations,
        getParentAnnotation,
        getChildAnnotations,
        clearParentAnnotation,
        addChildAnnotation,
        getNumberOfAnnotations,
        addAnnotation,
        getAnnotation,
        removeAnnotation,
        removeAllAnnotations,
        setAnnotationManager,
        getAnnotationManager,
        resetAnnotationManager,
        invalidateAnnotation
    }
}

declare namespace state_3 {
    export {
        getDefaultSegmentationStateManager,
        getSegmentation,
        getSegmentations,
        addSegmentation,
        removeSegmentation,
        getSegmentationRepresentations,
        addSegmentationRepresentation,
        removeSegmentationRepresentation,
        removeSegmentationRepresentations,
        getToolGroupSpecificConfig,
        setToolGroupSpecificConfig,
        getGlobalConfig,
        setGlobalConfig,
        getSegmentationRepresentationSpecificConfig,
        setSegmentationRepresentationSpecificConfig,
        getSegmentSpecificRepresentationConfig,
        setSegmentSpecificRepresentationConfig,
        getToolGroupIdsWithSegmentation,
        getAllSegmentationRepresentations,
        getSegmentationRepresentationByUID,
        getSegmentationIdRepresentations,
        addColorLUT,
        getColorLUT,
        getNextColorLUTIndex,
        removeColorLUT,
        findSegmentationRepresentationByUID
    }
}

// @public (undocumented)
type Statistics = {
    name: string;
    value: number | number[];
    unit: null | string;
};

// @public (undocumented)
function stopClip(element: HTMLDivElement): void;

// @public (undocumented)
enum StrategyCallbacks {
    // (undocumented)
    AcceptPreview = "acceptPreview",
    // (undocumented)
    CreateIsInThreshold = "createIsInThreshold",
    // (undocumented)
    Fill = "fill",
    // (undocumented)
    Initialize = "initialize",
    // (undocumented)
    INTERNAL_setValue = "setValue",
    // (undocumented)
    OnInteractionEnd = "onInteractionEnd",
    // (undocumented)
    OnInteractionStart = "onInteractionStart",
    // (undocumented)
    Preview = "preview",
    // (undocumented)
    RejectPreview = "rejectPreview",
    // (undocumented)
    StrategyFunction = "strategyFunction"
}

// @public (undocumented)
type StyleConfig = {
    annotations?: {
        [annotationUID: string]: AnnotationStyle_2;
    };
    viewports?: {
        [viewportId: string]: ToolStyleConfig;
    };
    toolGroups?: {
        [toolGroupId: string]: ToolStyleConfig;
    };
    default: ToolStyleConfig;
};

// @public (undocumented)
type StyleSpecifier = {
    viewportId?: string;
    toolGroupId?: string;
    toolName?: string;
    annotationUID?: string;
};

// @public (undocumented)
function subtractPolylines(targetPolyline: Types_2.Point2[], sourcePolyline: Types_2.Point2[]): Types_2.Point2[][];

// @public (undocumented)
type SVGCursorDescriptor = {
    iconContent: string;
    iconSize: number;
    viewBox: SVGPoint_2;
    mousePoint: SVGPoint_2;
    mousePointerGroupString: string;
};

// @public (undocumented)
type SVGDrawingHelper = {
    svgLayerElement: HTMLDivElement;
    svgNodeCacheForCanvas: Record<string, unknown>;
    getSvgNode: (cacheKey: string) => SVGGElement | undefined;
    appendNode: (svgNode: SVGElement, cacheKey: string) => void;
    setNodeTouched: (cacheKey: string) => void;
    clearUntouched: () => void;
};

// @public (undocumented)
class SVGMouseCursor extends ImageMouseCursor {
    constructor(url: string, x?: number, y?: number, name?: string | undefined, fallback?: MouseCursor | undefined);
    // (undocumented)
    static getDefinedCursor(name: string, pointer?: boolean, color?: string): MouseCursor;
}

// @public (undocumented)
type SVGPoint_2 = {
    x: number;
    y: number;
};

// @public (undocumented)
enum Swipe {
    // (undocumented)
    DOWN = "DOWN",
    // (undocumented)
    LEFT = "LEFT",
    // (undocumented)
    RIGHT = "RIGHT",
    // (undocumented)
    UP = "UP"
}

// @public (undocumented)
export class Synchronizer {
    constructor(synchronizerId: string, eventName: string, eventHandler: ISynchronizerEventHandler, options?: any);
    // (undocumented)
    add(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    addSource(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    addTarget(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    getOptions(viewportId: string): Record<string, unknown> | undefined;
    // (undocumented)
    getSourceViewports(): Array<Types_2.IViewportId>;
    // (undocumented)
    getTargetViewports(): Array<Types_2.IViewportId>;
    // (undocumented)
    hasSourceViewport(renderingEngineId: string, viewportId: string): boolean;
    // (undocumented)
    hasTargetViewport(renderingEngineId: string, viewportId: string): boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    isDisabled(): boolean;
    // (undocumented)
    remove(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    removeSource(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    removeTarget(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    setOptions(viewportId: string, options?: Record<string, unknown>): void;
}

declare namespace SynchronizerManager {
    export {
        createSynchronizer,
        destroy_2 as destroy,
        getSynchronizer,
        getSynchronizersForViewport,
        getAllSynchronizers,
        destroySynchronizer
    }
}
export { SynchronizerManager }

declare namespace synchronizers {
    export {
        createCameraPositionSynchronizer,
        createVOISynchronizer,
        createZoomPanSynchronizer,
        createImageSliceSynchronizer,
        createStackImageSynchronizer
    }
}
export { synchronizers }

// @public (undocumented)
type TextBoxHandle = {
    hasMoved: boolean;
    worldBoundingBox: {
        bottomLeft: Types_2.Point3;
        bottomRight: Types_2.Point3;
        topLeft: Types_2.Point3;
        topRight: Types_2.Point3;
    };
    worldPosition: Types_2.Point3;
};

// @public (undocumented)
function thresholdSegmentationByRange(segmentationVolume: Types_2.IImageVolume, segmentationIndex: number, thresholdVolumeInformation: ThresholdInformation[], overlapType: number): Types_2.IImageVolume;

// @public (undocumented)
function thresholdVolumeByRange(segmentationVolume: Types_2.IImageVolume, thresholdVolumeInformation: ThresholdInformation[], options: ThresholdRangeOptions): Types_2.IImageVolume;

// @public (undocumented)
function throttle(func: Function, wait?: number, options?: {
    leading?: boolean;
    trailing?: boolean;
}): Function;

// @public (undocumented)
type ToolAction = {
    method: string | ((evt: InteractionEventType, annotation: Annotation) => void);
    bindings: SetToolBindingsType[];
};

// @public (undocumented)
type ToolActivatedEventDetail = {
    toolGroupId: string;
    toolName: string;
    toolBindingsOptions: SetToolBindingsType;
};

// @public (undocumented)
type ToolActivatedEventType = Types_2.CustomEventType<ToolActivatedEventDetail>;

// @public (undocumented)
type ToolConfiguration = Record<string, any> & {
    statsCalculator?: Calculator;
};

// @public (undocumented)
interface ToolData {
    // (undocumented)
    dynamicCineEnabled?: boolean;
    // (undocumented)
    framesPerSecond: number;
    // (undocumented)
    frameTimeVector: number[] | undefined;
    // (undocumented)
    ignoreFrameTimeVector: boolean;
    // (undocumented)
    intervalId: number | undefined;
    // (undocumented)
    lastFrameTimeStamp: number | undefined;
    // (undocumented)
    loop: boolean;
    // (undocumented)
    reverse: boolean;
    // (undocumented)
    speed: number;
    // (undocumented)
    usingFrameTimeVector: boolean;
}

declare namespace ToolGroupManager {
    export {
        createToolGroup,
        destroy_3 as destroy,
        destroyToolGroup,
        getToolGroup,
        getToolGroupForViewport,
        getAllToolGroups,
        getToolGroupsWithToolName
    }
}
export { ToolGroupManager }

// @public (undocumented)
type ToolGroupSpecificContourRepresentation = ToolGroupSpecificRepresentationState & {
    config: ContourRenderingConfig;
    segmentationRepresentationSpecificConfig?: RepresentationConfig;
    segmentSpecificConfig?: SegmentSpecificRepresentationConfig;
};

// @public (undocumented)
type ToolGroupSpecificLabelmapRepresentation = ToolGroupSpecificRepresentationState & {
    config: LabelmapRenderingConfig;
    segmentationRepresentationSpecificConfig?: RepresentationConfig;
    segmentSpecificConfig?: SegmentSpecificRepresentationConfig;
};

// @public (undocumented)
type ToolGroupSpecificRepresentation = ToolGroupSpecificLabelmapRepresentation | ToolGroupSpecificContourRepresentation;

// @public (undocumented)
type ToolGroupSpecificRepresentationState = {
    segmentationRepresentationUID: string;
    segmentationId: string;
    type: Enums.SegmentationRepresentations;
    active: boolean;
    segmentsHidden: Set<number>;
    colorLUTIndex: number;
    polySeg?: {
        enabled: boolean;
        options?: any;
    };
};

// @public (undocumented)
type ToolHandle = AnnotationHandle | TextBoxHandle;

// @public (undocumented)
type ToolModeChangedEventDetail = {
    toolGroupId: string;
    toolName: string;
    mode: ToolModes;
    toolBindingsOptions?: SetToolBindingsType;
};

// @public (undocumented)
type ToolModeChangedEventType = Types_2.CustomEventType<ToolModeChangedEventDetail>;

// @public (undocumented)
enum ToolModes {
    // (undocumented)
    Active = "Active",
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled",
    // (undocumented)
    Passive = "Passive"
}

// @public (undocumented)
type ToolOptionsType = {
    bindings: IToolBinding[];
    mode: ToolModes;
};

// @public (undocumented)
type ToolProps = SharedToolProp;

declare namespace ToolSpecificAnnotationTypes {
    export {
        RectangleROIAnnotation,
        ProbeAnnotation,
        LengthAnnotation,
        AdvancedMagnifyAnnotation,
        CircleROIAnnotation,
        SplineROIAnnotation,
        SplineContourSegmentationAnnotation,
        LivewireContourAnnotation,
        LivewireContourSegmentationAnnotation,
        EllipticalROIAnnotation,
        BidirectionalAnnotation,
        RectangleROIThresholdAnnotation,
        RectangleROIStartEndThresholdAnnotation,
        CircleROIStartEndThresholdAnnotation,
        PlanarFreehandROIAnnotation,
        PlanarFreehandContourSegmentationAnnotation,
        InterpolationROIAnnotation,
        ArrowAnnotation,
        AngleAnnotation,
        UltrasoundDirectionalAnnotation,
        CobbAngleAnnotation,
        ReferenceCursor,
        ReferenceLineAnnotation,
        ScaleOverlayAnnotation,
        VideoRedactionAnnotation,
        ContourAnnotation
    }
}

// @public (undocumented)
const toolStyle: ToolStyle;

// @public (undocumented)
type ToolStyleConfig = {
    [toolName: string]: AnnotationStyle_2;
} & {
    global?: AnnotationStyle_2;
};

declare namespace touch {
    export {
        getMeanPoints,
        getMeanTouchPoints,
        copyPoints,
        copyPointsList,
        getDeltaDistanceBetweenIPoints,
        getDeltaPoints,
        getDeltaDistance,
        getDeltaRotation
    }
}

// @public (undocumented)
type TouchDragEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & TouchPointsDetail;

// @public (undocumented)
type TouchDragEventType = Types_2.CustomEventType<TouchDragEventDetail>;

// @public (undocumented)
type TouchEndEventDetail = NormalizedInteractionEventDetail & TouchPointsDetail & TouchCustomEventDetail;

// @public (undocumented)
type TouchEndEventType = Types_2.CustomEventType<TouchEndEventDetail>;

// @public (undocumented)
type TouchPressEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & {
    startPointsList: ITouchPoints[];
    lastPointsList: ITouchPoints[];
    startPoints: ITouchPoints;
    lastPoints: ITouchPoints;
};

// @public (undocumented)
type TouchPressEventType = Types_2.CustomEventType<TouchPressEventDetail>;

// @public (undocumented)
type TouchStartActivateEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & TouchPointsDetail;

// @public (undocumented)
type TouchStartActivateEventType = Types_2.CustomEventType<TouchStartActivateEventDetail>;

// @public (undocumented)
type TouchStartEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & TouchPointsDetail;

// @public (undocumented)
type TouchStartEventType = Types_2.CustomEventType<TouchStartEventDetail>;

// @public (undocumented)
type TouchSwipeEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & {
    swipe: Swipe;
};

// @public (undocumented)
type TouchSwipeEventType = Types_2.CustomEventType<TouchSwipeEventDetail>;

// @public (undocumented)
type TouchTapEventDetail = NormalizedInteractionEventDetail & TouchCustomEventDetail & {
    currentPointsList: ITouchPoints[];
    currentPoints: ITouchPoints;
    taps: number;
};

// @public (undocumented)
type TouchTapEventType = Types_2.CustomEventType<TouchTapEventDetail>;

// @public (undocumented)
export class TrackballRotateTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    mouseDragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    rotateCamera: (viewport: any, centerWorld: any, axis: any, angle: any) => void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: (evt: EventTypes_2.InteractionEventType) => void;
}

// @public (undocumented)
function triggerAnnotationRender(element: HTMLDivElement): void;

// @public (undocumented)
function triggerAnnotationRenderForToolGroupIds(toolGroupIds: string[]): void;

// @public (undocumented)
function triggerAnnotationRenderForViewportIds(renderingEngine: Types_2.IRenderingEngine, viewportIdsToRender: string[]): void;

// @public (undocumented)
function triggerEvent(el: EventTarget, type: string, detail?: unknown): boolean;

// @public (undocumented)
function triggerSegmentationDataModified(segmentationId: string, modifiedSlicesToUse?: number[]): void;

declare namespace triggerSegmentationEvents {
    export {
        triggerSegmentationRepresentationModified,
        triggerSegmentationRepresentationRemoved,
        triggerSegmentationDataModified,
        triggerSegmentationModified,
        triggerSegmentationRemoved
    }
}

// @public (undocumented)
function triggerSegmentationModified(segmentationId?: string): void;

// @public (undocumented)
function triggerSegmentationRemoved(segmentationId: string): void;

// @public (undocumented)
function triggerSegmentationRender(toolGroupId: string): void;

// @public (undocumented)
function triggerSegmentationRepresentationModified(toolGroupId: string, segmentationRepresentationUID?: string): void;

// @public (undocumented)
function triggerSegmentationRepresentationRemoved(toolGroupId: string, segmentationRepresentationUID: string): void;

declare namespace Types {
    export {
        Annotation,
        Annotations,
        ContourAnnotationData,
        ContourAnnotation,
        ContourSegmentationAnnotationData,
        ContourSegmentationAnnotation,
        BidirectionalData,
        CanvasCoordinates,
        IAnnotationManager,
        InterpolationViewportData,
        ImageInterpolationData,
        GroupSpecificAnnotations,
        AnnotationState,
        AnnotationStyle,
        ToolSpecificAnnotationTypes,
        JumpToSliceOptions,
        AnnotationGroupSelector,
        AnnotationRenderContext,
        PlanarBoundingBox,
        ToolProps,
        PublicToolProps,
        ToolConfiguration,
        EventTypes_2 as EventTypes,
        IPoints,
        ITouchPoints,
        IDistance,
        IToolBinding,
        SetToolBindingsType,
        ToolOptionsType,
        InteractionTypes,
        ToolAction,
        IToolGroup,
        IToolClassReference,
        ISynchronizerEventHandler,
        ToolHandle,
        AnnotationHandle,
        TextBoxHandle,
        Segmentation,
        SegmentationState,
        SegmentationRepresentationData,
        SegmentationRepresentationConfig,
        RepresentationConfig,
        ToolGroupSpecificRepresentationState,
        ToolGroupSpecificContourRepresentation,
        ToolGroupSpecificLabelmapRepresentation,
        ToolGroupSpecificRepresentation,
        RepresentationPublicInput,
        LabelmapTypes,
        SVGCursorDescriptor,
        SVGPoint_2 as SVGPoint,
        ScrollOptions_2 as ScrollOptions,
        CINETypes,
        BoundsIJK_2 as BoundsIJK,
        SVGDrawingHelper,
        FloodFillResult,
        FloodFillGetter,
        FloodFillOptions,
        ContourSegmentationData,
        Statistics,
        LabelmapToolOperationData,
        LabelmapToolOperationDataStack,
        LabelmapToolOperationDataVolume,
        CardinalSplineProps,
        ClosestControlPoint,
        ClosestPoint,
        ClosestSplinePoint,
        ControlPointInfo,
        ISpline,
        SplineCurveSegment,
        SplineLineSegment,
        SplineProps,
        PolySegConversionOptions
    }
}
export { Types }

declare namespace Types_3 {
    export {
        ColorbarCommonProps,
        ColorbarProps,
        ColorbarImageRange,
        ColorbarVOIRange,
        ColorbarSize,
        ColorbarTicksProps,
        ColorbarTicksStyle,
        ViewportColorbarProps
    }
}

// @public (undocumented)
interface UltrasoundDirectionalAnnotation extends Annotation {
    // (undocumented)
    data: {
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
            textBox: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
        };
        label: string;
        cachedStats: {
            [targetId: string]: {
                xValues: number[];
                yValues: number[];
                units: string[];
                isHorizontal: boolean;
                isUnitless: boolean;
            };
        };
    };
}

// @public (undocumented)
export class UltrasoundDirectionalTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => UltrasoundDirectionalAnnotation;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLDivElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLDivElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLDivElement) => void;
    // (undocumented)
    _dragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _endCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: UltrasoundDirectionalAnnotation, handle: ToolHandle): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLDivElement, annotation: UltrasoundDirectionalAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    startedDrawing: boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    toolSelectedCallback(evt: EventTypes_2.InteractionEventType, annotation: Annotation, interactionType: InteractionTypes, canvasCoords?: Types_2.Point2): void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function unlockAllAnnotations(): void;

// @public (undocumented)
function updateContourPolyline(annotation: ContourAnnotation, polylineData: {
    points: Types_2.Point2[];
    closed?: boolean;
    targetWindingDirection?: ContourWindingDirection;
}, transforms: {
    canvasToWorld: (point: Types_2.Point2) => Types_2.Point3;
}, options?: {
    decimate?: {
        enabled?: boolean;
        epsilon?: number;
    };
}): void;

declare namespace utilities {
    export {
        math,
        planar,
        viewportFilters,
        drawing_2 as drawing,
        debounce,
        dynamicVolume,
        throttle,
        orientation_2 as orientation,
        isObject,
        touch,
        triggerEvent,
        calibrateImageSpacing,
        getCalibratedLengthUnits,
        getCalibratedAreaUnits,
        getCalibratedScale,
        segmentation_2 as segmentation,
        contours,
        triggerAnnotationRenderForViewportIds,
        triggerAnnotationRenderForToolGroupIds,
        triggerAnnotationRender,
        pointInShapeCallback,
        getSphereBoundsInfo,
        getAnnotationNearPoint,
        getViewportForAnnotation,
        getAnnotationNearPointOnEnabledElement,
        jumpToSlice,
        pointInSurroundingSphereCallback,
        viewport,
        cine,
        clip_2 as clip,
        boundingBox,
        rectangleROITool,
        planarFreehandROITool,
        stackPrefetch,
        stackContextPrefetch,
        scroll_2 as scroll,
        roundNumber,
        pointToString,
        polyDataUtils,
        voi,
        AnnotationFrameRange as annotationFrameRange,
        contourSegmentation
    }
}
export { utilities }

declare namespace vec2 {
    export {
        findClosestPoint,
        clip as liangBarksyClip
    }
}

// @public (undocumented)
interface VideoRedactionAnnotation extends Annotation {
    // (undocumented)
    data: {
        invalidated: boolean;
        handles: {
            points: Types_2.Point3[];
            activeHandleIndex: number | null;
        };
        cachedStats: {
            [key: string]: any;
        };
        active: boolean;
    };
    // (undocumented)
    metadata: {
        viewPlaneNormal: Types_2.Point3;
        viewUp: Types_2.Point3;
        FrameOfReferenceUID: string;
        referencedImageId: string;
        toolName: string;
    };
}

// @public (undocumented)
export class VideoRedactionTool extends AnnotationTool {
    constructor(toolConfiguration?: {});
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.InteractionEventType) => VideoRedactionAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewPlaneNormal: any, viewUp: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel(element: any): any;
    // (undocumented)
    _configuration: any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportUIDsToRender: string[];
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    getHandleNearImagePoint: (element: any, annotation: any, canvasCoords: any, proximity: any) => any;
    // (undocumented)
    _getImageVolumeFromTargetUID(targetUID: any, renderingEngine: any): {
        imageVolume: any;
        viewport: any;
    };
    // (undocumented)
    _getRectangleImageCoordinates: (points: Array<Types_2.Point2>) => {
        left: number;
        top: number;
        width: number;
        height: number;
    };
    // (undocumented)
    _getTargetStackUID(viewport: any): string;
    // (undocumented)
    _getTargetVolumeUID: (scene: any) => any;
    // (undocumented)
    handleSelectedCallback: (evt: any, annotation: any, handle: any, interactionType?: string) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: any, annotation: any, canvasCoords: any, proximity: any) => boolean;
    // (undocumented)
    _mouseDragCallback: (evt: any) => void;
    // (undocumented)
    _mouseUpCallback: (evt: any) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: SVGDrawingHelper) => boolean;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    toolSelectedCallback: (evt: any, annotation: any, interactionType?: string) => void;
}

declare namespace viewport {
    export {
        isViewportPreScaled,
        jumpToSlice,
        jumpToWorld
    }
}

// @public (undocumented)
class ViewportColorbar extends Colorbar {
    constructor(props: ViewportColorbarProps);
    // (undocumented)
    get element(): HTMLDivElement;
    // (undocumented)
    get enabledElement(): Types_2.IEnabledElement;
    // (undocumented)
    protected getVOIMultipliers(): [number, number];
    // (undocumented)
    protected onVoiChange(voiRange: ColorbarVOIRange): void;
}

// @public (undocumented)
type ViewportColorbarProps = ColorbarProps & {
    element: HTMLDivElement;
    volumeId?: string;
};

declare namespace viewportFilters {
    export {
        filterViewportsWithToolEnabled,
        filterViewportsWithFrameOfReferenceUID,
        getViewportIdsWithToolToRender,
        filterViewportsWithParallelNormals
    }
}

declare namespace visibility {
    export {
        setAnnotationVisibility,
        showAllAnnotations,
        isAnnotationVisible,
        checkAndDefineIsVisibleProperty
    }
}

declare namespace visibility_2 {
    export {
        setSegmentationVisibility,
        getSegmentationVisibility,
        setSegmentVisibility,
        setSegmentsVisibility,
        getSegmentVisibility
    }
}

declare namespace voi {
    export {
        colorbar
    }
}

// @public (undocumented)
export class VolumeRotateMouseWheelTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _configuration: any;
    // (undocumented)
    mouseWheelCallback(evt: MouseWheelEventType): void;
    // (undocumented)
    static toolName: any;
}

// @public (undocumented)
type VolumeScrollOutOfBoundsEventDetail = {
    volumeId: string;
    viewport: Types_2.IVolumeViewport;
    desiredStepIndex: number;
    currentStepIndex: number;
    delta: number;
    numScrollSteps: number;
    currentImageId: string;
};

// @public (undocumented)
type VolumeScrollOutOfBoundsEventType = Types_2.CustomEventType<VolumeScrollOutOfBoundsEventDetail>;

// @public (undocumented)
export class WindowLevelTool extends BaseTool {
    constructor(toolProps?: {}, defaultToolProps?: {
        supportedInteractionTypes: string[];
    });
    // (undocumented)
    _getImageDynamicRangeFromMiddleSlice: (scalarData: any, dimensions: any) => number;
    // (undocumented)
    _getImageDynamicRangeFromViewport(viewport: any): number;
    // (undocumented)
    _getMultiplierFromDynamicRange(viewport: any, volumeId: any): number;
    // (undocumented)
    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }: {
        viewport: any;
        deltaPointsCanvas: any;
        volumeId: any;
        lower: any;
        upper: any;
    }): {
        lower: number;
        upper: number;
    };
    // (undocumented)
    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }: {
        deltaPointsCanvas: any;
        lower: any;
        upper: any;
        clientHeight: any;
        viewport: any;
        volumeId: any;
        isPreScaled: any;
    }): {
        lower: any;
        upper: any;
    };
    // (undocumented)
    mouseDragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback(evt: EventTypes_2.InteractionEventType): void;
}

// @public (undocumented)
export class ZoomTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    dirVec: Types_2.Point3;
    // (undocumented)
    _dragCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    _dragParallelProjection: (evt: EventTypes_2.InteractionEventType, viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, camera: Types_2.ICamera, pinch?: boolean) => void;
    // (undocumented)
    _dragPerspectiveProjection: (evt: EventTypes_2.InteractionEventType, viewport: Types_2.IStackViewport | Types_2.IVolumeViewport, camera: Types_2.ICamera, pinch?: boolean) => void;
    // (undocumented)
    initialMousePosWorld: Types_2.Point3;
    // (undocumented)
    mouseDragCallback: (evt: EventTypes_2.InteractionEventType) => void;
    // (undocumented)
    _panCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    _pinchCallback(evt: EventTypes_2.InteractionEventType): void;
    // (undocumented)
    preMouseDownCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    preTouchStartCallback: (evt: EventTypes_2.InteractionEventType) => boolean;
    // (undocumented)
    static toolName: any;
    // (undocumented)
    touchDragCallback: (evt: EventTypes_2.InteractionEventType) => void;
}

// (No @packageDocumentation comment for this package)

```

## API Report File for "@cornerstonejs/tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { mat4 } from 'gl-matrix';
import type { vtkColorTransferFunction } from 'vtk.js/Sources/Rendering/Core/ColorTransferFunction';
import type { vtkImageData } from 'vtk.js/Sources/Common/DataModel/ImageData';
import type { vtkPiecewiseFunction } from 'vtk.js/Sources/Common/DataModel/PiecewiseFunction';
import type { vtkVolume } from 'vtk.js/Sources/Rendering/Core/Volume';

declare namespace activeSegmentation {
    export {
        getActiveSegmentationInfo,
        setActiveSegmentation,
        _default_3 as default
    }
}

// @public
type ActorEntry = {
    uid: string
    volumeActor: VolumeActor
    slabThickness?: number
}

// @public (undocumented)
function addAnnotation(element: HTMLElement, annotation: Annotation): void;

// @public (undocumented)
function addColorLUT(colorLut: ColorLUT, index: number): void;

// @public (undocumented)
function addColorLUT_2(colorLUT: ColorLUT, colorLUTIndex: number): void;

// @public (undocumented)
function addGlobalSegmentationData(segmentationData: GlobalSegmentationData, suppressEvents?: boolean): void;

// @public (undocumented)
function addSegmentationData(toolGroupId: string, segmentationData: ToolGroupSpecificSegmentationData, suppressEvents?: boolean): void;

// @public (undocumented)
function addSegmentationsForToolGroup(toolGroupId: string, segmentationDataArray: SegmentationDataInput[], toolGroupSpecificConfig?: SegmentationConfig): Promise<void>;

// @public (undocumented)
export function addTool(ToolClass: any): void;

// @public (undocumented)
type Annotation = {
    annotationUID?: string;
    highlighted?: boolean;
    isLocked?: boolean;
    invalidated?: boolean;
    metadata: {
        cameraPosition?: Types_2.Point3;
        cameraFocalPoint?: Types_2.Point3;
        viewPlaneNormal?: Types_2.Point3;
        viewUp?: Types_2.Point3;
        FrameOfReferenceUID: string;
        toolName: string;
        referencedImageId?: string;
        volumeId?: string;
    };
    data: {
        handles?: {
            points?: Types_2.Point3[];
            activeHandleIndex?: number | null;
            textBox?: {
                hasMoved: boolean;
                worldPosition: Types_2.Point3;
                worldBoundingBox: {
                    topLeft: Types_2.Point3;
                    topRight: Types_2.Point3;
                    bottomLeft: Types_2.Point3;
                    bottomRight: Types_2.Point3;
                };
            };
            [key: string]: any;
        };
        cachedStats?: unknown;
    };
};

declare namespace annotation {
    export {
        config,
        locking,
        selection,
        state
    }
}
export { annotation }

// @public (undocumented)
type AnnotationAddedEventDetail = {
    viewportId: string;
    renderingEngineId: string;
    annotation: Annotation;
};

// @public (undocumented)
type AnnotationAddedEventType = Types_2.CustomEventType<AnnotationAddedEventDetail>;

// @public (undocumented)
type AnnotationHandle = Types_2.Point3;

// @public (undocumented)
type AnnotationLockChangeEventDetail = {
    added: Array<Annotation>;
    removed: Array<Annotation>;
    locked: Array<Annotation>;
};

// @public (undocumented)
type AnnotationLockChangeEventType = Types_2.CustomEventType<AnnotationLockChangeEventDetail>;

// @public (undocumented)
type AnnotationModifiedEventDetail = {
    viewportId: string;
    renderingEngineId: string;
    annotation: Annotation;
};

// @public (undocumented)
type AnnotationModifiedEventType = Types_2.CustomEventType<AnnotationModifiedEventDetail>;

// @public (undocumented)
type AnnotationRemovedEventDetail = {
    viewportId: string;
    renderingEngineId: string;
    annotation: Annotation;
};

// @public (undocumented)
type AnnotationRemovedEventType = Types_2.CustomEventType<AnnotationRemovedEventDetail>;

// @public (undocumented)
type AnnotationRenderedEventDetail = {
    element: HTMLElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type AnnotationRenderedEventType = Types_2.CustomEventType<AnnotationRenderedEventDetail>;

// @public (undocumented)
type Annotations = Array<Annotation>;

// @public (undocumented)
type AnnotationSelectionChangeEventDetail = {
    added: Array<Annotation>;
    removed: Array<Annotation>;
    selection: Array<Annotation>;
};

// @public (undocumented)
type AnnotationSelectionChangeEventType = Types_2.CustomEventType<AnnotationSelectionChangeEventDetail>;

// @public (undocumented)
type AnnotationState = {
    [key: string]: FrameOfReferenceSpecificAnnotations;
};

// @public (undocumented)
export abstract class AnnotationTool extends BaseTool {
    // (undocumented)
    abstract addNewAnnotation(evt: EventTypes_2.MouseDownActivateEventType, interactionType: InteractionTypes): Annotation;
    // (undocumented)
    abstract cancel(element: HTMLElement): any;
    // (undocumented)
    filterInteractableAnnotationsForElement(element: HTMLElement, annotations: Annotations): Annotations | undefined;
    // (undocumented)
    getHandleNearImagePoint(element: HTMLElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    getLinkedTextBoxStyle(settings: Settings, annotation?: Annotation): Record<string, unknown>;
    // (undocumented)
    getStyle(settings: Settings, property: string, annotation?: Annotation): unknown;
    // (undocumented)
    abstract handleSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: Annotation, handle: ToolHandle, interactionType: InteractionTypes): void;
    // (undocumented)
    abstract isPointNearTool(element: HTMLElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number, interactionType: string): boolean;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.MouseMoveEventType, filteredAnnotations: Annotations) => boolean;
    // (undocumented)
    onImageSpacingCalibrated: (evt: Types_2.EventTypes.ImageSpacingCalibratedEvent) => void;
    // (undocumented)
    abstract renderAnnotation(enabledElement: Types_2.IEnabledElement, svgDrawingHelper: any): any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    abstract toolSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: Annotation, interactionType: InteractionTypes): void;
}

// @public (undocumented)
export abstract class BaseTool implements IBaseTool {
    constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps);
    // (undocumented)
    applyActiveStrategy(enabledElement: Types_2.IEnabledElement, operationData: unknown): any;
    // (undocumented)
    configuration: Record<string, any>;
    // (undocumented)
    protected getTargetId(viewport: Types_2.IViewport): string | undefined;
    // (undocumented)
    protected getTargetIdViewportAndImage(targetId: string, renderingEngine: Types_2.IRenderingEngine): {
        viewport: Types_2.IViewport;
        image: Types_2.IImageData;
    };
    // (undocumented)
    getToolName(): string;
    // (undocumented)
    mode: ToolModes;
    // (undocumented)
    setActiveStrategy(strategyName: string): void;
    // (undocumented)
    setConfiguration(newConfiguration: Record<string, any>): void;
    // (undocumented)
    supportedInteractionTypes: InteractionTypes[];
    // (undocumented)
    toolGroupId: string;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
export class BidirectionalTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation(evt: EventTypes_2.MouseDownActivateEventType): BidirectionalAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    _calculateLength(pos1: any, pos2: any): number;
    // (undocumented)
    cancel: (element: HTMLElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getTextLines: (data: any, targetId: any) => string[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: BidirectionalAnnotation, handle: ToolHandle, interactionType?: string) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, index3: any, index4: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLElement, annotation: BidirectionalAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragDrawCallback: (evt: MouseMoveEventType | MouseDragEventType) => void;
    // (undocumented)
    _mouseDragModifyCallback: (evt: MouseDragEventType) => void;
    // (undocumented)
    _mouseDragModifyHandle: (evt: any) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    _movingLongAxisWouldPutItThroughShortAxis: (proposedFirstLineSegment: any, secondLineSegment: any) => boolean;
    // (undocumented)
    preventHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: any) => void;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: BidirectionalAnnotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
function calibrateImageSpacing(imageId: string, renderingEngine: Types_2.IRenderingEngine, rowPixelSpacing: number, columnPixelSpacing: number): void;

// @public
type CameraModifiedEvent = CustomEvent_2<CameraModifiedEventDetail>

// @public
type CameraModifiedEventDetail = {
    previousCamera: ICamera
    camera: ICamera
    element: HTMLElement
    viewportId: string
    renderingEngineId: string
}

// @public (undocumented)
export function cancelActiveManipulations(element: HTMLElement): string | undefined;

// @public (undocumented)
function checkAndDefineIsLockedProperty(annotation: Annotation): void;

// @public (undocumented)
export class CircleScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentation: any;
        segmentIndex: number;
        segmentationDataUID: string;
        segmentsLocked: number[];
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        centerCanvas?: Array<number>;
    } | null;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: any) => void;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
type Color = [number, number, number, number];

// @public (undocumented)
type ColorLUT = Array<Color>;

declare namespace config {
    export {
        getState,
        getStyle,
        getFont,
        setAnnotationStyle,
        setGlobalStyle,
        setToolStyle
    }
}

// @public (undocumented)
interface CPUFallbackColormap {
    // (undocumented)
    addColor: (rgba: Point4) => void
    // (undocumented)
    buildLookupTable: (lut: CPUFallbackLookupTable) => void
    // (undocumented)
    clearColors: () => void
    // (undocumented)
    createLookupTable: () => CPUFallbackLookupTable
    // (undocumented)
    getColor: (index: number) => Point4
    // (undocumented)
    getColorRepeating: (index: number) => Point4
    // (undocumented)
    getColorSchemeName: () => string
    getId: () => string
    // (undocumented)
    getNumberOfColors: () => number
    // (undocumented)
    insertColor: (index: number, rgba: Point4) => void
    // (undocumented)
    isValidIndex: (index: number) => boolean
    // (undocumented)
    removeColor: (index: number) => void
    // (undocumented)
    setColor: (index: number, rgba: Point4) => void
    // (undocumented)
    setColorSchemeName: (name: string) => void
    // (undocumented)
    setNumberOfColors: (numColors: number) => void
}

// @public (undocumented)
type CPUFallbackColormapData = {
    name: string;
    numOfColors?: number;
    colors?: Point4[];
    segmentedData?: unknown;
    numColors?: number;
    gamma?: number;
};

// @public (undocumented)
type CPUFallbackColormapsData = {
    [key: string]: CPUFallbackColormapData;
};

// @public (undocumented)
interface CPUFallbackEnabledElement {
    // (undocumented)
    canvas?: HTMLCanvasElement
    // (undocumented)
    colormap?: CPUFallbackColormap
    // (undocumented)
    image?: IImage
    // (undocumented)
    invalid?: boolean
    // (undocumented)
    metadata?: {
        direction?: Float32Array
        dimensions?: Point3
        spacing?: Point3
        origin?: Point3
        imagePlaneModule?: {
            frameOfReferenceUID: string
            rows: number
            columns: number
            imageOrientationPatient: number[]
            rowCosines: Point3
            columnCosines: Point3
            imagePositionPatient: number[]
            sliceThickness?: number
            sliceLocation?: number
            pixelSpacing: Point2
            rowPixelSpacing: number
            columnPixelSpacing: number
        }
        imagePixelModule?: {
            samplesPerPixel: number
            photometricInterpretation: string
            rows: number
            columns: number
            bitsAllocated: number
            bitsStored: number
            highBit: number
            pixelRepresentation: number
            planarConfiguration?: number
            pixelAspectRatio?: number
            smallestPixelValue?: number
            largestPixelValue?: number
            redPaletteColorLookupTableDescriptor?: number[]
            greenPaletteColorLookupTableDescriptor?: number[]
            bluePaletteColorLookupTableDescriptor?: number[]
            redPaletteColorLookupTableData: number[]
            greenPaletteColorLookupTableData: number[]
            bluePaletteColorLookupTableData: number[]
        }
    }
    // (undocumented)
    needsRedraw?: boolean
    // (undocumented)
    options?: {
        [key: string]: unknown
        colormap?: CPUFallbackColormap
    }
    // (undocumented)
    pan?: Point2
    // (undocumented)
    renderingTools?: CPUFallbackRenderingTools
    // (undocumented)
    rotation?: number
    // (undocumented)
    scale?: number
    // (undocumented)
    transform?: CPUFallbackTransform
    // (undocumented)
    viewport?: CPUFallbackViewport
    // (undocumented)
    zoom?: number
}

// @public (undocumented)
interface CPUFallbackLookupTable {
    // (undocumented)
    build: (force: boolean) => void;
    // (undocumented)
    getColor: (scalar: number) => Point4;
    // (undocumented)
    setAlphaRange: (start: number, end: number) => void;
    // (undocumented)
    setHueRange: (start: number, end: number) => void;
    // (undocumented)
    setNumberOfTableValues: (number: number) => void;
    // (undocumented)
    setRamp: (ramp: string) => void;
    // (undocumented)
    setRange: (start: number, end: number) => void;
    // (undocumented)
    setSaturationRange: (start: number, end: number) => void;
    // (undocumented)
    setTableRange: (start: number, end: number) => void;
    // (undocumented)
    setTableValue(index: number, rgba: Point4);
    // (undocumented)
    setValueRange: (start: number, end: number) => void;
}

// @public (undocumented)
type CPUFallbackLUT = {
    lut: number[];
};

// @public (undocumented)
type CPUFallbackRenderingTools = {
    renderCanvas?: HTMLCanvasElement;
    lastRenderedIsColor?: boolean;
    lastRenderedImageId?: string;
    lastRenderedViewport?: {
        windowWidth: number | number[];
        windowCenter: number | number[];
        invert: boolean;
        rotation: number;
        hflip: boolean;
        vflip: boolean;
        modalityLUT: CPUFallbackLUT;
        voiLUT: CPUFallbackLUT;
        colormap: unknown;
    };
    renderCanvasContext?: {
        putImageData: (
        renderCanvasData: unknown,
        dx: number,
        dy: number
        ) => unknown;
    };
    colormapId?: string;
    colorLut?: CPUFallbackLookupTable;
    renderCanvasData?: {
        data: Uint8ClampedArray;
    };
};

// @public (undocumented)
interface CPUFallbackTransform {
    // (undocumented)
    clone: () => CPUFallbackTransform;
    // (undocumented)
    getMatrix: () => TransformMatrix2D;
    // (undocumented)
    invert: () => void;
    // (undocumented)
    multiply: (matrix: TransformMatrix2D) => void;
    // (undocumented)
    reset: () => void;
    // (undocumented)
    rotate: (rad: number) => void;
    // (undocumented)
    scale: (sx: number, sy: number) => void;
    // (undocumented)
    transformPoint: (point: Point2) => Point2;
    // (undocumented)
    translate: (x: number, y: number) => void;
}

// @public (undocumented)
type CPUFallbackViewport = {
    scale?: number;
    translation?: {
        x: number;
        y: number;
    };
    voi?: {
        windowWidth: number;
        windowCenter: number;
    };
    invert?: boolean;
    pixelReplication?: boolean;
    rotation?: number;
    hflip?: boolean;
    vflip?: boolean;
    modalityLUT?: CPUFallbackLUT;
    voiLUT?: CPUFallbackLUT;
    colormap?: CPUFallbackColormap;
    displayedArea?: CPUFallbackViewportDisplayedArea;
    modality?: string;
};

// @public (undocumented)
type CPUFallbackViewportDisplayedArea = {
    tlhc: {
        x: number;
        y: number;
    };
    brhc: {
        x: number;
        y: number;
    };
    rowPixelSpacing: number;
    columnPixelSpacing: number;
    presentationSizeMode: string;
};

// @public (undocumented)
type CPUIImageData = {
    dimensions: Point3
    direction: Float32Array
    spacing: Point3
    origin: Point3
    imageData: CPUImageData
    metadata: { Modality: string }
    scalarData: number[]
    scaling: Scaling
}

// @public (undocumented)
type CPUImageData = {
    worldToIndex?: (point: Point3) => Point3
    indexToWorld?: (point: Point3) => Point3
    getWorldToIndex?: () => Point3
    getIndexToWorld?: () => Point3
    getSpacing?: () => Point3
    getDirection?: () => Float32Array
    getScalarData?: () => number[]
    getDimensions?: () => Point3
}

// @public (undocumented)
function createCameraPositionSynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
function createMergedLabelmapForIndex(labelmaps: Array<Types_2.IImageVolume>, segmentIndex?: number, uid?: string): Types_2.IImageVolume;

// @public (undocumented)
function createNewSegmentationForToolGroup(toolGroupId: string, options?: {
    volumeId?: string;
    scalarData?: Float32Array | Uint8Array;
    targetBuffer?: {
        type: 'Float32Array' | 'Uint8Array';
    };
    metadata?: any;
    dimensions?: Types_2.Point3;
    spacing?: Types_2.Point3;
    origin?: Types_2.Point3;
    direction?: Float32Array;
}): Promise<string>;

// @public (undocumented)
function createSynchronizer(synchronizerId: string, eventName: string, eventHandler: ISynchronizerEventHandler): Synchronizer;

// @public (undocumented)
function createToolGroup(toolGroupId: string): IToolGroup | undefined;

// @public (undocumented)
function createVOISynchronizer(synchronizerName: string): Synchronizer;

// @public (undocumented)
export class CrosshairsTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType, interactionType: string) => CrosshairsAnnotation;
    // (undocumented)
    _applyDeltaShiftToSelectedViewportCameras(renderingEngine: any, viewportsAnnotationsToUpdate: any, delta: any): void;
    // (undocumented)
    _applyDeltaShiftToViewportCamera(renderingEngine: Types_2.IRenderingEngine, annotation: any, delta: any): void;
    // (undocumented)
    _areViewportIdArraysEqual: (viewportUIDArrayOne: any, viewportUIDArrayTwo: any) => boolean;
    // (undocumented)
    _autoPanViewportIfNecessary(viewportId: string, renderingEngine: Types_2.IRenderingEngine): void;
    // (undocumented)
    cancel: () => void;
    // (undocumented)
    _checkIfViewportsRenderingSameScene: (viewport: any, otherViewport: any) => boolean;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
    } | null;
    // (undocumented)
    _filterAnnotationsByUniqueViewportOrientations: (enabledElement: any, annotations: any) => any[];
    // (undocumented)
    filterInteractableAnnotationsForElement: (element: any, annotations: any) => any;
    // (undocumented)
    _filterLinkedViewportWithSameOrientationAndScene: (enabledElement: any, annotations: any) => any;
    // (undocumented)
    _getAnnotationsForViewportsWithDifferentCameras: (enabledElement: any, annotations: any) => any;
    // (undocumented)
    getHandleNearImagePoint(element: HTMLElement, annotation: Annotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    _getReferenceLineColor?: (viewportId: string) => string;
    // (undocumented)
    _getReferenceLineControllable?: (viewportId: string) => boolean;
    // (undocumented)
    _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;
    // (undocumented)
    _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;
    // (undocumented)
    _getRotationHandleNearImagePoint(viewport: any, annotation: any, canvasCoords: any, proximity: any): any;
    // (undocumented)
    _getSlabThicknessHandleNearImagePoint(viewport: any, annotation: any, canvasCoords: any, proximity: any): any;
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: Annotation, handle: ToolHandle, interactionType?: string) => void;
    // (undocumented)
    init: (viewports: ViewportInputs) => void;
    // (undocumented)
    initializeViewport: ({ renderingEngineId, viewportId, }: Types_2.IViewportId) => {
        normal: Types_2.Point3;
        point: Types_2.Point3;
    };
    // (undocumented)
    _isClockWise(a: any, b: any, c: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLElement, annotation: CrosshairsAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    _jump: (enabledElement: any, jumpWorld: any) => boolean;
    // (undocumented)
    _mouseDragCallback: (evt: MouseDragEventType) => void;
    // (undocumented)
    mouseMoveCallback: (evt: EventTypes_2.MouseMoveEventType, filteredToolAnnotations: Annotations) => boolean;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    onCameraModified: (evt: any) => void;
    // (undocumented)
    _pointNearReferenceLine: (annotation: any, canvasCoords: any, proximity: any, lineViewport: any) => boolean;
    // (undocumented)
    _pointNearTool(element: any, annotation: any, canvasCoords: any, proximity: any): boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: any) => void;
    // (undocumented)
    toolCenter: Types_2.Point3;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: Annotation, interactionType: InteractionTypes) => void;
}

// @public (undocumented)
const CursorNames: string[];

declare namespace cursors {
    export {
        MouseCursor,
        ImageMouseCursor,
        SVGMouseCursor,
        elementCursor,
        registerCursor,
        CursorNames,
        setCursorForElement
    }
}
export { cursors }

// @public (undocumented)
interface CustomEvent_2<T = any> extends Event {
    readonly detail: T
    // (undocumented)
    initCustomEvent(
    typeArg: string,
    canBubbleArg: boolean,
    cancelableArg: boolean,
    detailArg: T
    ): void
}

// @public (undocumented)
function debounce(func: Function, wait?: number, options?: {
    leading?: boolean;
    maxWait?: number;
    trailing?: boolean;
}): Function;

// @public (undocumented)
function deepmerge(target?: {}, source?: {}, optionsArgument?: any): any;

// @public (undocumented)
const _default: {
    createToolGroup: typeof createToolGroup;
    destroy: typeof destroy_3;
    destroyToolGroupByToolGroupId: typeof destroyToolGroupByToolGroupId;
    getToolGroupByToolGroupId: typeof getToolGroupByToolGroupId;
    getToolGroup: typeof getToolGroup;
    getAllToolGroups: typeof getAllToolGroups;
};

// @public (undocumented)
const _default_10: {
    findClosestPoint: typeof findClosestPoint;
    liangBarksyClip: typeof clip;
};

// @public (undocumented)
const _default_11: {
    pointInEllipse: typeof pointInEllipse;
    getCanvasEllipseCorners: typeof getCanvasEllipseCorners;
};

// @public (undocumented)
const _default_12: {
    filterAnnotationsWithinSlice: typeof filterAnnotationsWithinSlice;
    getWorldWidthAndHeightFromCorners: typeof getWorldWidthAndHeightFromCorners;
    filterAnnotationsForDisplay: typeof filterAnnotationsForDisplay;
    getPointInLineOfSightWithCriteria: typeof getPointInLineOfSightWithCriteria;
};

// @public (undocumented)
const _default_13: {
    filterViewportsWithToolEnabled: typeof filterViewportsWithToolEnabled;
    filterViewportsWithFrameOfReferenceUID: typeof filterViewportsWithFrameOfReferenceUID;
    getViewportIdsWithToolToRender: typeof getViewportIdsWithToolToRender;
};

// @public (undocumented)
const _default_14: {
    snapFocalPointToSlice: typeof snapFocalPointToSlice;
    getSliceRange: typeof getSliceRange;
    scrollThroughStack: typeof scrollThroughStack;
};

// @public (undocumented)
const _default_15: {
    getTextBoxCoordsCanvas: typeof getTextBoxCoordsCanvas;
};

// @public (undocumented)
const _default_16: {
    getBoundingBoxAroundShape: typeof getBoundingBoxAroundShape;
    extend2DBoundingBoxInViewAxis: typeof extend2DBoundingBoxInViewAxis;
    thresholdVolumeByRange: typeof thresholdVolumeByRange;
    thresholdVolumeByRoiStats: typeof thresholdVolumeByRoiStats;
    createMergedLabelmapForIndex: typeof createMergedLabelmapForIndex;
    isValidRepresentationConfig: typeof isValidRepresentationConfig;
    getDefaultRepresentationConfig: typeof getDefaultRepresentationConfig;
};

// @public (undocumented)
const _default_17: {
    math: typeof math;
    planar: typeof planar;
    viewportFilters: typeof viewportFilters;
    stackScrollTool: typeof stackScrollTool;
    drawing: typeof drawing_2;
    debounce: typeof debounce;
    deepMerge: (target?: {}, source?: {}, optionsArgument?: any) => any;
    throttle: typeof throttle;
    isObject: typeof isObject;
    triggerEvent: typeof triggerEvent;
    calibrateImageSpacing: typeof calibrateImageSpacing;
    transformPhysicalToIndex: typeof transformPhysicalToIndex;
    segmentation: typeof segmentation_2;
    triggerAnnotationRenderForViewportIds: typeof triggerAnnotationRenderForViewportIds;
    pointInShapeCallback: typeof pointInShapeCallback;
    pointInSurroundingSphereCallback: typeof pointInSurroundingSphereCallback;
    getAnnotationNearPoint: typeof getAnnotationNearPoint;
    getAnnotationNearPointOnEnabledElement: typeof getAnnotationNearPointOnEnabledElement;
};

// @public (undocumented)
const _default_2: {
    draw: typeof draw;
    drawCircle: typeof drawCircle;
    drawEllipse: typeof drawEllipse;
    drawHandles: typeof drawHandles;
    drawLine: typeof drawLine;
    drawLinkedTextBox: typeof drawLinkedTextBox;
    drawRect: typeof drawRect;
    drawTextBox: typeof drawTextBox;
};

// @public (undocumented)
const _default_3: {
    getActiveSegmentationInfo: typeof getActiveSegmentationInfo;
    setActiveSegmentation: typeof setActiveSegmentation;
};

// @public (undocumented)
const _default_4: {
    getSegmentIndexLocked: typeof getSegmentIndexLocked;
    setSegmentIndexLocked: typeof setSegmentIndexLocked;
    getSegmentIndexLockedForSegmentation: typeof getSegmentIndexLockedForSegmentation;
    setSegmentIndexLockedForSegmentation: typeof setSegmentIndexLockedForSegmentation;
    getSegmentsLockedForSegmentation: typeof getSegmentsLockedForSegmentation;
};

// @public (undocumented)
const _default_5: {
    getColorForSegmentIndex: typeof getColorForSegmentIndex;
    addColorLUT: typeof addColorLUT_2;
};

// @public (undocumented)
const _default_6: {
    getGlobalSegmentationConfig: typeof getGlobalSegmentationConfig_2;
    setGlobalSegmentationConfig: typeof setGlobalSegmentationConfig_2;
    getGlobalRepresentationConfig: typeof getGlobalRepresentationConfig;
    setGlobalRepresentationConfig: typeof setGlobalRepresentationConfig;
    updateGlobalSegmentationConfig: typeof updateGlobalSegmentationConfig;
    updateGlobalRepresentationConfig: typeof updateGlobalRepresentationConfig;
    getSegmentationConfig: typeof getSegmentationConfig_2;
    setSegmentationConfig: typeof setSegmentationConfig_2;
    setRepresentationConfig: typeof setRepresentationConfig;
    getRepresentationConfig: typeof getRepresentationConfig;
};

// @public (undocumented)
const _default_7: {
    setSegmentationVisibility: typeof setSegmentationVisibility;
    getSegmentationVisibility: typeof getSegmentationVisibility;
};

// @public (undocumented)
const _default_8: {
    getActiveSegmentIndex: typeof getActiveSegmentIndex;
    setActiveSegmentIndex: typeof setActiveSegmentIndex;
    getActiveSegmentIndexForSegmentation: typeof getActiveSegmentIndexForSegmentation;
    setActiveSegmentIndexForSegmentation: typeof setActiveSegmentIndexForSegmentation;
};

// @public (undocumented)
const _default_9: {
    vec2: {
        findClosestPoint: findClosestPoint;
        liangBarksyClip: clip;
    };
    ellipse: {
        pointInEllipse: pointInEllipse;
        getCanvasEllipseCorners: getCanvasEllipseCorners;
    };
    lineSegment: {
        distanceToPoint: distanceToPoint;
        distanceToPointSquared: distanceToPointSquared;
        intersectLine: intersectLine;
    };
    rectangle: {
        distanceToPoint: distanceToPoint_2;
    };
};

// @public (undocumented)
export function destroy(): void;

// @public (undocumented)
function destroy_2(): void;

// @public (undocumented)
function destroy_3(): void;

// @public (undocumented)
function destroySynchronizerById(synchronizerId: string): void;

// @public (undocumented)
function destroyToolGroupByToolGroupId(toolGroupId: string): void;

// @public (undocumented)
function draw(element: HTMLElement, fn: (svgDrawingElement: any) => any): void;

// @public (undocumented)
function drawCircle(svgDrawingHelper: any, toolName: string, annotationUID: string, circleUID: string, center: Types_2.Point2, radius: number, options?: {}): void;

// @public (undocumented)
function drawEllipse(svgDrawingHelper: any, toolName: string, annotationUID: string, ellipseUID: string, corner1: Types_2.Point2, corner2: Types_2.Point2, options?: {}): void;

// @public (undocumented)
function drawHandles(svgDrawingHelper: any, toolName: string, annotationUID: string, handleGroupUID: string, handlePoints: Array<Types_2.Point2>, options?: {}): void;

declare namespace drawing {
    export {
        draw,
        drawCircle,
        drawEllipse,
        drawHandles,
        drawLine,
        drawLinkedTextBox,
        drawRect,
        drawTextBox,
        _default_2 as default
    }
}
export { drawing }

declare namespace drawing_2 {
    export {
        getTextBoxCoordsCanvas,
        _default_15 as default
    }
}

// @public (undocumented)
function drawLine(svgDrawingHelper: any, toolName: string, annotationUID: string, lineUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}): void;

// @public (undocumented)
function drawLinkedTextBox(svgDrawingHelper: Record<string, unknown>, toolName: string, annotationUID: string, textBoxUID: string, textLines: Array<string>, textBoxPosition: Types_2.Point2, annotationAnchorPoints: Array<Types_2.Point2>, textBox: unknown, options?: {}): SVGRect;

// @public (undocumented)
function drawRect(svgDrawingHelper: any, toolName: string, annotationUID: string, rectangleUID: string, start: Types_2.Point2, end: Types_2.Point2, options?: {}): void;

// @public (undocumented)
function drawTextBox(svgDrawingHelper: Record<string, unknown>, toolName: string, annotationUID: string, textUID: string, textLines: Array<string>, position: Types_2.Point2, options?: {}): SVGRect;

declare namespace elementCursor {
    export {
        initElementCursor,
        resetElementCursor,
        hideElementCursor,
        _setElementCursor as setElementCursor
    }
}

// @public
type ElementDisabledEvent = CustomEvent_2<ElementDisabledEventDetail>

// @public
type ElementDisabledEventDetail = {
    element: HTMLElement
    viewportId: string
    renderingEngineId: string
}

// @public
type ElementEnabledEvent = CustomEvent_2<ElementEnabledEventDetail>

// @public
type ElementEnabledEventDetail = {
    element: HTMLElement
    viewportId: string
    renderingEngineId: string
}

// @public (undocumented)
export class EllipticalRoiTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => EllipticalRoiAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewport: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    _dragHandle: (evt: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        movingTextBox?: boolean;
        centerCanvas?: Array<number>;
        canvasWidth?: number;
        canvasHeight?: number;
        originalHandleCanvas?: Array<number>;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getTextLines: (data: any, targetId: any) => any[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: EllipticalRoiAnnotation, handle: ToolHandle, interactionType?: string) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLElement, annotation: EllipticalRoiAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragDrawCallback: (evt: MouseMoveEventType | MouseDragEventType) => void;
    // (undocumented)
    _mouseDragModifyCallback: (evt: MouseDragEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    _pointInEllipseCanvas(ellipse: any, location: Types_2.Point2): boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: any) => void;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: EllipticalRoiAnnotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
export const Enums: {
    MouseBindings: typeof MouseBindings;
    KeyboardBindings: typeof KeyboardBindings;
    ToolModes: typeof ToolModes;
    Events: typeof Events;
    SegmentationRepresentations: typeof SegmentationRepresentations;
};

declare namespace EventTypes {
    export {
        CameraModifiedEventDetail,
        CameraModifiedEvent,
        VoiModifiedEvent,
        VoiModifiedEventDetail,
        ElementDisabledEvent,
        ElementDisabledEventDetail,
        ElementEnabledEvent,
        ElementEnabledEventDetail,
        ImageRenderedEventDetail,
        ImageRenderedEvent,
        ImageVolumeModifiedEvent,
        ImageVolumeModifiedEventDetail,
        ImageLoadedEvent,
        ImageLoadedEventDetail,
        ImageLoadedFailedEventDetail,
        ImageLoadedFailedEvent,
        VolumeLoadedEvent,
        VolumeLoadedEventDetail,
        VolumeLoadedFailedEvent,
        VolumeLoadedFailedEventDetail,
        ImageCacheImageAddedEvent,
        ImageCacheImageAddedEventDetail,
        ImageCacheImageRemovedEvent,
        ImageCacheImageRemovedEventDetail,
        VolumeCacheVolumeAddedEvent,
        VolumeCacheVolumeAddedEventDetail,
        VolumeCacheVolumeRemovedEvent,
        VolumeCacheVolumeRemovedEventDetail,
        StackNewImageEvent,
        StackNewImageEventDetail,
        ImageSpacingCalibratedEvent,
        ImageSpacingCalibratedEventDetail,
        ImageLoadProgressEvent,
        ImageLoadProgressEventDetail
    }
}

declare namespace EventTypes_2 {
    export {
        NormalizedMouseEventDetail,
        NormalizedMouseEventType,
        AnnotationAddedEventDetail,
        AnnotationAddedEventType,
        AnnotationModifiedEventDetail,
        AnnotationModifiedEventType,
        AnnotationRemovedEventDetail,
        AnnotationRemovedEventType,
        AnnotationSelectionChangeEventDetail,
        AnnotationSelectionChangeEventType,
        AnnotationRenderedEventDetail,
        AnnotationRenderedEventType,
        AnnotationLockChangeEventDetail,
        AnnotationLockChangeEventType,
        SegmentationDataModifiedEventType,
        SegmentationStateModifiedEventDetail,
        SegmentationStateModifiedEventType,
        SegmentationDataModifiedEventDetail,
        SegmentationRenderedEventType,
        SegmentationRenderedEventDetail,
        SegmentationGlobalStateModifiedEventType,
        SegmentationGlobalStateModifiedEventDetail,
        KeyDownEventDetail,
        KeyDownEventType,
        KeyUpEventDetail,
        KeyUpEventType,
        MouseDownEventDetail,
        MouseDownEventType,
        MouseDownActivateEventDetail,
        MouseDownActivateEventType,
        MouseDragEventDetail,
        MouseDragEventType,
        MouseUpEventDetail,
        MouseUpEventType,
        MouseClickEventDetail,
        MouseClickEventType,
        MouseMoveEventDetail,
        MouseMoveEventType,
        MouseDoubleClickEventDetail,
        MouseDoubleClickEventType,
        MouseWheelEventDetail,
        MouseWheelEventType
    }
}

// @public (undocumented)
function extend2DBoundingBoxInViewAxis(boundsIJK: [Types_2.Point2, Types_2.Point2, Types_2.Point2], numSlicesToProject: number): [Types_2.Point2, Types_2.Point2, Types_2.Point2];

// @public (undocumented)
function filterAnnotationsForDisplay(viewport: Types_2.IViewport, annotations: Annotations): Annotations;

// @public (undocumented)
function filterAnnotationsWithinSlice(annotations: Annotations, camera: Types_2.ICamera, spacingInNormalDirection: number): Annotations;

// @public (undocumented)
function filterViewportsWithFrameOfReferenceUID(viewports: Array<Types_2.IStackViewport | Types_2.IVolumeViewport>, FrameOfReferenceUID: string): Array<Types_2.IStackViewport | Types_2.IVolumeViewport>;

// @public (undocumented)
function filterViewportsWithToolEnabled(viewports: Array<Types_2.IStackViewport | Types_2.IVolumeViewport>, toolName: string): Array<Types_2.IStackViewport | Types_2.IVolumeViewport>;

// @public
type FlipDirection = {
    flipHorizontal?: boolean
    flipVertical?: boolean
}

// @public (undocumented)
type FrameOfReferenceSpecificAnnotations = {
    [key: string]: Annotations;
};

// @public (undocumented)
function getActiveSegmentationData(toolGroupId: string): ToolGroupSpecificSegmentationData | undefined;

// @public (undocumented)
function getActiveSegmentationInfo(toolGroupId: string): {
    volumeId: string;
    segmentationDataUID: string;
    activeSegmentIndex: number;
};

// @public (undocumented)
function getActiveSegmentIndex(toolGroupId: string): number | undefined;

// @public (undocumented)
function getActiveSegmentIndexForSegmentation(segmentationUID: string): number | undefined;

// @public (undocumented)
function getAllSynchronizers(): Array<Synchronizer>;

// @public (undocumented)
function getAllToolGroups(): Array<IToolGroup>;

// @public (undocumented)
function getAnnotation(annotationUID: string, element?: HTMLElement): Annotation;

// @public (undocumented)
function getAnnotationNearPoint(element: HTMLElement, canvasPoint: Types_2.Point2, proximity?: number): Annotation | null;

// @public (undocumented)
function getAnnotationNearPointOnEnabledElement(enabledElement: Types_2.IEnabledElement, point: Types_2.Point2, proximity: number): Annotation | null;

// @public (undocumented)
function getAnnotations(element: HTMLElement, toolName: string): Annotations;

// @public (undocumented)
function getAnnotationSelected(annotationUID: string): Annotation;

// @public (undocumented)
function getAnnotationsLocked(): Array<Annotation>;

// @public (undocumented)
function getAnnotationsLockedCount(): number;

// @public (undocumented)
function getAnnotationsSelected(): Array<Annotation>;

// @public (undocumented)
function getAnnotationsSelectedByToolName(toolName: string): Array<Annotation>;

// @public (undocumented)
function getAnnotationsSelectedCount(): number;

// @public (undocumented)
function getBoundingBoxAroundShape(vertices: Types_2.Point3[], dimensions?: Types_2.Point3): [Types_2.Point2, Types_2.Point2, Types_2.Point2];

// @public (undocumented)
function getColorForSegmentIndex(toolGroupId: string, segmentationDataUID: string, segmentIndex: number): Color;

// @public (undocumented)
function getColorLut(index: number): ColorLUT | undefined;

// @public (undocumented)
function getDefaultAnnotationManager(): FrameOfReferenceSpecificAnnotationManager;

// @public (undocumented)
function getDefaultRepresentationConfig(representationType: string): LabelmapConfig;

// @public (undocumented)
function getDefaultSegmentationStateManager(): SegmentationStateManager;

// @public (undocumented)
function getFont(settings?: Settings, state?: AnnotationStyleStates, mode?: ToolModes): string;

// @public (undocumented)
function getGlobalRepresentationConfig(representationType: SegmentationRepresentations): RepresentationConfig;

// @public (undocumented)
function getGlobalSegmentationConfig(): SegmentationConfig;

// @public (undocumented)
function getGlobalSegmentationConfig_2(): SegmentationConfig;

// @public (undocumented)
function getGlobalSegmentationDataByUID(segmentationUID: string): GlobalSegmentationData;

// @public (undocumented)
function getGlobalSegmentationState(): GlobalSegmentationState | [];

// @public (undocumented)
function getPointInLineOfSightWithCriteria(viewport: Types_2.IVolumeViewport, worldPos: Types_2.Point3, targetVolumeId: string, criteriaFunction: (intensity: number, point: Types_2.Point3) => Types_2.Point3, stepSize?: number): Types_2.Point3;

// @public (undocumented)
function getRepresentationConfig(toolGroupId: string, representationType: SegmentationRepresentations): RepresentationConfig;

// @public (undocumented)
function getSegmentationConfig(toolGroupId: string): SegmentationConfig;

// @public (undocumented)
function getSegmentationConfig_2(toolGroupId: string): SegmentationConfig;

// @public (undocumented)
function getSegmentationDataByUID(toolGroupId: string, segmentationDataUID: string): ToolGroupSpecificSegmentationData | undefined;

// @public (undocumented)
function getSegmentationState(toolGroupId: string): ToolGroupSpecificSegmentationState | [];

// @public (undocumented)
function getSegmentationVisibility(toolGroupId: string, segmentationDataUID: string): boolean | undefined;

// @public (undocumented)
function getSegmentIndexLocked(toolGroupId: string, segmentIndex: number): boolean;

// @public (undocumented)
function getSegmentIndexLockedForSegmentation(segmentationUID: string, segmentIndex: number): boolean;

// @public (undocumented)
function getSegmentsLockedForSegmentation(segmentationUID: string): number[] | [];

// @public (undocumented)
function getSliceRange(volumeActor: Types_2.VolumeActor, viewPlaneNormal: Types_2.Point3, focalPoint: Types_2.Point3): {
    min: number;
    max: number;
    current: number;
};

// @public (undocumented)
function getState(annotation?: Annotation): AnnotationStyleStates;

// @public (undocumented)
function getStyle(toolName?: string, annotation?: Record<string, unknown>): Settings;

// @public (undocumented)
function getSynchronizerById(synchronizerId: string): Synchronizer | void;

// @public (undocumented)
function getSynchronizers(renderingEngineId: string, viewportId: string): Array<Synchronizer>;

// @public (undocumented)
function getTextBoxCoordsCanvas(annotationCanvasPoints: Array<Types_2.Point2>): Types_2.Point2;

// @public (undocumented)
function getToolGroup(viewportId: string, renderingEngineId: string): IToolGroup | undefined;

// @public (undocumented)
function getToolGroupByToolGroupId(toolGroupId: string): IToolGroup | undefined;

// @public (undocumented)
function getToolGroups(): string[];

// @public (undocumented)
function getToolGroupsWithSegmentation(segmentationUID: string): string[];

// @public (undocumented)
function getViewportIdsWithToolToRender(element: HTMLElement, toolName: string, requireSameOrientation?: boolean): string[];

// @public (undocumented)
function getViewportSpecificAnnotationManager(element?: Types_2.IEnabledElement | HTMLElement): FrameOfReferenceSpecificAnnotationManager;

// @public (undocumented)
function getWorldWidthAndHeightFromCorners(viewPlaneNormal: Types_2.Point3, viewUp: Types_2.Point3, topLeftWorld: Types_2.Point3, bottomRightWorld: Types_2.Point3): {
    worldWidth: number;
    worldHeight: number;
};

// @public (undocumented)
type GlobalSegmentationData = {
    volumeId: string;
    label: string;
    referenceVolumeId?: string;
    referenceImageId?: string;
    activeSegmentIndex: number;
    segmentsLocked: Set<number>;
    cachedStats: {
        [key: string]: number;
    };
};

// @public (undocumented)
type GlobalSegmentationState = GlobalSegmentationData[];

// @public (undocumented)
type GlobalSegmentationStateWithConfig = {
    segmentations: GlobalSegmentationState;
    config: SegmentationConfig;
};

// @public (undocumented)
function hideElementCursor(element: HTMLElement): void;

// @public (undocumented)
interface ICache {
    getCacheSize: () => number
    getImageLoadObject: (imageId: string) => IImageLoadObject | void
    getMaxCacheSize: () => number
    getVolumeLoadObject: (volumeId: string) => IVolumeLoadObject | void
    purgeCache: () => void
    putImageLoadObject: (
    imageId: string,
    imageLoadObject: IImageLoadObject
    ) => Promise<any>
    putVolumeLoadObject: (
    volumeId: string,
    volumeLoadObject: IVolumeLoadObject
    ) => Promise<any>
    setMaxCacheSize: (maxCacheSize: number) => void
}

// @public (undocumented)
interface ICachedImage {
    // (undocumented)
    image?: IImage
    // (undocumented)
    imageId: string
    // (undocumented)
    imageLoadObject: IImageLoadObject
    // (undocumented)
    loaded: boolean
    // (undocumented)
    sharedCacheKey?: string
    // (undocumented)
    sizeInBytes: number
    // (undocumented)
    timeStamp: number
}

// @public (undocumented)
interface ICachedVolume {
    // (undocumented)
    loaded: boolean
    // (undocumented)
    sizeInBytes: number
    // (undocumented)
    timeStamp: number
    // (undocumented)
    volume?: IImageVolume
    // (undocumented)
    volumeId: string
    // (undocumented)
    volumeLoadObject: IVolumeLoadObject
}

// @public
interface ICamera {
    clippingRange?: Point2
    focalPoint?: Point3
    parallelProjection?: boolean
    parallelScale?: number
    position?: Point3
    slabThickness?: number
    viewAngle?: number
    viewPlaneNormal?: Point3
    viewUp?: Point3
}

// @public
interface IEnabledElement {
    FrameOfReferenceUID: string
    renderingEngine: IRenderingEngine
    renderingEngineId: string
    viewport: IStackViewport | IVolumeViewport
    viewportId: string
}

// @public
interface IImage {
    cachedLut?: {
        windowWidth?: number | number[]
        windowCenter?: number | number[]
        invert?: boolean
        lutArray?: Uint8ClampedArray
        modalityLUT?: unknown
        voiLUT?: CPUFallbackLUT
    }
    color: boolean
    colormap?: CPUFallbackColormap
    columnPixelSpacing: number
    columns: number
    // (undocumented)
    getCanvas: () => HTMLCanvasElement
    getPixelData: () => Array<number>
    height: number
    imageId: string
    intercept: number
    invert: boolean
    // (undocumented)
    maxPixelValue: number
    minPixelValue: number
    modalityLUT?: CPUFallbackLUT
    numComps: number
    render?: (
    enabledElement: CPUFallbackEnabledElement,
    invalidated: boolean
    ) => unknown
    rgba: boolean
    rowPixelSpacing: number
    rows: number
    scaling?: {
        PET?: {
            // @TODO: Do these values exist?
            SUVlbmFactor?: number
            SUVbsaFactor?: number
            // accessed in ProbeTool
            suvbwToSuvlbm?: number
            suvbwToSuvbsa?: number
        }
    }
    // (undocumented)
    sharedCacheKey?: string
    sizeInBytes: number
    sliceThickness?: number
    slope: number
    stats?: {
        lastStoredPixelDataToCanvasImageDataTime?: number
        lastGetPixelDataTime?: number
        lastPutImageDataTime?: number
        lastLutGenerateTime?: number
        lastRenderedViewport?: unknown
        lastRenderTime?: number
    }
    voiLUT?: CPUFallbackLUT
    width: number
    windowCenter: number[] | number
    windowWidth: number[] | number
}

// @public
interface IImageData {
    dimensions: Point3
    direction: Float32Array
    imageData: vtkImageData
    metadata: { Modality: string }
    origin: Point3
    scalarData: Float32Array
    scaling?: Scaling
    spacing: Point3
}

// @public
interface IImageLoadObject {
    cancel?: () => void
    decache?: () => void
    promise: Promise<IImage>
}

// @public
interface IImageVolume {
    convertToCornerstoneImage?: (
    imageId: string,
    imageIdIndex: number
    ) => IImageLoadObject
    dimensions: Point3
    direction: Float32Array
    imageData?: vtkImageData
    imageIds?: Array<string>
    loadStatus?: Record<string, any>
    metadata: Metadata
    numVoxels: number
    origin: Point3
    referenceVolumeId?: string
    scalarData: any
    scaling?: {
        PET?: {
            SUVlbmFactor?: number
            SUVbsaFactor?: number
            suvbwToSuvlbm?: number
            suvbwToSuvbsa?: number
        }
    }
    sizeInBytes?: number
    spacing: Point3
    readonly volumeId: string
    vtkOpenGLTexture: any
}

// @public
type ImageCacheImageAddedEvent =
CustomEvent_2<ImageCacheImageAddedEventDetail>

// @public
type ImageCacheImageAddedEventDetail = {
    image: ICachedImage
}

// @public
type ImageCacheImageRemovedEvent =
CustomEvent_2<ImageCacheImageRemovedEventDetail>

// @public
type ImageCacheImageRemovedEventDetail = {
    imageId: string
}

// @public
type ImageLoadedEvent = CustomEvent_2<ImageLoadedEventDetail>

// @public
type ImageLoadedEventDetail = {
    image: IImage
}

// @public
type ImageLoadedFailedEvent = CustomEvent_2<ImageLoadedFailedEventDetail>

// @public
type ImageLoadedFailedEventDetail = {
    imageId: string
    error: unknown
}

// @public
type ImageLoaderFn = (
imageId: string,
options?: Record<string, any>
) => {
    promise: Promise<Record<string, any>>
    cancelFn?: () => void | undefined
    decache?: () => void | undefined
}

// @public
type ImageLoadProgressEvent = CustomEvent_2<ImageLoadProgressEventDetail>

// @public
type ImageLoadProgressEventDetail = {
    url: string
    imageId: string
    loaded: number
    total: number
    percent: number
}

// @public (undocumented)
class ImageMouseCursor extends MouseCursor {
    constructor(url: string, x?: number, y?: number, name?: string | undefined, fallback?: MouseCursor | undefined);
    // (undocumented)
    getStyleProperty(): string;
    // (undocumented)
    static getUniqueInstanceName(prefix: string): string;
}

// @public
type ImageRenderedEvent = CustomEvent_2<ElementEnabledEventDetail>

// @public
type ImageRenderedEventDetail = {
    element: HTMLElement
    viewportId: string
    renderingEngineId: string
    suppressEvents?: boolean
}

// @public
type ImageSpacingCalibratedEvent =
CustomEvent_2<ImageSpacingCalibratedEventDetail>

// @public
type ImageSpacingCalibratedEventDetail = {
    element: HTMLElement
    viewportId: string
    renderingEngineId: string
    imageId: string
    rowScale: number
    columnScale: number
    imageData: vtkImageData
    worldToIndex: mat4
}

// @public
type ImageVolumeModifiedEvent = CustomEvent_2<ImageVolumeModifiedEventDetail>

// @public
type ImageVolumeModifiedEventDetail = {
    imageVolume: IImageVolume
    FrameOfReferenceUID: string
}

// @public (undocumented)
export function init(defaultConfiguration?: {}): void;

// @public (undocumented)
function initElementCursor(element: HTMLElement, cursor: MouseCursor | null): void;

// @public (undocumented)
type InteractionTypes = 'Mouse';

// @public (undocumented)
type IPoints = {
    page: Types_2.Point2;
    client: Types_2.Point2;
    canvas: Types_2.Point2;
    world: Types_2.Point3;
};

// @public
interface IRegisterImageLoader {
    // (undocumented)
    registerImageLoader: (scheme: string, imageLoader: ImageLoaderFn) => void
}

// @public (undocumented)
interface IRenderingEngine {
    // (undocumented)
    _debugRender(): void
    // (undocumented)
    destroy(): void
    // (undocumented)
    disableElement(viewportId: string): void
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void
    // (undocumented)
    fillCanvasWithBackgroundColor(
    canvas: HTMLCanvasElement,
    backgroundColor: [number, number, number]
    ): void
    // (undocumented)
    getStackViewports(): Array<IStackViewport>
    // (undocumented)
    getViewport(id: string): IStackViewport | IVolumeViewport
    // (undocumented)
    getViewports(): Array<IStackViewport | IVolumeViewport>
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>
    // (undocumented)
    hasBeenDestroyed: boolean
    // (undocumented)
    id: string
    // (undocumented)
    offScreenCanvasContainer: any
    // (undocumented)
    offscreenMultiRenderWindow: any
    // (undocumented)
    render(): void
    // (undocumented)
    renderFrameOfReference(FrameOfReferenceUID: string): void
    // (undocumented)
    renderViewport(viewportId: string): void
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void
    // (undocumented)
    resize(): void
    // (undocumented)
    setViewports(viewports: Array<PublicViewportInput>): void
}

// @public (undocumented)
function isAnnotationLocked(annotation: Annotation): boolean;

// @public (undocumented)
function isAnnotationSelected(annotation: Annotation): boolean;

// @public (undocumented)
function isObject(value: any): boolean;

// @public
interface IStackViewport extends IViewport {
    calibrateSpacing(imageId: string): void
    canvasToWorld: (canvasPos: Point2) => Point3
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement
        element: HTMLElement
        viewportId: string
        renderingEngineId: string
    }
    getCamera(): ICamera
    getCurrentImageId: () => string
    getCurrentImageIdIndex: () => number
    getFrameOfReferenceUID: () => string
    getImageData(): IImageData | CPUIImageData
    getImageIds: () => string[]
    getProperties: () => StackViewportProperties
    getRenderer(): any
    // (undocumented)
    modality: string
    resetCamera(resetPanZoomForViewPlane?: boolean): boolean
    resetProperties(): void
    resize: () => void
    scaling: Scaling
    setCamera(cameraInterface: ICamera): void
    setColormap(colormap: CPUFallbackColormapData): void
    setImageIdIndex(imageIdIndex: number): Promise<string>
    setProperties({
        voiRange,
        invert,
        interpolationType,
        rotation,
        flipHorizontal,
        flipVertical,
    }: StackViewportProperties): void
    setStack(
    imageIds: Array<string>,
    currentImageIdIndex?: number
    ): Promise<string>
    unsetColormap(): void
    worldToCanvas: (worldPos: Point3) => Point2
}

// @public
interface IStreamingImageVolume extends ImageVolume {
    clearLoadCallbacks(): void
    convertToCornerstoneImage(imageId: string, imageIdIndex: number): any
    decache(completelyRemove: boolean): void
}

// @public (undocumented)
interface IStreamingVolumeProperties {
    imageIds: Array<string>
    loadStatus: {
        loaded: boolean
        loading: boolean
        cachedFrames: Array<boolean>
        callbacks: Array<() => void>
    }
}

// @public (undocumented)
function isValidRepresentationConfig(representationType: string, config: RepresentationConfig): boolean;

// @public (undocumented)
type IToolBinding = {
    mouseButton: ToolBindingMouseType;
    modifierKey?: ToolBindingKeyboardType;
};

// @public (undocumented)
interface IToolGroup {
    // (undocumented)
    addTool: {
        (toolName: string, toolConfiguration?: any): void;
    };
    // (undocumented)
    addViewport: {
        (viewportId: string, renderingEngineId?: string): void;
    };
    // (undocumented)
    getActivePrimaryMouseButtonTool: {
        (): undefined | string;
    };
    // (undocumented)
    getToolInstance: {
        (toolName: string): any;
    };
    // (undocumented)
    getToolOptions: {
        (toolName: string): ToolOptionsType;
    };
    // (undocumented)
    getViewportIds: () => string[];
    // (undocumented)
    id: string;
    // (undocumented)
    removeViewports: {
        (renderingEngineId: string, viewportId?: string): void;
    };
    // (undocumented)
    setToolActive: {
        (toolName: string, toolBindingsOption?: SetToolBindingsType): void;
    };
    // (undocumented)
    setToolDisabled: {
        (toolName: string): void;
    };
    // (undocumented)
    setToolEnabled: {
        (toolName: string): void;
    };
    // (undocumented)
    setToolPassive: {
        (toolName: string): void;
    };
    // (undocumented)
    setViewportsCursorByToolName: {
        (toolName: string, strategyName?: string): void;
    };
    // (undocumented)
    _toolInstances: Record<string, any>;
    // (undocumented)
    toolOptions: Record<string, any>;
    // (undocumented)
    viewportsInfo: Array<Types_2.IViewportId>;
}

// @public
interface IViewport {
    _actors: Map<string, any>
    addActor(actorEntry: ActorEntry): void
    addActors(actors: Array<ActorEntry>): void
    canvas: HTMLCanvasElement
    canvasToWorld: (canvasPos: Point2) => Point3
    customRenderViewportToCanvas: () => unknown
    defaultOptions: any
    element: HTMLElement
    getActor(actorUID: string): ActorEntry
    getActors(): Array<ActorEntry>
    getCamera(): ICamera
    getCanvas(): HTMLCanvasElement
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[]
    getFrameOfReferenceUID: () => string
    getRenderer(): void
    getRenderingEngine(): any
    id: string
    options: ViewportInputOptions
    removeAllActors(): void
    render(): void
    renderingEngineId: string
    reset(immediate: boolean): void
    setActors(actors: Array<ActorEntry>): void
    setCamera(cameraInterface: ICamera): void
    setOptions(options: ViewportInputOptions, immediate: boolean): void
    sHeight: number
    suppressEvents: boolean
    sWidth: number
    sx: number
    sy: number
    type: ViewportType
    worldToCanvas: (worldPos: Point3) => Point2
}

// @public
interface IViewportId {
    // (undocumented)
    renderingEngineId: string
    // (undocumented)
    viewportId: string
}

// @public
interface IVolume {
    dimensions: Point3
    direction: Float32Array
    imageData?: vtkImageData
    metadata: Metadata
    origin: Point3
    referenceVolumeId?: string
    scalarData: Float32Array | Uint8Array
    scaling?: {
        PET?: {
            // @TODO: Do these values exist?
            SUVlbmFactor?: number
            SUVbsaFactor?: number
            // accessed in ProbeTool
            suvbwToSuvlbm?: number
            suvbwToSuvbsa?: number
        }
    }
    sizeInBytes?: number
    spacing: Point3
    volumeId: string
}

// @public
interface IVolumeInput {
    // (undocumented)
    actorUID?: string
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    blendMode?: string
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    callback?: VolumeInputCallback
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    slabThickness?: number
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    visibility?: boolean
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    volumeId: string
}

// @public
interface IVolumeLoadObject {
    cancel?: () => void
    decache?: () => void
    promise: Promise<ImageVolume>
}

// @public
interface IVolumeViewport extends IViewport {
    addVolumes(
    volumeInputArray: Array<IVolumeInput>,
    immediate?: boolean
    ): Promise<void>
    canvasToWorld: (canvasPos: Point2) => Point3
    flip(flipDirection: FlipDirection): void
    getBounds(): any
    getCurrentImageId: () => string
    getCurrentImageIdIndex: () => number
    // (undocumented)
    getFrameOfReferenceUID: () => string
    getImageData(): IImageData | undefined
    getIntensityFromWorld(point: Point3): number
    // (undocumented)
    getProperties: () => any
    getSlabThickness(): number
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void
    resetCamera(resetPanZoomForViewPlane?: boolean): boolean
    setSlabThickness(slabThickness: number): void
    setVolumes(
    volumeInputArray: Array<IVolumeInput>,
    immediate?: boolean
    ): Promise<void>
    // (undocumented)
    useCPURendering: boolean
    worldToCanvas: (worldPos: Point3) => Point2
}

// @public (undocumented)
type KeyDownEventDetail = {
    element: HTMLElement;
    viewportId: string;
    renderingEngineId: string;
    key: string;
    keyCode: number;
};

// @public (undocumented)
type KeyDownEventType = Types_2.CustomEventType<KeyDownEventDetail>;

// @public (undocumented)
type KeyUpEventDetail = KeyDownEventDetail;

// @public (undocumented)
type KeyUpEventType = Types_2.CustomEventType<KeyUpEventDetail>;

// @public (undocumented)
type LabelmapRepresentation = {
    type: typeof SegmentationRepresentations.Labelmap;
    config: {
        cfun?: vtkColorTransferFunction;
        ofun?: vtkPiecewiseFunction;
    };
};

// @public (undocumented)
export class LengthTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: HTMLElement) => void;
    // (undocumented)
    _activateModify: (element: HTMLElement) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => LengthAnnotation;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    _calculateLength(pos1: any, pos2: any): number;
    // (undocumented)
    cancel: (element: HTMLElement) => any;
    // (undocumented)
    _deactivateDraw: (element: HTMLElement) => void;
    // (undocumented)
    _deactivateModify: (element: HTMLElement) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getTextLines(data: any, targetId: any): string[];
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: LengthAnnotation, handle: ToolHandle, interactionType?: string): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume(index1: any, index2: any, dimensions: any): boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLElement, annotation: LengthAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType | EventTypes_2.MouseMoveEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: any) => void;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: LengthAnnotation, interactionType: InteractionTypes) => void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
const lineSegment: {
    distanceToPoint: typeof distanceToPoint;
    distanceToPointSquared: typeof distanceToPointSquared;
    intersectLine: typeof intersectLine;
};

declare namespace locking {
    export {
        setAnnotationLocked,
        getAnnotationsLocked,
        getAnnotationsLockedCount,
        unlockAllAnnotations,
        isAnnotationLocked,
        checkAndDefineIsLockedProperty
    }
}

declare namespace math {
    export {
        _default_9 as default,
        _default_10 as vec2,
        _default_11 as ellipse,
        lineSegment,
        rectangle
    }
}

// @public
type Metadata = {
    BitsAllocated: number
    BitsStored: number
    SamplesPerPixel: number
    HighBit: number
    PhotometricInterpretation: string
    PixelRepresentation: number
    Modality: string
    ImageOrientationPatient: Array<number>
    PixelSpacing: Array<number>
    FrameOfReferenceUID: string
    Columns: number
    Rows: number
    voiLut: Array<VOI>
}

// @public (undocumented)
export class MIPJumpToClickTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _bounds: any;
    // (undocumented)
    mouseClickCallback(evt: any): void;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
type MouseClickEventDetail = NormalizedMouseEventDetail & {
    mouseButton: number;
    startPoints: IPoints;
    lastPoints: IPoints;
    currentPoints: IPoints;
    deltaPoints: IPoints;
};

// @public (undocumented)
type MouseClickEventType = Types_2.CustomEventType<MouseClickEventDetail>;

// @public (undocumented)
class MouseCursor {
    constructor(name: string, fallback?: MouseCursor | undefined);
    // (undocumented)
    addFallbackStyleProperty(style: string): string;
    // (undocumented)
    static getDefinedCursor(name: string): MouseCursor | undefined;
    // (undocumented)
    getName(): string;
    // (undocumented)
    getStyleProperty(): string;
    // (undocumented)
    static setDefinedCursor(name: string, cursor: MouseCursor): boolean;
}

// @public (undocumented)
type MouseDoubleClickEventDetail = NormalizedMouseEventDetail & {
    startPoints: IPoints;
    lastPoints: IPoints;
    currentPoints: IPoints;
    deltaPoints: IPoints;
};

// @public (undocumented)
type MouseDoubleClickEventType = Types_2.CustomEventType<MouseDoubleClickEventDetail>;

// @public (undocumented)
type MouseDownActivateEventDetail = NormalizedMouseEventDetail & {
    mouseButton: number;
    startPoints: IPoints;
    lastPoints: IPoints;
    currentPoints: IPoints;
    deltaPoints: IPoints;
};

// @public (undocumented)
type MouseDownActivateEventType = Types_2.CustomEventType<MouseDownActivateEventDetail>;

// @public (undocumented)
type MouseDownEventDetail = NormalizedMouseEventDetail & {
    mouseButton: number;
    startPoints: IPoints;
    lastPoints: IPoints;
    currentPoints: IPoints;
    deltaPoints: IPoints;
};

// @public (undocumented)
type MouseDownEventType = Types_2.CustomEventType<MouseDownEventDetail>;

// @public (undocumented)
type MouseDragEventDetail = NormalizedMouseEventDetail & {
    mouseButton: number;
    startPoints: IPoints;
    lastPoints: IPoints;
    currentPoints: IPoints;
    deltaPoints: IPoints;
};

// @public (undocumented)
type MouseDragEventType = Types_2.CustomEventType<MouseDragEventDetail>;

// @public (undocumented)
type MouseMoveEventDetail = NormalizedMouseEventDetail & {
    currentPoints: IPoints;
};

// @public (undocumented)
type MouseMoveEventType = Types_2.CustomEventType<MouseMoveEventDetail>;

// @public (undocumented)
type MouseUpEventDetail = NormalizedMouseEventDetail & {
    mouseButton: number;
    startPoints: IPoints;
    lastPoints: IPoints;
    currentPoints: IPoints;
    deltaPoints: IPoints;
};

// @public (undocumented)
type MouseUpEventType = Types_2.CustomEventType<MouseUpEventDetail>;

// @public (undocumented)
type MouseWheelEventDetail = NormalizedMouseEventDetail & {
    detail: Record<string, any>;
    wheel: {
        spinX: number;
        spinY: number;
        pixelX: number;
        pixelY: number;
        direction: number;
    };
    points: IPoints;
};

// @public (undocumented)
type MouseWheelEventType = Types_2.CustomEventType<MouseWheelEventDetail>;

// @public (undocumented)
type NormalizedMouseEventDetail = {
    event: Record<string, unknown> | MouseEvent;
    eventName: string;
    renderingEngineId: string;
    viewportId: string;
    camera: Record<string, unknown>;
    element: HTMLElement;
};

// @public (undocumented)
type NormalizedMouseEventType = Types_2.CustomEventType<NormalizedMouseEventDetail>;

// @public (undocumented)
type Orientation = {
    sliceNormal: Point3
    viewUp: Point3
}

// @public (undocumented)
export class PanTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: any): void;
    // (undocumented)
    mouseDragCallback: () => void;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    touchDragCallback: () => void;
}

declare namespace planar {
    export {
        _default_12 as default,
        filterAnnotationsWithinSlice,
        getWorldWidthAndHeightFromCorners,
        filterAnnotationsForDisplay,
        getPointInLineOfSightWithCriteria
    }
}

// @public (undocumented)
type PlanarBoundingBox = {
    x: number;
    y: number;
    width: number;
    height: number;
};

// @public
type Plane = [number, number, number, number]

// @public
type Point2 = [number, number]

// @public
type Point3 = [number, number, number]

// @public
type Point4 = [number, number, number, number];

// @public (undocumented)
function pointInShapeCallback(imageData: vtkImageData | Types_2.CPUImageData, pointInShapeFn: ShapeFnCriteria, callback: PointInShapeCallback, boundsIJK?: BoundsIJK): void;

// @public (undocumented)
function pointInSurroundingSphereCallback(viewport: Types_2.IVolumeViewport, imageData: vtkImageData, circlePoints: [Types_2.Point3, Types_2.Point3], callback: PointInShapeCallback): void;

// @public (undocumented)
export class ProbeTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => ProbeAnnotation;
    // (undocumented)
    _calculateCachedStats(annotation: any, renderingEngine: any, enabledElement: any): any;
    // (undocumented)
    cancel: (element: HTMLElement) => any;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
    } | null;
    // (undocumented)
    eventDispatchDetail: {
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getHandleNearImagePoint(element: HTMLElement, annotation: ProbeAnnotation, canvasCoords: Types_2.Point2, proximity: number): ToolHandle | undefined;
    // (undocumented)
    _getTextLines(data: any, targetId: any): any[];
    // (undocumented)
    _getValueForModality(value: any, imageVolume: any, modality: any): {};
    // (undocumented)
    handleSelectedCallback(evt: EventTypes_2.MouseDownEventType, annotation: ProbeAnnotation, handle: ToolHandle, interactionType?: string): void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    isPointNearTool(): boolean;
    // (undocumented)
    mouseDragCallback: any;
    // (undocumented)
    _mouseDragCallback: (evt: any) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: any) => void;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback(): void;
    // (undocumented)
    touchDragCallback: any;
}

// @public (undocumented)
type PTScaling = {
    suvbwToSuvlbm?: number
    suvbwToSuvbsa?: number
}

// @public (undocumented)
type PublicToolProps = SharedToolProp & {
    name?: string;
};

// @public
type PublicViewportInput = {
    element: HTMLElement
    viewportId: string
    type: ViewportType
    defaultOptions: ViewportInputOptions
}

// @public (undocumented)
const rectangle: {
    distanceToPoint: typeof distanceToPoint_2;
};

// @public (undocumented)
export class RectangleRoiStartEndThresholdTool extends RectangleRoiTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => {
        highlighted: boolean;
        invalidated: boolean;
        metadata: {
            viewPlaneNormal: Types_2.Point3;
            enabledElement: Types_2.IEnabledElement;
            viewUp: Types_2.Point3;
            FrameOfReferenceUID: string;
            referencedImageId: any;
            toolName: string;
            volumeId: any;
            spacingInNormal: number;
        };
        data: {
            label: string;
            startSlice: number;
            endSlice: number;
            cachedStats: {
                projectionPoints: any[];
                projectionPointsImageIds: any[];
            };
            handles: {
                textBox: {
                    hasMoved: boolean;
                    worldPosition: any;
                    worldBoundingBox: any;
                };
                points: Types_2.Point3[];
                activeHandleIndex: any;
            };
            labelmapUID: any;
        };
    };
    // (undocumented)
    _calculateCachedStatsTool(annotation: any, enabledElement: any): any;
    // (undocumented)
    _computeProjectionPoints(annotation: RectangleRoiStartEndThresholdAnnotation, imageVolume: Types_2.IImageVolume): void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getEndSliceIndex(imageVolume: Types_2.IImageVolume, worldPos: Types_2.Point3, spacingInNormal: number, viewPlaneNormal: Types_2.Point3): number | undefined;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: any) => void;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
export class RectangleRoiThresholdTool extends RectangleRoiTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => {
        highlighted: boolean;
        invalidated: boolean;
        metadata: {
            viewPlaneNormal: Types_2.Point3;
            enabledElement: Types_2.IEnabledElement;
            viewUp: Types_2.Point3;
            FrameOfReferenceUID: string;
            referencedImageId: any;
            toolName: string;
            volumeId: any;
        };
        data: {
            label: string;
            handles: {
                textBox: {
                    hasMoved: boolean;
                    worldPosition: any;
                    worldBoundingBox: any;
                };
                points: Types_2.Point3[];
                activeHandleIndex: any;
            };
            segmentationUID: any;
        };
    };
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: any) => void;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
export class RectangleRoiTool extends AnnotationTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    _activateModify: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => RectangleRoiAnnotation;
    // (undocumented)
    _calculateCachedStats: (annotation: any, viewPlaneNormal: any, viewUp: any, renderingEngine: any, enabledElement: any) => any;
    // (undocumented)
    cancel: (element: HTMLElement) => any;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    _deactivateModify: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    _getRectangleImageCoordinates: (points: Array<Types_2.Point2>) => {
        left: number;
        top: number;
        width: number;
        height: number;
    };
    // (undocumented)
    _getTextLines: (data: any, targetId: string) => any[];
    // (undocumented)
    handleSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: RectangleRoiAnnotation, handle: ToolHandle, interactionType?: string) => void;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _isInsideVolume: (index1: any, index2: any, dimensions: any) => boolean;
    // (undocumented)
    isPointNearTool: (element: HTMLElement, annotation: RectangleRoiAnnotation, canvasCoords: Types_2.Point2, proximity: number) => boolean;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseMoveEventType | EventTypes_2.MouseDragEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: any) => void;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    toolSelectedCallback: (evt: EventTypes_2.MouseDownEventType, annotation: RectangleRoiAnnotation, interactionType: InteractionTypes) => void;
}

// @public (undocumented)
export class RectangleScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentationDataUID: string;
        segmentation: any;
        segmentIndex: number;
        segmentsLocked: number[];
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
    } | null;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: any) => void;
    // (undocumented)
    _throttledCalculateCachedStats: any;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
function registerCursor(toolName: string, iconContent: string, viewBox: {
    x: number;
    y: number;
}): void;

// @public (undocumented)
function removeAnnotation(element: HTMLElement, annotationUID: string): void;

// @public (undocumented)
function removeSegmentationData(toolGroupId: string, segmentationDataUID: string): void;

// @public (undocumented)
function removeSegmentationsFromToolGroup(toolGroupId: string, segmentationDataUIDs?: string[] | undefined): void;

// @public (undocumented)
export function removeTool(ToolClass: any): void;

// @public (undocumented)
type RepresentationConfig = LabelmapConfig;

// @public (undocumented)
function resetElementCursor(element: HTMLElement): void;

// @public (undocumented)
type Scaling = {
    PET?: PTScaling
}

// @public (undocumented)
type ScalingParameters = {
    rescaleSlope: number
    rescaleIntercept: number
    modality: string
    suvbw?: number
    suvlbm?: number
    suvbsa?: number
}

// @public (undocumented)
function scrollThroughStack(evt: MouseWheelEventType | MouseDragEventType, deltaFrames: number, volumeId: string, invert?: boolean): void;

declare namespace segmentation {
    export {
        state_2 as state,
        activeSegmentation,
        addSegmentationsForToolGroup,
        removeSegmentationsFromToolGroup,
        createNewSegmentationForToolGroup,
        segmentLocking,
        segmentationColor,
        segmentationConfig,
        segmentationVisibility,
        segmentIndex,
        triggerSegmentationEvents
    }
}
export { segmentation }

declare namespace segmentation_2 {
    export {
        getBoundingBoxAroundShape,
        extend2DBoundingBoxInViewAxis,
        thresholdVolumeByRange,
        thresholdVolumeByRoiStats,
        createMergedLabelmapForIndex,
        isValidRepresentationConfig,
        getDefaultRepresentationConfig,
        _default_16 as default
    }
}

declare namespace segmentationColor {
    export {
        _default_5 as default,
        getColorForSegmentIndex,
        addColorLUT_2 as addColorLUT
    }
}

// @public (undocumented)
type SegmentationConfig = {
    renderInactiveSegmentations: boolean;
    representations: {
        LABELMAP?: LabelmapConfig;
    };
};

declare namespace segmentationConfig {
    export {
        getGlobalSegmentationConfig_2 as getGlobalSegmentationConfig,
        setGlobalSegmentationConfig_2 as setGlobalSegmentationConfig,
        getGlobalRepresentationConfig,
        setGlobalRepresentationConfig,
        updateGlobalSegmentationConfig,
        updateGlobalRepresentationConfig,
        getSegmentationConfig_2 as getSegmentationConfig,
        setSegmentationConfig_2 as setSegmentationConfig,
        setRepresentationConfig,
        getRepresentationConfig,
        _default_6 as default
    }
}

// @public (undocumented)
type SegmentationDataModifiedEventDetail = {
    toolGroupId: string;
    segmentationDataUID: string;
};

// @public (undocumented)
type SegmentationDataModifiedEventType = Types_2.CustomEventType<SegmentationDataModifiedEventDetail>;

// @public (undocumented)
export class SegmentationDisplayTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    disableCallback(): void;
    // (undocumented)
    enableCallback(): void;
    // (undocumented)
    _getSegmentationConfig(toolGroupId: string): SegmentationConfig;
    // (undocumented)
    renderSegmentation: (toolGroupId: string) => void;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
type SegmentationGlobalStateModifiedEventDetail = {
    segmentationUID: string;
};

// @public (undocumented)
type SegmentationGlobalStateModifiedEventType = Types_2.CustomEventType<SegmentationGlobalStateModifiedEventDetail>;

// @public (undocumented)
type SegmentationRenderedEventDetail = {
    viewportId: string;
    toolGroupId: string;
};

// @public (undocumented)
type SegmentationRenderedEventType = Types_2.CustomEventType<SegmentationRenderedEventDetail>;

// @public (undocumented)
type SegmentationRepresentation = LabelmapRepresentation;

// @public (undocumented)
type SegmentationStateModifiedEventDetail = {
    toolGroupId: string;
};

// @public (undocumented)
type SegmentationStateModifiedEventType = Types_2.CustomEventType<SegmentationStateModifiedEventDetail>;

declare namespace segmentationVisibility {
    export {
        _default_7 as default,
        setSegmentationVisibility,
        getSegmentationVisibility
    }
}

declare namespace segmentIndex {
    export {
        _default_8 as default,
        getActiveSegmentIndex,
        setActiveSegmentIndex,
        getActiveSegmentIndexForSegmentation,
        setActiveSegmentIndexForSegmentation
    }
}

declare namespace segmentLocking {
    export {
        getSegmentIndexLocked,
        setSegmentIndexLocked,
        getSegmentIndexLockedForSegmentation,
        setSegmentIndexLockedForSegmentation,
        getSegmentsLockedForSegmentation,
        _default_4 as default
    }
}

declare namespace selection {
    export {
        setAnnotationSelected,
        getAnnotationsSelected,
        getAnnotationSelected,
        getAnnotationsSelectedByToolName,
        getAnnotationsSelectedCount,
        isAnnotationSelected
    }
}

// @public (undocumented)
function setActiveSegmentation(toolGroupId: string, segmentationDataUID: string): void;

// @public (undocumented)
function setActiveSegmentationData(toolGroupId: string, segmentationDataUID: string, suppressEvents?: boolean): void;

// @public (undocumented)
function setActiveSegmentIndex(toolGroupId: string, segmentIndex: number): void;

// @public (undocumented)
function setActiveSegmentIndexForSegmentation(segmentationUID: string, segmentIndex: number): void;

// @public (undocumented)
function setAnnotationLocked(annotation: Annotation, locked?: boolean): void;

// @public (undocumented)
function setAnnotationSelected(annotation: Annotation, selected?: boolean, preserveSelected?: boolean): void;

// @public (undocumented)
function setAnnotationStyle(toolName: string, annotation: Record<string, unknown>, style: Record<string, unknown>): boolean;

// @public (undocumented)
function setCursorForElement(element: HTMLElement, cursorName: string): void;

// @public (undocumented)
function _setElementCursor(element: HTMLElement, cursor: MouseCursor | null): void;

// @public (undocumented)
function setGlobalRepresentationConfig(representationType: SegmentationRepresentations, config: RepresentationConfig): void;

// @public (undocumented)
function setGlobalSegmentationConfig(config: SegmentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setGlobalSegmentationConfig_2(segmentationConfig: SegmentationConfig): void;

// @public (undocumented)
function setGlobalStyle(style: Record<string, unknown>): boolean;

// @public (undocumented)
function setRepresentationConfig(toolGroupId: string, representationType: SegmentationRepresentations, representationConfig: RepresentationConfig): void;

// @public (undocumented)
function setSegmentationConfig(toolGroupId: string, config: SegmentationConfig, suppressEvents?: boolean): void;

// @public (undocumented)
function setSegmentationConfig_2(toolGroupId: string, segmentationConfig: SegmentationConfig): void;

// @public (undocumented)
function setSegmentationVisibility(toolGroupId: string, segmentationDataUID: string, visibility: boolean): void;

// @public (undocumented)
function setSegmentIndexLocked(toolGroupId: string, segmentIndex: number, locked?: boolean): void;

// @public (undocumented)
function setSegmentIndexLockedForSegmentation(segmentationUID: string, segmentIndex: number, locked?: boolean): void;

// @public (undocumented)
type SetToolBindingsType = {
    bindings: IToolBinding[];
};

// @public (undocumented)
function setToolStyle(toolName: string, style: Record<string, unknown>): boolean;

// @public (undocumented)
function snapFocalPointToSlice(focalPoint: Types_2.Point3, position: Types_2.Point3, scrollRange: any, viewPlaneNormal: Types_2.Point3, spacingInNormalDirection: number, deltaFrames: number): {
    newFocalPoint: Types_2.Point3;
    newPosition: Types_2.Point3;
};

// @public (undocumented)
export class SphereScissorsTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _activateDraw: (element: any) => void;
    // (undocumented)
    addNewAnnotation: (evt: EventTypes_2.MouseDownActivateEventType) => void;
    // (undocumented)
    _deactivateDraw: (element: any) => void;
    // (undocumented)
    editData: {
        annotation: any;
        segmentation: any;
        segmentIndex: number;
        segmentsLocked: number[];
        segmentationDataUID: string;
        toolGroupId: string;
        segmentColor: [number, number, number, number];
        viewportIdsToRender: string[];
        handleIndex?: number;
        movingTextBox: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        centerCanvas?: Array<number>;
    } | null;
    // (undocumented)
    isDrawing: boolean;
    // (undocumented)
    isHandleOutsideImage: boolean;
    // (undocumented)
    _mouseDragCallback: (evt: EventTypes_2.MouseDragEventType) => void;
    // (undocumented)
    _mouseUpCallback: (evt: EventTypes_2.MouseUpEventType | EventTypes_2.MouseClickEventType) => void;
    // (undocumented)
    renderAnnotation: (enabledElement: Types_2.IEnabledElement, svgDrawingHelper: any) => void;
    // (undocumented)
    static toolName: string;
}

// @public
type StackNewImageEvent = CustomEvent_2<StackNewImageEventDetail>

// @public
type StackNewImageEventDetail = {
    image: IImage
    imageId: string
    viewportId: string
    renderingEngineId: string
}

// @public (undocumented)
export class StackScrollMouseWheelTool extends BaseTool {
    constructor(toolProps?: {}, defaultToolProps?: {
        supportedInteractionTypes: string[];
        invert: boolean;
    });
    // (undocumented)
    _configuration: any;
    // (undocumented)
    mouseWheelCallback(evt: MouseWheelEventType): void;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
export class StackScrollTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: EventTypes_2.MouseDragEventType): void;
    // (undocumented)
    mouseDragCallback: () => void;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    touchDragCallback: () => void;
}

declare namespace stackScrollTool {
    export {
        snapFocalPointToSlice,
        getSliceRange,
        scrollThroughStack,
        _default_14 as default
    }
}

// @public
type StackViewportProperties = {
    voiRange?: VOIRange
    invert?: boolean
    interpolationType?: InterpolationType
    rotation?: number
    flipHorizontal?: boolean
    flipVertical?: boolean
}

declare namespace state {
    export {
        getAnnotations,
        addAnnotation,
        getAnnotation,
        removeAnnotation,
        getViewportSpecificAnnotationManager,
        getDefaultAnnotationManager
    }
}

declare namespace state_2 {
    export {
        getGlobalSegmentationConfig,
        getSegmentationConfig,
        setGlobalSegmentationConfig,
        setSegmentationConfig,
        addColorLUT,
        getColorLut,
        getGlobalSegmentationState,
        getGlobalSegmentationDataByUID,
        addGlobalSegmentationData,
        getSegmentationState,
        addSegmentationData,
        removeSegmentationData,
        getSegmentationDataByUID,
        setActiveSegmentationData,
        getActiveSegmentationData,
        getToolGroupsWithSegmentation,
        getToolGroups,
        getDefaultSegmentationStateManager
    }
}

// @public (undocumented)
type SVGCursorDescriptor = {
    iconContent: string;
    iconSize: number;
    viewBox: SVGPoint_2;
    mousePoint: SVGPoint_2;
    mousePointerGroupString: string;
};

// @public (undocumented)
class SVGMouseCursor extends ImageMouseCursor {
    constructor(url: string, x?: number, y?: number, name?: string | undefined, fallback?: MouseCursor | undefined);
    // (undocumented)
    static getDefinedCursor(name: string, pointer?: boolean, color?: string): MouseCursor;
}

// @public (undocumented)
type SVGPoint_2 = {
    x: number;
    y: number;
};

// @public (undocumented)
export class Synchronizer {
    constructor(synchronizerId: string, eventName: string, eventHandler: ISynchronizerEventHandler);
    // (undocumented)
    add(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    addSource(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    addTarget(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    getSourceViewports(): Array<Types_2.IViewportId>;
    // (undocumented)
    getTargetViewports(): Array<Types_2.IViewportId>;
    // (undocumented)
    hasSourceViewport(renderingEngineId: string, viewportId: string): boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    isDisabled(): boolean;
    // (undocumented)
    remove(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    removeSource(viewportInfo: Types_2.IViewportId): void;
    // (undocumented)
    removeTarget(viewportInfo: Types_2.IViewportId): void;
}

declare namespace SynchronizerManager {
    export {
        createSynchronizer,
        destroy_2 as destroy,
        getSynchronizerById,
        getSynchronizers,
        getAllSynchronizers,
        destroySynchronizerById
    }
}
export { SynchronizerManager }

declare namespace synchronizers {
    export {
        createCameraPositionSynchronizer,
        createVOISynchronizer
    }
}
export { synchronizers }

// @public (undocumented)
type TextBoxHandle = {
    hasMoved: boolean;
    worldBoundingBox: {
        bottomLeft: Types_2.Point3;
        bottomRight: Types_2.Point3;
        topLeft: Types_2.Point3;
        topRight: Types_2.Point3;
    };
    worldPosition: Types_2.Point3;
};

// @public (undocumented)
function thresholdVolumeByRange(toolGroupId: string, annotations: AnnotationForThresholding[], referenceVolumes: Types_2.IImageVolume[], segmentationData: ToolGroupSpecificSegmentationData, options: ThresholdRangeOptions): Types_2.IImageVolume;

// @public (undocumented)
function thresholdVolumeByRoiStats(toolGroupId: string, annotations: AnnotationForThresholding[], referenceVolumes: Types_2.IImageVolume[], segmentationData: ToolGroupSpecificSegmentationData, options: ThresholdRoiStatsOptions): void;

// @public (undocumented)
function throttle(func: Function, wait?: number, options?: {
    leading?: boolean;
    trailing?: boolean;
}): Function;

declare namespace ToolGroupManager {
    export {
        _default as default,
        createToolGroup,
        destroy_3 as destroy,
        destroyToolGroupByToolGroupId,
        getToolGroupByToolGroupId,
        getToolGroup,
        getAllToolGroups
    }
}
export { ToolGroupManager }

// @public (undocumented)
type ToolGroupSpecificSegmentationData = {
    volumeId: string;
    segmentationDataUID: string;
    active: boolean;
    segmentsHidden: Set<number>;
    visibility: boolean;
    colorLUTIndex: number;
    representation: SegmentationRepresentation;
};

// @public (undocumented)
type ToolGroupSpecificSegmentationState = ToolGroupSpecificSegmentationData[];

// @public (undocumented)
type ToolGroupSpecificSegmentationStateWithConfig = {
    segmentations: ToolGroupSpecificSegmentationState;
    config: SegmentationConfig;
};

// @public (undocumented)
type ToolHandle = AnnotationHandle | TextBoxHandle;

// @public (undocumented)
type ToolOptionsType = {
    bindings: IToolBinding[];
    mode: ToolModes;
};

// @public (undocumented)
type ToolProps = SharedToolProp;

// @public
type TransformMatrix2D = [number, number, number, number, number, number]

// @public (undocumented)
function transformPhysicalToIndex(imageData: any, physicalPoint: any): any;

// @public (undocumented)
function triggerAnnotationRenderForViewportIds(renderingEngine: Types_2.IRenderingEngine, viewportIdsToRender: string[]): void;

// @public
function triggerEvent(
el: EventTarget = eventTarget,
type: string,
detail: unknown = null
): boolean {
    if (!type) {
        throw new Error('Event type was not defined')
    }

    const // (undocumented)
    event = new CustomEvent(type, {
        detail,
        cancelable: true,
    })

    return el.dispatchEvent(event)
}

// @public (undocumented)
function triggerSegmentationDataModified(toolGroupId: string, segmentationDataUID: string): void;

declare namespace triggerSegmentationEvents {
    export {
        triggerSegmentationStateModified,
        triggerSegmentationDataModified,
        triggerSegmentationGlobalStateModified
    }
}

// @public (undocumented)
function triggerSegmentationGlobalStateModified(segmentationUID?: string): void;

// @public (undocumented)
function triggerSegmentationStateModified(toolGroupId: string): void;

declare namespace Types {
    export {
        Annotation,
        Annotations,
        FrameOfReferenceSpecificAnnotations,
        AnnotationState,
        PlanarBoundingBox,
        ToolProps,
        PublicToolProps,
        EventTypes_2 as EventTypes,
        IPoints,
        IToolBinding,
        SetToolBindingsType,
        ToolOptionsType,
        InteractionTypes,
        IToolGroup,
        ToolHandle,
        AnnotationHandle,
        TextBoxHandle,
        SegmentationRepresentation,
        LabelmapRepresentation,
        Color,
        ColorLUT,
        RepresentationConfig,
        SegmentationConfig,
        GlobalSegmentationData,
        GlobalSegmentationState,
        GlobalSegmentationStateWithConfig,
        ToolGroupSpecificSegmentationData,
        ToolGroupSpecificSegmentationStateWithConfig,
        ToolGroupSpecificSegmentationState,
        SVGCursorDescriptor,
        SVGPoint_2 as SVGPoint
    }
}
export { Types }

// @public (undocumented)
function unlockAllAnnotations(): void;

// @public (undocumented)
function updateGlobalRepresentationConfig(representationType: SegmentationRepresentations, config: Partial<RepresentationConfig>): void;

// @public (undocumented)
function updateGlobalSegmentationConfig(config: Partial<SegmentationConfig>): void;

declare namespace utilities {
    export {
        math,
        planar,
        viewportFilters,
        stackScrollTool,
        drawing_2 as drawing,
        debounce,
        deepmerge as deepMerge,
        throttle,
        isObject,
        triggerEvent,
        calibrateImageSpacing,
        segmentation_2 as segmentation,
        triggerAnnotationRenderForViewportIds,
        pointInShapeCallback,
        pointInSurroundingSphereCallback,
        getAnnotationNearPoint,
        getAnnotationNearPointOnEnabledElement,
        transformPhysicalToIndex,
        _default_17 as default
    }
}
export { utilities }

declare namespace viewportFilters {
    export {
        _default_13 as default,
        filterViewportsWithToolEnabled,
        filterViewportsWithFrameOfReferenceUID,
        getViewportIdsWithToolToRender
    }
}

// @public
type ViewportInputOptions = {
    background?: [number, number, number]
    orientation?: Orientation
    suppressEvents?: boolean
}

// @public (undocumented)
type VOI = {
    windowWidth: number
    windowCenter: number
}

// @public
type VoiModifiedEvent = CustomEvent_2<VoiModifiedEventDetail>

// @public
type VoiModifiedEventDetail = {
    viewportId: string
    volumeId: string
    range: VOIRange
}

// @public (undocumented)
type VOIRange = {
    upper: number
    lower: number
}

// @public
type VolumeActor = vtkVolume

// @public
type VolumeCacheVolumeAddedEvent =
CustomEvent_2<VolumeCacheVolumeAddedEventDetail>

// @public
type VolumeCacheVolumeAddedEventDetail = {
    volume: ICachedVolume
}

// @public
type VolumeCacheVolumeRemovedEvent =
CustomEvent_2<VolumeCacheVolumeRemovedEventDetail>

// @public
type VolumeCacheVolumeRemovedEventDetail = {
    volumeId: string
}

// @public
type VolumeInputCallback = (params: {
    volumeActor: VolumeActor
    volumeId: string
}) => unknown

// @public
type VolumeLoadedEvent = CustomEvent_2<VolumeLoadedEventDetail>

// @public
type VolumeLoadedEventDetail = {
    volume: IImageVolume
}

// @public
type VolumeLoadedFailedEvent = CustomEvent_2<VolumeLoadedFailedEventDetail>

// @public
type VolumeLoadedFailedEventDetail = {
    volumeId: string
    error: unknown
}

// @public
type VolumeLoaderFn = (
volumeId: string,
options?: Record<string, any>
) => {
    promise: Promise<Record<string, any>>
    cancelFn?: () => void | undefined
    decache?: () => void | undefined
}

// @public (undocumented)
export class VolumeRotateMouseWheelTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _configuration: any;
    // (undocumented)
    mouseWheelCallback(evt: MouseWheelEventType): void;
    // (undocumented)
    static toolName: string;
}

// @public (undocumented)
export class WindowLevelTool extends BaseTool {
    constructor(toolProps?: {}, defaultToolProps?: {
        supportedInteractionTypes: string[];
    });
    // (undocumented)
    _dragCallback(evt: any): void;
    // (undocumented)
    _getImageDynamicRange: (volumeId: string) => number;
    // (undocumented)
    _getMultiplyerFromDynamicRange(volumeId: any): number;
    // (undocumented)
    getNewRange({ deltaPointsCanvas, useDynamicRange, volumeId, lower, upper }: {
        deltaPointsCanvas: any;
        useDynamicRange: any;
        volumeId: any;
        lower: any;
        upper: any;
    }): {
        lower: number;
        upper: number;
    };
    // (undocumented)
    getPTNewRange({ deltaPointsCanvas, lower, upper, clientHeight }: {
        deltaPointsCanvas: any;
        lower: any;
        upper: any;
        clientHeight: any;
    }): {
        lower: any;
        upper: any;
    };
    // (undocumented)
    mouseDragCallback: () => void;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    touchDragCallback: () => void;
}

// @public (undocumented)
export class ZoomTool extends BaseTool {
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    // (undocumented)
    _dragCallback(evt: any): void;
    // (undocumented)
    _dragParallelProjection: (evt: any, camera: any) => void;
    // (undocumented)
    _dragPerspectiveProjection: (evt: any, camera: any) => void;
    // (undocumented)
    mouseDragCallback: () => void;
    // (undocumented)
    static toolName: string;
    // (undocumented)
    touchDragCallback: () => void;
}

// (No @packageDocumentation comment for this package)

```

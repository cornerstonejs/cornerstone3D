## API Report File for "@cornerstonejs/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { mat4 } from 'gl-matrix';
import { vec3 } from 'gl-matrix';
import type vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';
import type { vtkCamera } from '@kitware/vtk.js/Rendering/Core/Camera';
import type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';
import vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import type { VtkObject } from '@kitware/vtk.js/interfaces';
import vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';
import type vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';

// @public (undocumented)
type Actor = vtkActor;

// @public (undocumented)
type ActorEntry = {
    uid: string;
    actor: Actor | VolumeActor | ImageActor;
    slabThickness?: number;
};

// @public (undocumented)
type ActorSliceRange = {
    actor: VolumeActor;
    viewPlaneNormal: Point3;
    focalPoint: Point3;
    min: number;
    max: number;
    current: number;
};

// @public (undocumented)
function addProvider(provider: (type: string, imageId: string) => {
    any: any;
}, priority?: number): void;

// @public (undocumented)
export function addVolumesToViewports(renderingEngine: IRenderingEngine, volumeInputs: Array<IVolumeInput>, viewportIds: Array<string>, immediateRender?: boolean, suppressEvents?: boolean): Promise<void>;

// @public (undocumented)
enum BlendModes {
    // (undocumented)
    AVERAGE_INTENSITY_BLEND = 3,
    // (undocumented)
    COMPOSITE = 0,
    // (undocumented)
    MAXIMUM_INTENSITY_BLEND = 1,
    // (undocumented)
    MINIMUM_INTENSITY_BLEND = 2
}

// @public (undocumented)
export const cache: Cache_2;

// @public (undocumented)
type CameraModifiedEvent = CustomEvent_2<CameraModifiedEventDetail>;

// @public (undocumented)
type CameraModifiedEventDetail = {
    previousCamera: ICamera;
    camera: ICamera;
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    rotation?: number;
};

// @public (undocumented)
function cancelLoadAll(): void;

// @public (undocumented)
function cancelLoadImage(imageId: string): void;

// @public (undocumented)
function cancelLoadImages(imageIds: Array<string>): void;

// @public (undocumented)
const colormapsData: CPUFallbackColormapsData;

declare namespace CONSTANTS {
    export {
        ORIENTATION,
        colormapsData as CPU_COLORMAPS,
        RENDERING_DEFAULTS
    }
}
export { CONSTANTS }

// @public (undocumented)
interface CPUFallbackColormap {
    // (undocumented)
    addColor: (rgba: Point4) => void;
    // (undocumented)
    buildLookupTable: (lut: CPUFallbackLookupTable) => void;
    // (undocumented)
    clearColors: () => void;
    // (undocumented)
    createLookupTable: () => CPUFallbackLookupTable;
    // (undocumented)
    getColor: (index: number) => Point4;
    // (undocumented)
    getColorRepeating: (index: number) => Point4;
    // (undocumented)
    getColorSchemeName: () => string;
    // (undocumented)
    getId: () => string;
    // (undocumented)
    getNumberOfColors: () => number;
    // (undocumented)
    insertColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    isValidIndex: (index: number) => boolean;
    // (undocumented)
    removeColor: (index: number) => void;
    // (undocumented)
    setColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    setColorSchemeName: (name: string) => void;
    // (undocumented)
    setNumberOfColors: (numColors: number) => void;
}

// @public (undocumented)
type CPUFallbackColormapData = {
    name: string;
    numOfColors?: number;
    colors?: Point4[];
    segmentedData?: unknown;
    numColors?: number;
    gamma?: number;
};

// @public (undocumented)
type CPUFallbackColormapsData = {
    [key: string]: CPUFallbackColormapData;
};

// @public (undocumented)
interface CPUFallbackEnabledElement {
    // (undocumented)
    canvas?: HTMLCanvasElement;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    image?: IImage;
    // (undocumented)
    invalid?: boolean;
    // (undocumented)
    metadata?: {
        direction?: Float32Array;
        dimensions?: Point3;
        spacing?: Point3;
        origin?: Point3;
        imagePlaneModule?: {
            frameOfReferenceUID: string;
            rows: number;
            columns: number;
            imageOrientationPatient: number[];
            rowCosines: Point3;
            columnCosines: Point3;
            imagePositionPatient: number[];
            sliceThickness?: number;
            sliceLocation?: number;
            pixelSpacing: Point2;
            rowPixelSpacing: number;
            columnPixelSpacing: number;
        };
        imagePixelModule?: {
            samplesPerPixel: number;
            photometricInterpretation: string;
            rows: number;
            columns: number;
            bitsAllocated: number;
            bitsStored: number;
            highBit: number;
            pixelRepresentation: number;
            planarConfiguration?: number;
            pixelAspectRatio?: number;
            smallestPixelValue?: number;
            largestPixelValue?: number;
            redPaletteColorLookupTableDescriptor?: number[];
            greenPaletteColorLookupTableDescriptor?: number[];
            bluePaletteColorLookupTableDescriptor?: number[];
            redPaletteColorLookupTableData: number[];
            greenPaletteColorLookupTableData: number[];
            bluePaletteColorLookupTableData: number[];
        };
    };
    // (undocumented)
    needsRedraw?: boolean;
    // (undocumented)
    options?: {
        [key: string]: unknown;
        colormap?: CPUFallbackColormap;
    };
    // (undocumented)
    pan?: Point2;
    // (undocumented)
    renderingTools?: CPUFallbackRenderingTools;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    transform?: CPUFallbackTransform;
    // (undocumented)
    viewport?: CPUFallbackViewport;
    // (undocumented)
    zoom?: number;
}

// @public (undocumented)
interface CPUFallbackLookupTable {
    // (undocumented)
    build: (force: boolean) => void;
    // (undocumented)
    getColor: (scalar: number) => Point4;
    // (undocumented)
    setAlphaRange: (start: number, end: number) => void;
    // (undocumented)
    setHueRange: (start: number, end: number) => void;
    // (undocumented)
    setNumberOfTableValues: (number: number) => void;
    // (undocumented)
    setRamp: (ramp: string) => void;
    // (undocumented)
    setRange: (start: number, end: number) => void;
    // (undocumented)
    setSaturationRange: (start: number, end: number) => void;
    // (undocumented)
    setTableRange: (start: number, end: number) => void;
    // (undocumented)
    setTableValue(index: number, rgba: Point4): any;
    // (undocumented)
    setValueRange: (start: number, end: number) => void;
}

// @public (undocumented)
type CPUFallbackLUT = {
    lut: number[];
};

// @public (undocumented)
type CPUFallbackRenderingTools = {
    renderCanvas?: HTMLCanvasElement;
    lastRenderedIsColor?: boolean;
    lastRenderedImageId?: string;
    lastRenderedViewport?: {
        windowWidth: number | number[];
        windowCenter: number | number[];
        invert: boolean;
        rotation: number;
        hflip: boolean;
        vflip: boolean;
        modalityLUT: CPUFallbackLUT;
        voiLUT: CPUFallbackLUT;
        colormap: unknown;
    };
    renderCanvasContext?: {
        putImageData: (renderCanvasData: unknown, dx: number, dy: number) => unknown;
    };
    colormapId?: string;
    colorLUT?: CPUFallbackLookupTable;
    renderCanvasData?: {
        data: Uint8ClampedArray;
    };
};

// @public (undocumented)
interface CPUFallbackTransform {
    // (undocumented)
    clone: () => CPUFallbackTransform;
    // (undocumented)
    getMatrix: () => TransformMatrix2D;
    // (undocumented)
    invert: () => void;
    // (undocumented)
    multiply: (matrix: TransformMatrix2D) => void;
    // (undocumented)
    reset: () => void;
    // (undocumented)
    rotate: (rad: number) => void;
    // (undocumented)
    scale: (sx: number, sy: number) => void;
    // (undocumented)
    transformPoint: (point: Point2) => Point2;
    // (undocumented)
    translate: (x: number, y: number) => void;
}

// @public (undocumented)
type CPUFallbackViewport = {
    scale?: number;
    parallelScale?: number;
    focalPoint?: number[];
    translation?: {
        x: number;
        y: number;
    };
    voi?: {
        windowWidth: number;
        windowCenter: number;
    };
    invert?: boolean;
    pixelReplication?: boolean;
    rotation?: number;
    hflip?: boolean;
    vflip?: boolean;
    modalityLUT?: CPUFallbackLUT;
    voiLUT?: CPUFallbackLUT;
    colormap?: CPUFallbackColormap;
    displayedArea?: CPUFallbackViewportDisplayedArea;
    modality?: string;
};

// @public (undocumented)
type CPUFallbackViewportDisplayedArea = {
    tlhc: {
        x: number;
        y: number;
    };
    brhc: {
        x: number;
        y: number;
    };
    rowPixelSpacing: number;
    columnPixelSpacing: number;
    presentationSizeMode: string;
};

// @public (undocumented)
type CPUIImageData = {
    dimensions: Point3;
    direction: Float32Array;
    spacing: Point3;
    origin: Point3;
    imageData: CPUImageData;
    metadata: {
        Modality: string;
    };
    scalarData: number[];
    scaling: Scaling;
    hasPixelSpacing?: boolean;
};

// @public (undocumented)
type CPUImageData = {
    worldToIndex?: (point: Point3) => Point3;
    indexToWorld?: (point: Point3) => Point3;
    getWorldToIndex?: () => Point3;
    getIndexToWorld?: () => Point3;
    getSpacing?: () => Point3;
    getDirection?: () => Float32Array;
    getScalarData?: () => number[];
    getDimensions?: () => Point3;
};

// @public (undocumented)
function createAndCacheDerivedVolume(referencedVolumeId: string, options: DerivedVolumeOptions): ImageVolume;

// @public (undocumented)
function createAndCacheVolume(volumeId: string, options: VolumeLoaderOptions): Promise<Record<string, any>>;

// @public (undocumented)
function createFloat32SharedArray(length: number): Float32Array;

// @public (undocumented)
function createLocalVolume(options: LocalVolumeOptions, volumeId: string, preventCache?: boolean): ImageVolume;

// @public (undocumented)
function createUint8SharedArray(length: number): Uint8Array;

// @public (undocumented)
export function createVolumeActor(props: createVolumeActorInterface, element: HTMLDivElement, viewportId: string, suppressEvents?: boolean): Promise<VolumeActor>;

// @public (undocumented)
export function createVolumeMapper(imageData: any, vtkOpenGLTexture: any): any;

// @public (undocumented)
interface CustomEvent_2<T = any> extends Event {
    // (undocumented)
    readonly detail: T;
    // (undocumented)
    initCustomEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, detailArg: T): void;
}

// @public (undocumented)
type ElementDisabledEvent = CustomEvent_2<ElementDisabledEventDetail>;

// @public (undocumented)
type ElementDisabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type ElementEnabledEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public (undocumented)
type ElementEnabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

declare namespace Enums {
    export {
        EVENTS as Events,
        BlendModes,
        InterpolationType,
        RequestType,
        ViewportType
    }
}
export { Enums }

// @public (undocumented)
export enum EVENTS {
    // (undocumented)
    CACHE_SIZE_EXCEEDED = "CACHE_SIZE_EXCEEDED",
    // (undocumented)
    CAMERA_MODIFIED = "CORNERSTONE_CAMERA_MODIFIED",
    // (undocumented)
    ELEMENT_DISABLED = "CORNERSTONE_ELEMENT_DISABLED",
    // (undocumented)
    ELEMENT_ENABLED = "CORNERSTONE_ELEMENT_ENABLED",
    // (undocumented)
    IMAGE_CACHE_IMAGE_ADDED = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED",
    // (undocumented)
    IMAGE_CACHE_IMAGE_REMOVED = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED",
    // (undocumented)
    IMAGE_LOAD_ERROR = "IMAGE_LOAD_ERROR",
    // (undocumented)
    IMAGE_LOAD_FAILED = "CORNERSTONE_IMAGE_LOAD_FAILED",
    // (undocumented)
    IMAGE_LOAD_PROGRESS = "CORNERSTONE_IMAGE_LOAD_PROGRESS",
    // (undocumented)
    IMAGE_LOADED = "CORNERSTONE_IMAGE_LOADED",
    // (undocumented)
    IMAGE_RENDERED = "CORNERSTONE_IMAGE_RENDERED",
    // (undocumented)
    IMAGE_SPACING_CALIBRATED = "CORNERSTONE_IMAGE_SPACING_CALIBRATED",
    // (undocumented)
    IMAGE_VOLUME_MODIFIED = "CORNERSTONE_IMAGE_VOLUME_MODIFIED",
    // (undocumented)
    PRE_STACK_NEW_IMAGE = "CORNERSTONE_PRE_STACK_NEW_IMAGE",
    // (undocumented)
    STACK_NEW_IMAGE = "CORNERSTONE_STACK_NEW_IMAGE",
    // (undocumented)
    STACK_VIEWPORT_NEW_STACK = "CORNERSTONE_STACK_VIEWPORT_NEW_STACK",
    // (undocumented)
    STACK_VIEWPORT_SCROLL = "CORNERSTONE_STACK_VIEWPORT_SCROLL",
    // (undocumented)
    VOI_MODIFIED = "CORNERSTONE_VOI_MODIFIED",
    // (undocumented)
    VOLUME_CACHE_VOLUME_ADDED = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED",
    // (undocumented)
    VOLUME_CACHE_VOLUME_REMOVED = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED",
    // (undocumented)
    VOLUME_LOADED = "CORNERSTONE_VOLUME_LOADED",
    // (undocumented)
    VOLUME_LOADED_FAILED = "CORNERSTONE_VOLUME_LOADED_FAILED",
    // (undocumented)
    VOLUME_NEW_IMAGE = "CORNERSTONE_VOLUME_NEW_IMAGE"
}

// @public (undocumented)
export const eventTarget: CornerstoneEventTarget;

declare namespace EventTypes {
    export {
        CameraModifiedEventDetail,
        CameraModifiedEvent,
        VoiModifiedEvent,
        VoiModifiedEventDetail,
        ElementDisabledEvent,
        ElementDisabledEventDetail,
        ElementEnabledEvent,
        ElementEnabledEventDetail,
        ImageRenderedEventDetail,
        ImageRenderedEvent,
        ImageVolumeModifiedEvent,
        ImageVolumeModifiedEventDetail,
        ImageLoadedEvent,
        ImageLoadedEventDetail,
        ImageLoadedFailedEventDetail,
        ImageLoadedFailedEvent,
        VolumeLoadedEvent,
        VolumeLoadedEventDetail,
        VolumeLoadedFailedEvent,
        VolumeLoadedFailedEventDetail,
        ImageCacheImageAddedEvent,
        ImageCacheImageAddedEventDetail,
        ImageCacheImageRemovedEvent,
        ImageCacheImageRemovedEventDetail,
        VolumeCacheVolumeAddedEvent,
        VolumeCacheVolumeAddedEventDetail,
        VolumeCacheVolumeRemovedEvent,
        VolumeCacheVolumeRemovedEventDetail,
        StackNewImageEvent,
        StackNewImageEventDetail,
        PreStackNewImageEvent,
        PreStackNewImageEventDetail,
        ImageSpacingCalibratedEvent,
        ImageSpacingCalibratedEventDetail,
        ImageLoadProgressEvent,
        ImageLoadProgressEventDetail,
        VolumeNewImageEvent,
        VolumeNewImageEventDetail,
        StackViewportNewStackEvent,
        StackViewportNewStackEventDetail,
        StackViewportScrollEvent,
        StackViewportScrollEventDetail
    }
}

// @public (undocumented)
type FlipDirection = {
    flipHorizontal?: boolean;
    flipVertical?: boolean;
};

// @public (undocumented)
function getClosestImageId(imageVolume: IImageVolume, worldPos: Point3, viewPlaneNormal: Point3, viewUp: Point3): string;

// @public (undocumented)
export function getEnabledElement(element: HTMLDivElement | undefined): IEnabledElement | undefined;

// @public (undocumented)
export function getEnabledElementByIds(viewportId: string, renderingEngineId: string): IEnabledElement;

// @public (undocumented)
export function getEnabledElements(): IEnabledElement[];

// @public (undocumented)
function getImageSliceDataForVolumeViewport(viewport: IVolumeViewport): ImageSliceData;

// @public (undocumented)
function getMetaData(type: string, imageId: string): any;

// @public (undocumented)
function getMinMax(storedPixelData: number[]): {
    min: number;
    max: number;
};

// @public (undocumented)
export function getOrCreateCanvas(element: HTMLDivElement): HTMLCanvasElement;

// @public (undocumented)
export function getRenderingEngine(id: string): IRenderingEngine | undefined;

// @public (undocumented)
export function getRenderingEngines(): IRenderingEngine[] | undefined;

// @public (undocumented)
function getRuntimeId(context?: unknown, separator?: string, max?: number): string;

// @public (undocumented)
function getScalingParameters(imageId: string): ScalingParameters | undefined;

// @public (undocumented)
export function getShouldUseCPURendering(): boolean;

// @public (undocumented)
function getSliceRange(volumeActor: VolumeActor, viewPlaneNormal: Point3, focalPoint: Point3): ActorSliceRange;

// @public (undocumented)
function getSpacingInNormalDirection(imageVolume: IImageVolume, viewPlaneNormal: Point3): number;

// @public (undocumented)
function getTargetVolumeAndSpacingInNormalDir(viewport: IVolumeViewport, camera: ICamera, targetVolumeId?: string): {
    imageVolume: IImageVolume;
    spacingInNormalDirection: number;
};

// @public (undocumented)
function getVolumeActorCorners(volumeActor: any): Array<Point3>;

// @public (undocumented)
function getVolumeViewportsContainingSameVolumes(targetViewport: IVolumeViewport, renderingEngineId?: string): Array<IVolumeViewport>;

// @public (undocumented)
function getVolumeViewportsContainingVolumeId(volumeId: string, renderingEngineId?: string): Array<IVolumeViewport>;

// @public (undocumented)
interface ICache {
    // (undocumented)
    getCacheSize: () => number;
    // (undocumented)
    getImageLoadObject: (imageId: string) => IImageLoadObject | void;
    // (undocumented)
    getMaxCacheSize: () => number;
    // (undocumented)
    getVolumeLoadObject: (volumeId: string) => IVolumeLoadObject | void;
    // (undocumented)
    purgeCache: () => void;
    // (undocumented)
    putImageLoadObject: (imageId: string, imageLoadObject: IImageLoadObject) => Promise<any>;
    // (undocumented)
    putVolumeLoadObject: (volumeId: string, volumeLoadObject: IVolumeLoadObject) => Promise<any>;
    // (undocumented)
    setMaxCacheSize: (maxCacheSize: number) => void;
}

// @public (undocumented)
interface ICachedImage {
    // (undocumented)
    image?: IImage;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageLoadObject: IImageLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedVolume {
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
    // (undocumented)
    volume?: IImageVolume;
    // (undocumented)
    volumeId: string;
    // (undocumented)
    volumeLoadObject: IVolumeLoadObject;
}

// @public (undocumented)
interface ICamera {
    // (undocumented)
    flipHorizontal?: boolean;
    // (undocumented)
    flipVertical?: boolean;
    // (undocumented)
    focalPoint?: Point3;
    // (undocumented)
    parallelProjection?: boolean;
    // (undocumented)
    parallelScale?: number;
    // (undocumented)
    position?: Point3;
    // (undocumented)
    scale?: number;
    // (undocumented)
    viewAngle?: number;
    // (undocumented)
    viewPlaneNormal?: Point3;
    // (undocumented)
    viewUp?: Point3;
}

// @public (undocumented)
interface IEnabledElement {
    // (undocumented)
    FrameOfReferenceUID: string;
    // (undocumented)
    renderingEngine: IRenderingEngine;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewport: IStackViewport | IVolumeViewport;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
interface IImage {
    // (undocumented)
    cachedLut?: {
        windowWidth?: number | number[];
        windowCenter?: number | number[];
        invert?: boolean;
        lutArray?: Uint8ClampedArray;
        modalityLUT?: unknown;
        voiLUT?: CPUFallbackLUT;
    };
    // (undocumented)
    color: boolean;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    columnPixelSpacing: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    getCanvas: () => HTMLCanvasElement;
    // (undocumented)
    getPixelData: () => Array<number>;
    // (undocumented)
    height: number;
    // (undocumented)
    imageId: string;
    // (undocumented)
    intercept: number;
    // (undocumented)
    invert: boolean;
    // (undocumented)
    isPreScaled?: boolean;
    // (undocumented)
    maxPixelValue: number;
    // (undocumented)
    minPixelValue: number;
    // (undocumented)
    modalityLUT?: CPUFallbackLUT;
    // (undocumented)
    numComps: number;
    // (undocumented)
    render?: (enabledElement: CPUFallbackEnabledElement, invalidated: boolean) => unknown;
    // (undocumented)
    rgba: boolean;
    // (undocumented)
    rowPixelSpacing: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    sliceThickness?: number;
    // (undocumented)
    slope: number;
    // (undocumented)
    stats?: {
        lastStoredPixelDataToCanvasImageDataTime?: number;
        lastGetPixelDataTime?: number;
        lastPutImageDataTime?: number;
        lastLutGenerateTime?: number;
        lastRenderedViewport?: unknown;
        lastRenderTime?: number;
    };
    // (undocumented)
    voiLUT?: CPUFallbackLUT;
    // (undocumented)
    width: number;
    // (undocumented)
    windowCenter: number[] | number;
    // (undocumented)
    windowWidth: number[] | number;
}

// @public (undocumented)
interface IImageData {
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Float32Array;
    // (undocumented)
    hasPixelSpacing?: boolean;
    // (undocumented)
    imageData: vtkImageData;
    // (undocumented)
    metadata: {
        Modality: string;
    };
    // (undocumented)
    origin: Point3;
    // (undocumented)
    scalarData: Float32Array;
    // (undocumented)
    scaling?: Scaling;
    // (undocumented)
    spacing: Point3;
}

// @public (undocumented)
interface IImageLoadObject {
    // (undocumented)
    cancel?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IImage>;
}

// @public (undocumented)
interface IImageVolume {
    // (undocumented)
    convertToCornerstoneImage?: (imageId: string, imageIdIndex: number) => IImageLoadObject;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Float32Array;
    // (undocumented)
    hasPixelSpacing: boolean;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    imageIds?: Array<string>;
    // (undocumented)
    isPrescaled: boolean;
    // (undocumented)
    loadStatus?: Record<string, any>;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    numVoxels: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scalarData: any;
    // (undocumented)
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    readonly volumeId: string;
    // (undocumented)
    vtkOpenGLTexture: any;
}

// @public (undocumented)
type ImageCacheImageAddedEvent = CustomEvent_2<ImageCacheImageAddedEventDetail>;

// @public (undocumented)
type ImageCacheImageAddedEventDetail = {
    image: ICachedImage;
};

// @public (undocumented)
type ImageCacheImageRemovedEvent = CustomEvent_2<ImageCacheImageRemovedEventDetail>;

// @public (undocumented)
type ImageCacheImageRemovedEventDetail = {
    imageId: string;
};

// @public (undocumented)
function imageIdToURI(imageId: string): string;

// @public (undocumented)
type ImageLoadedEvent = CustomEvent_2<ImageLoadedEventDetail>;

// @public (undocumented)
type ImageLoadedEventDetail = {
    image: IImage;
};

// @public (undocumented)
type ImageLoadedFailedEvent = CustomEvent_2<ImageLoadedFailedEventDetail>;

// @public (undocumented)
type ImageLoadedFailedEventDetail = {
    imageId: string;
    error: unknown;
};

declare namespace imageLoader {
    export {
        loadImage,
        loadAndCacheImage,
        loadAndCacheImages,
        cancelLoadImage,
        cancelLoadImages,
        cancelLoadAll,
        registerImageLoader,
        registerUnknownImageLoader,
        unregisterAllImageLoaders,
        ImageLoaderOptions
    }
}
export { imageLoader }

// @public (undocumented)
type ImageLoaderFn = (imageId: string, options?: Record<string, any>) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
interface ImageLoaderOptions {
    // (undocumented)
    additionalDetails?: Record<string, unknown>;
    // (undocumented)
    priority: number;
    // (undocumented)
    requestType: string;
}

// @public (undocumented)
const imageLoadPoolManager: RequestPoolManager;
export { imageLoadPoolManager }
export { imageLoadPoolManager as requestPoolManager }

// @public (undocumented)
type ImageLoadProgressEvent = CustomEvent_2<ImageLoadProgressEventDetail>;

// @public (undocumented)
type ImageLoadProgressEventDetail = {
    url: string;
    imageId: string;
    loaded: number;
    total: number;
    percent: number;
};

// @public (undocumented)
type ImageRenderedEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public (undocumented)
type ImageRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    suppressEvents?: boolean;
};

// @public (undocumented)
export const imageRetrievalPoolManager: RequestPoolManager;

// @public (undocumented)
type ImageSliceData = {
    numberOfSlices: number;
    imageIndex: number;
};

// @public (undocumented)
type ImageSpacingCalibratedEvent = CustomEvent_2<ImageSpacingCalibratedEventDetail>;

// @public (undocumented)
type ImageSpacingCalibratedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    imageId: string;
    rowScale: number;
    columnScale: number;
    imageData: vtkImageData;
    worldToIndex: mat4;
};

// @public (undocumented)
function imageToWorldCoords(imageId: string, imageCoords: Point2): Point3 | undefined;

// @public (undocumented)
export class ImageVolume implements IImageVolume {
    constructor(props: IVolume);
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Float32Array;
    // (undocumented)
    hasPixelSpacing: boolean;
    // (undocumented)
    imageData?: any;
    // (undocumented)
    imageIds?: Array<string>;
    // (undocumented)
    isPrescaled: boolean;
    // (undocumented)
    loadStatus?: Record<string, any>;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    numVoxels: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scalarData: Float32Array | Uint8Array;
    // (undocumented)
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    readonly volumeId: string;
    // (undocumented)
    vtkOpenGLTexture: any;
}

// @public (undocumented)
type ImageVolumeModifiedEvent = CustomEvent_2<ImageVolumeModifiedEventDetail>;

// @public (undocumented)
type ImageVolumeModifiedEventDetail = {
    imageVolume: IImageVolume;
    FrameOfReferenceUID: string;
};

// @public (undocumented)
function indexWithinDimensions(index: Point3, dimensions: Point3): boolean;

// @public (undocumented)
export function init(defaultConfiguration?: {}): Promise<boolean>;

// @public (undocumented)
enum InterpolationType {
    // (undocumented)
    FAST_LINEAR = 2,
    // (undocumented)
    LINEAR = 1,
    // (undocumented)
    NEAREST = 0
}

// @public (undocumented)
function invertRgbTransferFunction(rgbTransferFunction: any): void;

// @public (undocumented)
interface IRegisterImageLoader {
    // (undocumented)
    registerImageLoader: (scheme: string, imageLoader: ImageLoaderFn) => void;
}

// @public (undocumented)
interface IRenderingEngine {
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(canvas: HTMLCanvasElement, backgroundColor: [number, number, number]): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getViewport(id: string): IStackViewport | IVolumeViewport;
    // (undocumented)
    getViewports(): Array<IStackViewport | IVolumeViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference(FrameOfReferenceUID: string): void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, resetPan?: boolean, resetZoom?: boolean): void;
    // (undocumented)
    setViewports(viewports: Array<PublicViewportInput>): void;
}

// @public (undocumented)
export function isCornerstoneInitialized(): boolean;

// @public (undocumented)
function isEqual(v1: number[] | Float32Array, v2: number[] | Float32Array, tolerance?: number): boolean;

// @public (undocumented)
function isImageActor(actor: vtkActor | vtkVolume | vtkImageSlice): boolean;

// @public (undocumented)
function isOpposite(v1: Point3, v2: Point3, tolerance?: number): boolean;

// @public (undocumented)
interface IStackViewport extends IViewport {
    // (undocumented)
    calibrateSpacing(imageId: string): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(): IImageData | CPUIImageData;
    // (undocumented)
    getImageIds: () => string[];
    // (undocumented)
    getProperties: () => StackViewportProperties;
    // (undocumented)
    getRenderer(): any;
    // (undocumented)
    hasImageId: (imageId: string) => boolean;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    isImagePreScaled(imageId: string): boolean;
    // (undocumented)
    modality: string;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scaling: Scaling;
    // (undocumented)
    setCamera(cameraInterface: ICamera): void;
    // (undocumented)
    setColormap(colormap: CPUFallbackColormapData): void;
    // (undocumented)
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    // (undocumented)
    setProperties({ voiRange, invert, interpolationType, rotation }: StackViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    setStack(imageIds: Array<string>, currentImageIdIndex?: number): Promise<string>;
    // (undocumented)
    unsetColormap(): void;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
interface IStreamingImageVolume extends ImageVolume {
    // (undocumented)
    clearLoadCallbacks(): void;
    // (undocumented)
    convertToCornerstoneImage(imageId: string, imageIdIndex: number): any;
    // (undocumented)
    decache(completelyRemove: boolean): void;
}

// @public (undocumented)
interface IStreamingVolumeProperties {
    // (undocumented)
    imageIds: Array<string>;
    // (undocumented)
    loadStatus: {
        loaded: boolean;
        loading: boolean;
        cachedFrames: Array<boolean>;
        callbacks: Array<() => void>;
    };
}

// @public (undocumented)
interface IViewport {
    // (undocumented)
    _actors: Map<string, any>;
    // (undocumented)
    addActor(actorEntry: ActorEntry): void;
    // (undocumented)
    addActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    canvas: HTMLCanvasElement;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => unknown;
    // (undocumented)
    defaultOptions: any;
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    getActor(actorUID: string): ActorEntry;
    // (undocumented)
    getActorByIndex(index: number): ActorEntry;
    // (undocumented)
    getActors(): Array<ActorEntry>;
    // (undocumented)
    getActorUIDByIndex(index: number): string;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    // (undocumented)
    getDefaultActor(): ActorEntry;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getRenderer(): void;
    // (undocumented)
    getRenderingEngine(): any;
    // (undocumented)
    id: string;
    // (undocumented)
    options: ViewportInputOptions;
    // (undocumented)
    removeAllActors(): void;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    reset(immediate: boolean): void;
    // (undocumented)
    setActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera): void;
    // (undocumented)
    setOptions(options: ViewportInputOptions, immediate: boolean): void;
    // (undocumented)
    sHeight: number;
    // (undocumented)
    suppressEvents: boolean;
    // (undocumented)
    sWidth: number;
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    type: ViewportType;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
interface IViewportId {
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
interface IVolume {
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Float32Array;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scalarData: Float32Array | Uint8Array;
    // (undocumented)
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
interface IVolumeInput {
    // (undocumented)
    actorUID?: string;
    // (undocumented)
    blendMode?: BlendModes;
    // (undocumented)
    callback?: VolumeInputCallback;
    // (undocumented)
    slabThickness?: number;
    // (undocumented)
    visibility?: boolean;
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
interface IVolumeLoadObject {
    // (undocumented)
    cancel?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<ImageVolume>;
}

// @public (undocumented)
interface IVolumeViewport extends IViewport {
    // (undocumented)
    addVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    flip(flipDirection: FlipDirection): void;
    // (undocumented)
    getBounds(): any;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(): IImageData | undefined;
    // (undocumented)
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    getProperties: () => any;
    // (undocumented)
    getSlabThickness(): number;
    // (undocumented)
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: Array<string>, immediate?: boolean): void;
    // (undocumented)
    setProperties({ voiRange }: VolumeViewportProperties, volumeId?: string, suppressEvents?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: Array<string>): void;
    // (undocumented)
    setVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
function linePlaneIntersection(p0: Point3, p1: Point3, plane: Plane): Point3;

// @public (undocumented)
function loadAndCacheImage(imageId: string, options?: ImageLoaderOptions): Promise<IImage>;

// @public (undocumented)
function loadAndCacheImages(imageIds: Array<string>, options?: ImageLoaderOptions): Promise<IImage>[];

// @public (undocumented)
function loadImage(imageId: string, options?: ImageLoaderOptions): Promise<IImage>;

// @public (undocumented)
function loadImageToCanvas(canvas: HTMLCanvasElement, imageId: string, requestType?: RequestType, priority?: number): Promise<string>;

// @public (undocumented)
function loadVolume(volumeId: string, options?: VolumeLoaderOptions): Promise<Types.IImageVolume>;

// @public (undocumented)
type Metadata = {
    BitsAllocated: number;
    BitsStored: number;
    SamplesPerPixel: number;
    HighBit: number;
    PhotometricInterpretation: string;
    PixelRepresentation: number;
    Modality: string;
    SeriesInstanceUID?: string;
    ImageOrientationPatient: Array<number>;
    PixelSpacing: Array<number>;
    FrameOfReferenceUID: string;
    Columns: number;
    Rows: number;
    voiLut: Array<VOI>;
};

declare namespace metaData {
    export {
        addProvider,
        removeProvider,
        removeAllProviders,
        getMetaData as get
    }
}
export { metaData }

// @public (undocumented)
const metadataProvider: {
    add: (imageId: string, payload: [number, number]) => void;
    get: (type: string, imageId: string) => [number, number];
};

// @public (undocumented)
const ORIENTATION: Record<string, Orientation>;

// @public (undocumented)
type Orientation = {
    sliceNormal: Point3;
    viewUp: Point3;
};

declare namespace planar {
    export {
        linePlaneIntersection,
        planeEquation,
        threePlaneIntersection
    }
}

// @public (undocumented)
type Plane = [number, number, number, number];

// @public (undocumented)
function planeEquation(normal: Point3, point: Point3 | vec3): Plane;

// @public (undocumented)
type Point2 = [number, number];

// @public (undocumented)
type Point3 = [number, number, number];

// @public (undocumented)
type Point4 = [number, number, number, number];

// @public (undocumented)
type PreStackNewImageEvent = CustomEvent_2<PreStackNewImageEventDetail>;

// @public (undocumented)
type PreStackNewImageEventDetail = {
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type PTScaling = {
    suvbwToSuvlbm?: number;
    suvbwToSuvbsa?: number;
};

// @public (undocumented)
type PublicViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions?: ViewportInputOptions;
};

// @public (undocumented)
export function registerImageLoader(scheme: string, imageLoader: ImageLoaderFn): void;

// @public (undocumented)
function registerUnknownImageLoader(imageLoader: ImageLoaderFn): ImageLoaderFn;

// @public (undocumented)
function registerUnknownVolumeLoader(volumeLoader: Types.VolumeLoaderFn): Types.VolumeLoaderFn | undefined;

// @public (undocumented)
function registerVolumeLoader(scheme: string, volumeLoader: Types.VolumeLoaderFn): void;

// @public (undocumented)
function removeAllProviders(): void;

// @public (undocumented)
function removeProvider(provider: (type: string, imageId: string) => {
    any: any;
}): void;

// @public (undocumented)
const RENDERING_DEFAULTS: {
    MINIMUM_SLAB_THICKNESS: number;
    MAXIMUM_RAY_DISTANCE: number;
};

// @public (undocumented)
export class RenderingEngine implements IRenderingEngine {
    constructor(id?: string);
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    _downloadOffScreenCanvas(): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(canvas: HTMLCanvasElement, backgroundColor: [number, number, number]): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getViewport(viewportId: string): IStackViewport | IVolumeViewport;
    // (undocumented)
    getViewports(): Array<IStackViewport | IVolumeViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference: (FrameOfReferenceUID: string) => void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, resetPan?: boolean, resetZoom?: boolean): void;
    // (undocumented)
    setViewports(publicViewportInputEntries: Array<PublicViewportInput>): void;
}

// @public (undocumented)
function renderToCanvas(canvas: HTMLCanvasElement, image: IImage, modality?: string): void;

// @public (undocumented)
enum RequestType {
    // (undocumented)
    Interaction = "interaction",
    // (undocumented)
    Prefetch = "prefetch",
    // (undocumented)
    Thumbnail = "thumbnail"
}

// @public (undocumented)
export function resetUseCPURendering(): void;

// @public (undocumented)
function scaleRGBTransferFunction(rgbTransferFunction: any, scalingFactor: number): void;

// @public (undocumented)
type Scaling = {
    PET?: PTScaling;
};

// @public (undocumented)
type ScalingParameters = {
    rescaleSlope: number;
    rescaleIntercept: number;
    modality: string;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
export function setMaxSimultaneousRequests(newMaxSimultaneousRequests: any): void;

// @public (undocumented)
export class Settings {
    constructor(base?: Settings);
    // (undocumented)
    static assert(subject: Settings): Settings;
    // (undocumented)
    dump(): Record<string, unknown>;
    // (undocumented)
    extend(): Settings;
    // (undocumented)
    static extendRuntimeSettings(): Settings;
    // (undocumented)
    forEach(callback: (key: string, value: unknown) => void): void;
    // (undocumented)
    get(key: string): unknown;
    // (undocumented)
    static getDefaultSettings(subfield?: any): Settings | any;
    // (undocumented)
    static getObjectSettings(subject: unknown, from?: unknown): Settings;
    // (undocumented)
    static getRuntimeSettings(): Settings;
    // (undocumented)
    import(root: Record<string, unknown>): void;
    // (undocumented)
    set(key: string, value: unknown): boolean;
    // (undocumented)
    unset(key: string): boolean;
}

// @public (undocumented)
export function setUseCPURendering(status: boolean): void;

// @public (undocumented)
export function setVolumesForViewports(renderingEngine: IRenderingEngine, volumeInputs: Array<IVolumeInput>, viewportIds: Array<string>, immediateRender?: boolean, suppressEvents?: boolean): Promise<void>;

// @public (undocumented)
function snapFocalPointToSlice(focalPoint: Point3, position: Point3, sliceRange: ActorSliceRange, viewPlaneNormal: Point3, spacingInNormalDirection: number, deltaFrames: number): {
    newFocalPoint: Point3;
    newPosition: Point3;
};

// @public (undocumented)
type StackNewImageEvent = CustomEvent_2<StackNewImageEventDetail>;

// @public (undocumented)
type StackNewImageEventDetail = {
    image: IImage;
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
export class StackViewport extends Viewport implements IStackViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addActor(actorEntry: ActorEntry): void;
    // (undocumented)
    addActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    calibrateSpacing(imageId: string): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getActor(actorUID: string): ActorEntry;
    // (undocumented)
    getActors(): Array<ActorEntry>;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getDefaultActor(): ActorEntry;
    // (undocumented)
    getFrameOfReferenceUID: () => string | undefined;
    // (undocumented)
    getImageData(): IImageData | CPUIImageData;
    // (undocumented)
    getImageIds: () => Array<string>;
    // (undocumented)
    getProperties: () => StackViewportProperties;
    // (undocumented)
    getRenderer(): any;
    // (undocumented)
    getTargetImageIdIndex: () => number;
    // (undocumented)
    hasImageId: (imageId: string) => boolean;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    isImagePreScaled(imageId: string): boolean;
    // (undocumented)
    modality: string;
    // (undocumented)
    removeAllActors(): void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scaling: Scaling;
    // (undocumented)
    scroll(delta: number, debounce?: boolean, loop?: boolean): void;
    // (undocumented)
    setActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera): void;
    // (undocumented)
    setColormap(colormap: CPUFallbackColormapData): void;
    // (undocumented)
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    // (undocumented)
    setProperties({ voiRange, invert, interpolationType, rotation, }?: StackViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    setStack(imageIds: Array<string>, currentImageIdIndex?: number): Promise<string>;
    // (undocumented)
    unsetColormap(): void;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
type StackViewportNewStackEvent = CustomEvent_2<StackViewportNewStackEventDetail>;

// @public (undocumented)
type StackViewportNewStackEventDetail = {
    imageIds: string[];
    viewportId: string;
    element: HTMLDivElement;
    currentImageIdIndex: number;
};

// @public (undocumented)
type StackViewportProperties = {
    voiRange?: VOIRange;
    invert?: boolean;
    interpolationType?: InterpolationType;
    rotation?: number;
    suppressEvents?: boolean;
};

// @public (undocumented)
type StackViewportScrollEvent = CustomEvent_2<StackViewportScrollEventDetail>;

// @public (undocumented)
type StackViewportScrollEventDetail = {
    newImageIdIndex: number;
    imageId: string;
    direction: number;
};

// @public (undocumented)
function threePlaneIntersection(firstPlane: Plane, secondPlane: Plane, thirdPlane: Plane): Point3;

// @public (undocumented)
function toLowHighRange(windowWidth: number, windowCenter: number): {
    lower: number;
    upper: number;
};

// @public (undocumented)
function toWindowLevel(low: number, high: number): {
    windowWidth: number;
    windowCenter: number;
};

// @public (undocumented)
type TransformMatrix2D = [number, number, number, number, number, number];

// @public (undocumented)
function transformWorldToIndex(imageData: any, worldPos: Point3): any;

// @public (undocumented)
export function triggerEvent(el: EventTarget, type: string, detail?: unknown): boolean;

declare namespace Types {
    export {
        ICamera,
        IStackViewport,
        IVolumeViewport,
        IEnabledElement,
        ICache,
        IVolume,
        IViewportId,
        IImageVolume,
        IRenderingEngine,
        ScalingParameters,
        PTScaling,
        Scaling,
        IStreamingImageVolume,
        IImage,
        IImageData,
        CPUIImageData,
        CPUImageData,
        EventTypes,
        ImageLoaderFn,
        VolumeLoaderFn,
        IRegisterImageLoader,
        IStreamingVolumeProperties,
        IViewport,
        StackViewportProperties,
        VolumeViewportProperties,
        PublicViewportInput,
        VolumeActor,
        Actor,
        ActorEntry,
        IImageLoadObject,
        IVolumeLoadObject,
        IVolumeInput,
        VolumeInputCallback,
        Metadata,
        Orientation,
        Point2,
        Point3,
        Point4,
        Plane,
        ViewportInputOptions,
        VOIRange,
        VOI,
        FlipDirection,
        ICachedImage,
        ICachedVolume,
        CPUFallbackEnabledElement,
        CPUFallbackViewport,
        CPUFallbackTransform,
        CPUFallbackColormapData,
        CPUFallbackViewportDisplayedArea,
        CPUFallbackColormapsData,
        CPUFallbackColormap,
        TransformMatrix2D,
        CPUFallbackLookupTable,
        CPUFallbackLUT,
        CPUFallbackRenderingTools,
        CustomEvent_2 as CustomEventType,
        ActorSliceRange,
        ImageSliceData
    }
}
export { Types }

// @public (undocumented)
function unregisterAllImageLoaders(): void;

declare namespace utilities {
    export {
        invertRgbTransferFunction,
        scaleRGBTransferFunction as scaleRgbTransferFunction,
        triggerEvent,
        imageIdToURI,
        metadataProvider as calibratedPixelSpacingMetadataProvider,
        uuidv4,
        planar,
        getMinMax,
        getRuntimeId,
        isEqual,
        isOpposite,
        createFloat32SharedArray,
        createUint8SharedArray,
        windowLevel,
        getClosestImageId,
        getSpacingInNormalDirection,
        getTargetVolumeAndSpacingInNormalDir,
        getVolumeActorCorners,
        indexWithinDimensions,
        getVolumeViewportsContainingSameVolumes,
        getVolumeViewportsContainingVolumeId,
        transformWorldToIndex,
        loadImageToCanvas,
        renderToCanvas,
        worldToImageCoords,
        imageToWorldCoords,
        getSliceRange,
        snapFocalPointToSlice,
        getImageSliceDataForVolumeViewport,
        getScalingParameters,
        isImageActor
    }
}
export { utilities }

// @public (undocumented)
function uuidv4(): string;

// @public (undocumented)
export class Viewport implements IViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    _actors: Map<string, any>;
    // (undocumented)
    addActor(actorEntry: ActorEntry): void;
    // (undocumented)
    addActors(actors: Array<ActorEntry>, resetCameraPanAndZoom?: boolean): void;
    // (undocumented)
    protected applyFlipTx: (worldPos: Point3) => Point3;
    // (undocumented)
    readonly canvas: HTMLCanvasElement;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => unknown;
    // (undocumented)
    readonly defaultOptions: any;
    // (undocumented)
    readonly element: HTMLDivElement;
    // (undocumented)
    protected flip({ flipHorizontal, flipVertical }: FlipDirection): void;
    // (undocumented)
    protected flipHorizontal: boolean;
    // (undocumented)
    protected flipVertical: boolean;
    // (undocumented)
    getActor(actorUID: string): ActorEntry;
    // (undocumented)
    getActorByIndex(index: number): ActorEntry;
    // (undocumented)
    getActors(): Array<ActorEntry>;
    // (undocumented)
    getActorUIDByIndex(index: number): string;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    // (undocumented)
    getDefaultActor(): ActorEntry;
    // (undocumented)
    _getEdges(bounds: Array<number>): Array<[number[], number[]]>;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getProperties: () => void;
    // (undocumented)
    getRenderer(): any;
    // (undocumented)
    getRenderingEngine(): IRenderingEngine;
    // (undocumented)
    protected getVtkActiveCamera(): vtkCamera | vtkSlabCamera;
    // (undocumented)
    protected hasPixelSpacing: boolean;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    _isInBounds(point: Point3, bounds: number[]): boolean;
    // (undocumented)
    options: ViewportInputOptions;
    // (undocumented)
    removeActor(actorUID: string): void;
    // (undocumented)
    removeActors(actorUIDs: Array<string>): void;
    // (undocumented)
    removeAllActors(): void;
    // (undocumented)
    render(): void;
    // (undocumented)
    readonly renderingEngineId: string;
    // (undocumented)
    reset(immediate?: boolean): void;
    // (undocumented)
    protected resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    // (undocumented)
    protected resetCameraNoEvent(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    protected rotation: number;
    // (undocumented)
    setActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera): void;
    // (undocumented)
    protected setCameraNoEvent(camera: ICamera): void;
    // (undocumented)
    setOptions(options: ViewportInputOptions, immediate?: boolean): void;
    // (undocumented)
    setOrientationOfClippingPlanes(vtkPlanes: Array<vtkPlane>, slabThickness: number, viewPlaneNormal: Point3, focalPoint: Point3): void;
    // (undocumented)
    sHeight: number;
    // (undocumented)
    readonly suppressEvents: boolean;
    // (undocumented)
    sWidth: number;
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    triggerCameraModifiedEventIfNecessary(previousCamera: ICamera, updatedCamera: ICamera): void;
    // (undocumented)
    readonly type: ViewportType;
    // (undocumented)
    protected updateClippingPlanesForActors(updatedCamera: ICamera): void;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
type ViewportInputOptions = {
    background?: [number, number, number];
    orientation?: Orientation;
    suppressEvents?: boolean;
};

// @public (undocumented)
enum ViewportType {
    // (undocumented)
    ORTHOGRAPHIC = "orthographic",
    // (undocumented)
    PERSPECTIVE = "perspective",
    // (undocumented)
    STACK = "stack"
}

// @public (undocumented)
type VOI = {
    windowWidth: number;
    windowCenter: number;
};

// @public (undocumented)
type VoiModifiedEvent = CustomEvent_2<VoiModifiedEventDetail>;

// @public (undocumented)
type VoiModifiedEventDetail = {
    viewportId: string;
    range: VOIRange;
    volumeId?: string;
};

// @public (undocumented)
type VOIRange = {
    upper: number;
    lower: number;
};

// @public (undocumented)
type VolumeActor = vtkVolume;

// @public (undocumented)
type VolumeCacheVolumeAddedEvent = CustomEvent_2<VolumeCacheVolumeAddedEventDetail>;

// @public (undocumented)
type VolumeCacheVolumeAddedEventDetail = {
    volume: ICachedVolume;
};

// @public (undocumented)
type VolumeCacheVolumeRemovedEvent = CustomEvent_2<VolumeCacheVolumeRemovedEventDetail>;

// @public (undocumented)
type VolumeCacheVolumeRemovedEventDetail = {
    volumeId: string;
};

// @public (undocumented)
type VolumeInputCallback = (params: {
    volumeActor: VolumeActor;
    volumeId: string;
}) => unknown;

// @public (undocumented)
type VolumeLoadedEvent = CustomEvent_2<VolumeLoadedEventDetail>;

// @public (undocumented)
type VolumeLoadedEventDetail = {
    volume: IImageVolume;
};

// @public (undocumented)
type VolumeLoadedFailedEvent = CustomEvent_2<VolumeLoadedFailedEventDetail>;

// @public (undocumented)
type VolumeLoadedFailedEventDetail = {
    volumeId: string;
    error: unknown;
};

declare namespace volumeLoader {
    export {
        loadVolume,
        createAndCacheVolume,
        createAndCacheDerivedVolume,
        createLocalVolume,
        registerVolumeLoader,
        registerUnknownVolumeLoader
    }
}
export { volumeLoader }

// @public (undocumented)
type VolumeLoaderFn = (volumeId: string, options?: Record<string, any>) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
type VolumeNewImageEvent = CustomEvent_2<VolumeNewImageEventDetail>;

// @public (undocumented)
type VolumeNewImageEventDetail = {
    imageIndex: number;
    numberOfSlices: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
export class VolumeViewport extends Viewport implements IVolumeViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    flip(flipDirection: FlipDirection): void;
    // (undocumented)
    getBounds(): number[];
    // (undocumented)
    getCurrentImageId: () => string | undefined;
    // (undocumented)
    getCurrentImageIdIndex: () => number | undefined;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(): IImageData | undefined;
    // (undocumented)
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    getSlabThickness(): number;
    // (undocumented)
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: any[], immediate?: boolean): void;
    // (undocumented)
    setProperties({ voiRange }?: VolumeViewportProperties, volumeId?: string, suppressEvents?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: any[]): void;
    // (undocumented)
    setVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
type VolumeViewportProperties = {
    voiRange?: VOIRange;
};

declare namespace windowLevel {
    export {
        toWindowLevel,
        toLowHighRange
    }
}

// @public (undocumented)
function worldToImageCoords(imageId: string, worldCoords: Point3): Point2 | undefined;

// (No @packageDocumentation comment for this package)

```

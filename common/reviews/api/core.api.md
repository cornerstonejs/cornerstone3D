## API Report File for "@cornerstonejs/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type ColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';
import type { mat3 } from 'gl-matrix';
import { mat4 } from 'gl-matrix';
import type { Range as Range_2 } from '@kitware/vtk.js/types';
import { vec3 } from 'gl-matrix';
import type vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';
import type { vtkCamera } from '@kitware/vtk.js/Rendering/Core/Camera';
import { vtkColorTransferFunction } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';
import { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';
import type vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import type { vtkObject } from '@kitware/vtk.js/interfaces';
import type vtkOpenGLTexture from '@kitware/vtk.js/Rendering/OpenGL/Texture';
import vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';
import type vtkRenderer from '@kitware/vtk.js/Rendering/Core/Renderer';
import type vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';
import vtkVolumeMapper from '@kitware/vtk.js/Rendering/Core/VolumeMapper';

// @public (undocumented)
interface AABB2 {
    // (undocumented)
    maxX: number;
    // (undocumented)
    maxY: number;
    // (undocumented)
    minX: number;
    // (undocumented)
    minY: number;
}

// @public (undocumented)
interface AABB3 {
    // (undocumented)
    maxX: number;
    // (undocumented)
    maxY: number;
    // (undocumented)
    maxZ: number;
    // (undocumented)
    minX: number;
    // (undocumented)
    minY: number;
    // (undocumented)
    minZ: number;
}

// @public (undocumented)
type Actor = vtkActor;

// @public (undocumented)
interface ActorEntry {
    // (undocumented)
    [key: string]: unknown;
    // (undocumented)
    actor: Actor | VolumeActor | ImageActor | ICanvasActor;
    // (undocumented)
    blendMode?: BlendModes;
    // (undocumented)
    callbacks?: ({ volumeActor, volumeId, }: {
        volumeActor: VolumeActor;
        volumeId: string;
    }) => void;
    // (undocumented)
    clippingFilter?: any;
    // (undocumented)
    referencedId?: string;
    // (undocumented)
    slabThickness?: number;
    // (undocumented)
    uid: string;
}

// @public (undocumented)
function actorIsA(actorEntry: Types.ActorEntry | Types.Actor, actorType: actorTypes): boolean;

// @public (undocumented)
interface ActorSliceRange {
    // (undocumented)
    actor: VolumeActor;
    // (undocumented)
    current: number;
    // (undocumented)
    focalPoint: Point3;
    // (undocumented)
    max: number;
    // (undocumented)
    min: number;
    // (undocumented)
    viewPlaneNormal: Point3;
}

// @public (undocumented)
export function addImageSlicesToViewports(renderingEngine: IRenderingEngine, stackInputs: IStackInput[], viewportIds: string[]): Promise<void>;

// @public (undocumented)
function addProvider(provider: (type: string, ...query: string[]) => unknown, priority?: number): void;

// @public (undocumented)
export function addVolumesToViewports(renderingEngine: IRenderingEngine, volumeInputs: IVolumeInput[], viewportIds: string[], immediateRender?: boolean, suppressEvents?: boolean): Promise<void>;

// @public (undocumented)
type AffineMatrix = [
[
number,
number,
number,
number
],
[
number,
number,
number,
number
],
[
number,
number,
number,
number
],
[
number,
number,
number,
number
]
];

// @public (undocumented)
function applyPreset(actor: VolumeActor, preset: ViewportPreset): void;

// @public (undocumented)
const autoLoad: (volumeId: string) => void;

// @public (undocumented)
const backgroundColors: {
    slicer3D: number[];
};

// @public (undocumented)
export abstract class BaseVolumeViewport extends Viewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addVolumes(volumeInputArray: IVolumeInput[], immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    protected applyViewOrientation(orientation: OrientationAxis | OrientationVectors, resetCamera?: boolean): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    clearDefaultProperties(volumeId?: string): void;
    // (undocumented)
    flip(flipDirection: FlipDirection): void;
    // (undocumented)
    getAllVolumeIds(): string[];
    // (undocumented)
    getBounds(): number[];
    // (undocumented)
    abstract getCurrentImageId(): string | undefined;
    // (undocumented)
    getDefaultProperties: (volumeId?: string) => VolumeViewportProperties;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(volumeId?: string): IImageData | undefined;
    // (undocumented)
    getImageIds: (volumeId?: string) => string[];
    // (undocumented)
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    protected _getOrientationVectors(orientation: OrientationAxis | OrientationVectors): OrientationVectors;
    // (undocumented)
    getProperties: (volumeId?: string) => VolumeViewportProperties;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getSlabThickness(): number;
    // (undocumented)
    getSliceIndex(): number;
    // (undocumented)
    getSliceViewInfo(): {
        width: number;
        height: number;
        sliceIndex: number;
        slicePlane: number;
        sliceToIndexMatrix: mat4;
        indexToSliceMatrix: mat4;
    };
    // (undocumented)
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    // (undocumented)
    getViewReferenceId(specifier?: ViewReferenceSpecifier): string;
    // (undocumented)
    protected getVOIModifiedEventDetail(volumeId: string): VoiModifiedEventDetail;
    // (undocumented)
    getVolumeId(specifier?: ViewReferenceSpecifier): string;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    hasVolumeId(volumeId: string): boolean;
    // (undocumented)
    hasVolumeURI(volumeURI: string): boolean;
    // (undocumented)
    protected initialTransferFunctionNodes: TransferFunctionNodes;
    // (undocumented)
    protected initialViewUp: Point3;
    // (undocumented)
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    // (undocumented)
    removeVolumeActors(actorUIDs: string[], immediate?: boolean): void;
    // (undocumented)
    abstract resetProperties(volumeId?: string): void;
    // (undocumented)
    abstract resetSlabThickness(): void;
    // (undocumented)
    resetToDefaultProperties(volumeId: string): void;
    // (undocumented)
    scroll(delta?: number): void;
    // (undocumented)
    abstract setBlendMode(blendMode: BlendModes, filterActorUIDs?: string[], immediate?: boolean): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    protected setCameraClippingRange(): void;
    // (undocumented)
    setDefaultProperties(ViewportProperties: VolumeViewportProperties, volumeId?: string): void;
    // (undocumented)
    protected setInterpolationType(interpolationType: InterpolationType, volumeId?: string): void;
    // (undocumented)
    setOrientation(_orientation: OrientationAxis | OrientationVectors, _immediate?: boolean): void;
    // (undocumented)
    setProperties({ voiRange, VOILUTFunction, invert, colormap, preset, interpolationType, slabThickness, }?: VolumeViewportProperties, volumeId?: string, suppressEvents?: boolean): void;
    // (undocumented)
    protected setRotation: (rotation: number) => void;
    // (undocumented)
    abstract setSlabThickness(slabThickness: number, filterActorUIDs?: string[]): void;
    // (undocumented)
    setViewReference(viewRef: ViewReference): void;
    // (undocumented)
    setVolumes(volumeInputArray: IVolumeInput[], immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    protected viewportProperties: VolumeViewportProperties;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
enum BlendModes {
    // (undocumented)
    AVERAGE_INTENSITY_BLEND,
    // (undocumented)
    COMPOSITE,
    // (undocumented)
    LABELMAP_EDGE_PROJECTION_BLEND,
    // (undocumented)
    MAXIMUM_INTENSITY_BLEND,
    // (undocumented)
    MINIMUM_INTENSITY_BLEND
}

// @public (undocumented)
type BoundsIJK = [Point2, Point2, Point2];

// @public (undocumented)
type BoundsLPS = [Point3, Point3, Point3];

// @public (undocumented)
export const cache: Cache_2;

// @public (undocumented)
function calculateViewportsSpatialRegistration(viewport1: StackViewport | IVolumeViewport, viewport2: StackViewport | IVolumeViewport): void;

// @public (undocumented)
enum CalibrationTypes {
    // (undocumented)
    ERMF = "ERMF",
    // (undocumented)
    ERROR = "Error",
    // (undocumented)
    NOT_APPLICABLE = "",
    // (undocumented)
    PROJECTION = "Proj",
    // (undocumented)
    REGION = "Region",
    // (undocumented)
    UNCALIBRATED = "Uncalibrated",
    // (undocumented)
    USER = "User"
}

// @public (undocumented)
type CameraModifiedEvent = CustomEvent_2<CameraModifiedEventDetail>;

// @public (undocumented)
interface CameraModifiedEventDetail {
    // (undocumented)
    camera: ICamera;
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    previousCamera: ICamera;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
type CameraResetEvent = CustomEvent_2<CameraResetEventDetail>;

// @public (undocumented)
interface CameraResetEventDetail {
    // (undocumented)
    camera: ICamera;
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
function cancelLoadAll(): void;

// @public (undocumented)
function cancelLoadImage(imageId: string): void;

// @public (undocumented)
function cancelLoadImages(imageIds: string[]): void;

// @public (undocumented)
export function canRenderFloatTextures(): boolean;

// @public (undocumented)
function clamp(value: number, min: number, max: number): number;

// @public (undocumented)
function clip(val: number, low: number, high: number): number;

// @public (undocumented)
type Color = [number, number, number, number];

declare namespace color {
    export {
        hexToRgb,
        rgbToHex
    }
}

// @public (undocumented)
type ColorLUT = Color[];

declare namespace colormap {
    export {
        getColormap,
        getColormapNames,
        registerColormap,
        findMatchingColormap
    }
}

// @public (undocumented)
type ColormapModifiedEvent = CustomEvent_2<ColormapModifiedEventDetail>;

// @public (undocumented)
interface ColormapModifiedEventDetail {
    // (undocumented)
    colormap: ColormapPublic;
    // (undocumented)
    viewportId: string;
    // (undocumented)
    volumeId?: string;
}

// @public (undocumented)
interface ColormapPublic {
    // (undocumented)
    name?: string;
    // (undocumented)
    opacity?: OpacityMapping[] | number;
}

// @public (undocumented)
interface ColormapRegistration {
    // (undocumented)
    ColorSpace: string;
    // (undocumented)
    Name: string;
    // (undocumented)
    RGBPoints: RGB[] | number[];
}

// @public (undocumented)
const colormapsData: CPUFallbackColormapsData;

declare namespace CONSTANTS {
    export {
        colormapsData as CPU_COLORMAPS,
        RENDERING_DEFAULTS,
        mprCameraValues as MPR_CAMERA_VALUES,
        EPSILON,
        presets as VIEWPORT_PRESETS,
        backgroundColors as BACKGROUND_COLORS
    }
}
export { CONSTANTS }

// @public (undocumented)
interface ContourData {
    // (undocumented)
    color: Point3;
    // (undocumented)
    points: Point3[];
    // (undocumented)
    segmentIndex: number;
    // (undocumented)
    type: ContourType;
}

// @public (undocumented)
interface ContourSetData {
    // (undocumented)
    color?: Point3;
    // (undocumented)
    data: ContourData[];
    // (undocumented)
    frameOfReferenceUID: string;
    // (undocumented)
    id: string;
    // (undocumented)
    segmentIndex?: number;
}

// @public (undocumented)
enum ContourType {
    // (undocumented)
    CLOSED_PLANAR = "CLOSED_PLANAR",
    // (undocumented)
    OPEN_PLANAR = "OPEN_PLANAR"
}

// @public (undocumented)
export function convertMapperToNotSharedMapper(sharedMapper: vtkVolumeMapper): vtkVolumeMapper;

// @public (undocumented)
function convertStackToVolumeViewport({ viewport, options, }: {
    viewport: StackViewport;
    options?: {
        volumeId?: string;
        viewportId?: string;
        background?: Point3;
        orientation?: OrientationAxis;
    };
}): Promise<IVolumeViewport>;

// @public (undocumented)
function convertToGrayscale(scalarData: any, width: number, height: number): any;

// @public (undocumented)
function convertVolumeToStackViewport({ viewport, options, }: {
    viewport: Types.IVolumeViewport;
    options: {
        viewportId?: string;
        background?: Types.Point3;
    };
}): Promise<Types.IStackViewport>;

// @public (undocumented)
interface Cornerstone3DConfig {
    // (undocumented)
    gpuTier: {
        tier: number;
    };
    // (undocumented)
    isMobile: boolean;
    // (undocumented)
    peerImport?: (moduleId: string) => any;
    // (undocumented)
    rendering: {
        preferSizeOverAccuracy: boolean;
        useCPURendering: boolean;
        strictZSpacingForVolumeViewport: boolean;
    };
}

// @public (undocumented)
export function cornerstoneStreamingDynamicImageVolumeLoader(volumeId: string, options: {
    imageIds: string[];
}): IVolumeLoader_2;

// @public (undocumented)
export function cornerstoneStreamingImageVolumeLoader(volumeId: string, options: {
    imageIds: string[];
    progressiveRendering?: boolean | IRetrieveConfiguration;
}): IVolumeLoader;

// @public (undocumented)
interface CPUFallbackColormap {
    // (undocumented)
    addColor: (rgba: Point4) => void;
    // (undocumented)
    buildLookupTable: (lut: CPUFallbackLookupTable) => void;
    // (undocumented)
    clearColors: () => void;
    // (undocumented)
    createLookupTable: () => CPUFallbackLookupTable;
    // (undocumented)
    getColor: (index: number) => Point4;
    // (undocumented)
    getColorRepeating: (index: number) => Point4;
    // (undocumented)
    getColorSchemeName: () => string;
    // (undocumented)
    getId: () => string;
    // (undocumented)
    getNumberOfColors: () => number;
    // (undocumented)
    insertColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    isValidIndex: (index: number) => boolean;
    // (undocumented)
    removeColor: (index: number) => void;
    // (undocumented)
    setColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    setColorSchemeName: (name: string) => void;
    // (undocumented)
    setNumberOfColors: (numColors: number) => void;
}

// @public (undocumented)
interface CPUFallbackColormapData {
    // (undocumented)
    colors?: Point4[];
    // (undocumented)
    gamma?: number;
    // (undocumented)
    name: string;
    // (undocumented)
    numColors?: number;
    // (undocumented)
    numOfColors?: number;
    // (undocumented)
    segmentedData?: unknown;
}

// @public (undocumented)
type CPUFallbackColormapsData = Record<string, CPUFallbackColormapData>;

// @public (undocumented)
interface CPUFallbackEnabledElement {
    // (undocumented)
    canvas?: HTMLCanvasElement;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    image?: IImage;
    // (undocumented)
    invalid?: boolean;
    // (undocumented)
    metadata?: {
        direction?: Mat3;
        dimensions?: Point3;
        spacing?: Point3;
        origin?: Point3;
        imagePlaneModule?: ImagePlaneModule;
        imagePixelModule?: ImagePixelModule;
    };
    // (undocumented)
    needsRedraw?: boolean;
    // (undocumented)
    options?: {
        [key: string]: unknown;
        colormap?: CPUFallbackColormap;
    };
    // (undocumented)
    pan?: Point2;
    // (undocumented)
    renderingTools?: CPUFallbackRenderingTools;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    transform?: CPUFallbackTransform;
    // (undocumented)
    viewport?: CPUFallbackViewport;
    // (undocumented)
    voxelManager?: IVoxelManager<number> | IVoxelManager<RGB>;
    // (undocumented)
    zoom?: number;
}

// @public (undocumented)
interface CPUFallbackLookupTable {
    // (undocumented)
    build: (force: boolean) => void;
    // (undocumented)
    getColor: (scalar: number) => Point4;
    // (undocumented)
    setAlphaRange: (start: number, end: number) => void;
    // (undocumented)
    setHueRange: (start: number, end: number) => void;
    // (undocumented)
    setNumberOfTableValues: (number: number) => void;
    // (undocumented)
    setRamp: (ramp: string) => void;
    // (undocumented)
    setRange: (start: number, end: number) => void;
    // (undocumented)
    setSaturationRange: (start: number, end: number) => void;
    // (undocumented)
    setTableRange: (start: number, end: number) => void;
    // (undocumented)
    setTableValue(index: number, rgba: Point4): any;
    // (undocumented)
    setValueRange: (start: number, end: number) => void;
}

// @public (undocumented)
interface CPUFallbackLUT {
    // (undocumented)
    id?: string;
    // (undocumented)
    lut: number[];
}

// @public (undocumented)
interface CPUFallbackRenderingTools {
    // (undocumented)
    colorLUT?: CPUFallbackLookupTable;
    // (undocumented)
    colormapId?: string;
    // (undocumented)
    lastRenderedImageId?: string;
    // (undocumented)
    lastRenderedIsColor?: boolean;
    // (undocumented)
    lastRenderedViewport?: {
        windowWidth: number | number[];
        windowCenter: number | number[];
        invert: boolean;
        rotation: number;
        hflip: boolean;
        vflip: boolean;
        modalityLUT: CPUFallbackLUT;
        voiLUT: CPUFallbackLUT;
        colormap: unknown;
    };
    // (undocumented)
    renderCanvas?: HTMLCanvasElement;
    // (undocumented)
    renderCanvasContext?: CanvasRenderingContext2D;
    // (undocumented)
    renderCanvasData?: ImageData;
}

// @public (undocumented)
interface CPUFallbackTransform {
    // (undocumented)
    clone: () => CPUFallbackTransform;
    // (undocumented)
    getMatrix: () => TransformMatrix2D;
    // (undocumented)
    invert: () => void;
    // (undocumented)
    multiply: (matrix: TransformMatrix2D) => void;
    // (undocumented)
    reset: () => void;
    // (undocumented)
    rotate: (rad: number) => void;
    // (undocumented)
    scale: (sx: number, sy: number) => void;
    // (undocumented)
    transformPoint: (point: Point2) => Point2;
    // (undocumented)
    translate: (x: number, y: number) => void;
}

// @public (undocumented)
interface CPUFallbackViewport {
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    displayedArea?: CPUFallbackViewportDisplayedArea;
    // (undocumented)
    focalPoint?: number[];
    // (undocumented)
    hflip?: boolean;
    // (undocumented)
    invert?: boolean;
    // (undocumented)
    modality?: string;
    // (undocumented)
    modalityLUT?: CPUFallbackLUT;
    // (undocumented)
    parallelScale?: number;
    // (undocumented)
    pixelReplication?: boolean;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    translation?: {
        x: number;
        y: number;
    };
    // (undocumented)
    vflip?: boolean;
    // (undocumented)
    voi?: {
        windowWidth: number;
        windowCenter: number;
        voiLUTFunction: VOILUTFunctionType;
    };
    // (undocumented)
    voiLUT?: CPUFallbackLUT;
}

// @public (undocumented)
interface CPUFallbackViewportDisplayedArea {
    // (undocumented)
    brhc: {
        x: number;
        y: number;
    };
    // (undocumented)
    columnPixelSpacing: number;
    // (undocumented)
    presentationSizeMode: string;
    // (undocumented)
    rowPixelSpacing: number;
    // (undocumented)
    tlhc: {
        x: number;
        y: number;
    };
}

// @public (undocumented)
interface CPUIImageData {
    // (undocumented)
    calibration?: IImageCalibration;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    hasPixelSpacing?: boolean;
    // (undocumented)
    imageData: CPUImageData;
    // (undocumented)
    metadata: {
        Modality: string;
        FrameOfReferenceUID: string;
    };
    // (undocumented)
    numberOfComponents?: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    // (undocumented)
    scalarData: PixelDataTypedArray;
    // (undocumented)
    scaling?: Scaling;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    voxelManager?: IVoxelManager<number> | IVoxelManager<RGB>;
}

// @public (undocumented)
interface CPUImageData {
    // (undocumented)
    getDimensions?: () => Point3;
    // (undocumented)
    getDirection?: () => Mat3;
    // (undocumented)
    getIndexToWorld?: () => Point3;
    // (undocumented)
    getRange?: () => [number, number];
    // (undocumented)
    getScalarData?: () => PixelDataTypedArray;
    // (undocumented)
    getSpacing?: () => Point3;
    // (undocumented)
    getWorldToIndex?: () => Point3;
    // (undocumented)
    indexToWorld?: (point: Point3) => Point3;
    // (undocumented)
    worldToIndex?: (point: Point3) => Point3;
}

// @public (undocumented)
function createAndCacheDerivedImage(referencedImageId: string, options?: DerivedImageOptions): IImage;

// @public (undocumented)
function createAndCacheDerivedImages(referencedImageIds: string[], options?: DerivedImageOptions & {
    getDerivedImageId?: (referencedImageId: string) => string;
    targetBuffer?: {
        type: PixelDataTypedArrayString;
    };
    voxelRepresentation?: VoxelManagerEnum;
}): IImage[];

// @public (undocumented)
function createAndCacheDerivedLabelmapImage(referencedImageId: string, options?: DerivedImageOptions): IImage;

// @public (undocumented)
function createAndCacheDerivedLabelmapImages(referencedImageIds: string[], options?: DerivedImageOptions): IImage[];

// @public (undocumented)
function createAndCacheDerivedLabelmapVolume(referencedVolumeId: string, options?: DerivedVolumeOptions): IImageVolume;

// @public (undocumented)
function createAndCacheDerivedVolume(referencedVolumeId: string, options: DerivedVolumeOptions): IImageVolume;

// @public (undocumented)
function createAndCacheGeometry(geometryId: string, options: GeometryOptions): IGeometry;

// @public (undocumented)
function createAndCacheLocalImage(imageId: string, options: LocalImageOptions): IImage;

// @public (undocumented)
function createAndCacheVolume(volumeId: string, options?: VolumeLoaderOptions): Promise<IImageVolume | IStreamingImageVolume>;

// @public (undocumented)
function createAndCacheVolumeFromImages(volumeId: string, imageIds: string[]): Promise<IImageVolume>;

// @public (undocumented)
function createAndCacheVolumeFromImagesSync(volumeId: string, imageIds: string[]): IImageVolume;

// @public (undocumented)
function createLinearRGBTransferFunction(voiRange: VOIRange): vtkColorTransferFunction;

// @public (undocumented)
function createLocalLabelmapVolume(options: LocalVolumeOptions, volumeId: string, preventCache?: boolean): IImageVolume;

// @public (undocumented)
function createLocalVolume(volumeId: string, options?: LocalVolumeOptions): IImageVolume;

// @public (undocumented)
function createSigmoidRGBTransferFunction(voiRange: VOIRange, approximationNodes?: number): vtkColorTransferFunction;

// @public (undocumented)
function createSubVolume(referencedVolumeId: string, boundsIJK: AABB3, options?: {
    targetBuffer?: {
        type: PixelDataTypedArrayString;
    };
}): ImageVolume;

// @public (undocumented)
export function createVolumeActor(props: createVolumeActorInterface, element: HTMLDivElement, viewportId: string, suppressEvents?: boolean): Promise<VolumeActor>;

// @public (undocumented)
export function createVolumeMapper(imageData: vtkImageData, vtkOpenGLTexture: vtkOpenGLTexture): vtkVolumeMapper;

// @public (undocumented)
interface CustomEvent_2<T = unknown> extends Event {
    // (undocumented)
    readonly detail: T;
    // (undocumented)
    initCustomEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, detailArg: T): void;
}

// @public (undocumented)
type DataSetOptions = {
    groupId?: string;
    viewSelector?: ViewPresentationSelector;
    viewReference?: ViewReferenceSpecifier;
};

// @public (undocumented)
function decimate(list: unknown[], interleave: number, offset?: number): number[];

// @public (undocumented)
function deepClone(obj: unknown): unknown;

// @public (undocumented)
function deepEqual(obj1: unknown, obj2: unknown): boolean;

// @public (undocumented)
const deepMerge: (target?: {}, source?: {}, optionsArgument?: any) => any;

// @public (undocumented)
const DefaultHistoryMemo: HistoryMemo;

// @public (undocumented)
interface DicomDateObject {
    // (undocumented)
    day: number;
    // (undocumented)
    month: number;
    // (undocumented)
    year: number;
}

// @public (undocumented)
interface DicomTimeObject {
    // (undocumented)
    fractionalSeconds?: number;
    // (undocumented)
    hours: number;
    // (undocumented)
    minutes?: number;
    // (undocumented)
    seconds?: number;
}

// @public (undocumented)
interface DisplayArea {
    // (undocumented)
    imageArea?: [number, number];
    // (undocumented)
    imageCanvasPoint?: {
        imagePoint: [number, number];
        canvasPoint?: [number, number];
    };
    // (undocumented)
    interpolationType?: InterpolationType;
    // (undocumented)
    scale?: number;
    // (undocumented)
    storeAsInitialCamera?: boolean;
    // (undocumented)
    type?: 'SCALE' | 'FIT';
}

// @public (undocumented)
type DisplayAreaModifiedEvent = CustomEvent_2<DisplayAreaModifiedEventDetail>;

// @public (undocumented)
interface DisplayAreaModifiedEventDetail {
    // (undocumented)
    displayArea: DisplayArea;
    // (undocumented)
    storeAsInitialCamera?: boolean;
    // (undocumented)
    viewportId: string;
    // (undocumented)
    volumeId?: string;
}

// @public (undocumented)
enum DynamicOperatorType {
    // (undocumented)
    AVERAGE = "AVERAGE",
    // (undocumented)
    SUBTRACT = "SUBTRACT",
    // (undocumented)
    SUM = "SUM"
}

// @public (undocumented)
type ElementDisabledEvent = CustomEvent_2<ElementDisabledEventDetail>;

// @public (undocumented)
interface ElementDisabledEventDetail {
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
type ElementEnabledEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public (undocumented)
interface ElementEnabledEventDetail {
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

declare namespace Enums {
    export {
        EVENTS as Events,
        BlendModes,
        CalibrationTypes,
        InterpolationType,
        RequestType,
        ViewportType,
        OrientationAxis,
        GeometryType,
        ContourType,
        VOILUTFunctionType,
        DynamicOperatorType,
        ViewportStatus,
        VideoEnums,
        MetadataModules,
        ImageQualityStatus,
        VoxelManagerEnum,
        GenerateImageType
    }
}
export { Enums }

// @public (undocumented)
const EPSILON = 0.001;

declare namespace eventListener {
    export {
        TargetEventListeners,
        MultiTargetEventListenerManager
    }
}

// @public (undocumented)
export enum EVENTS {
    // (undocumented)
    CACHE_SIZE_EXCEEDED = "CACHE_SIZE_EXCEEDED",
    // (undocumented)
    CAMERA_MODIFIED = "CORNERSTONE_CAMERA_MODIFIED",
    // (undocumented)
    CAMERA_RESET = "CORNERSTONE_CAMERA_RESET",
    // (undocumented)
    CLIPPING_PLANES_UPDATED = "CORNERSTONE_CLIPPING_PLANES_UPDATED",
    // (undocumented)
    COLORMAP_MODIFIED = "CORNERSTONE_COLORMAP_MODIFIED",
    // (undocumented)
    DISPLAY_AREA_MODIFIED = "CORNERSTONE_DISPLAY_AREA_MODIFIED",
    // (undocumented)
    DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED = "DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED",
    // (undocumented)
    DYNAMIC_VOLUME_DIMENSION_GROUP_LOADED = "DYNAMIC_VOLUME_DIMENSION_GROUP_LOADED",
    // (undocumented)
    DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED = "DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED",
    // (undocumented)
    DYNAMIC_VOLUME_TIME_POINT_LOADED = "DYNAMIC_VOLUME_TIME_POINT_LOADED",
    // (undocumented)
    ELEMENT_DISABLED = "CORNERSTONE_ELEMENT_DISABLED",
    // (undocumented)
    ELEMENT_ENABLED = "CORNERSTONE_ELEMENT_ENABLED",
    // (undocumented)
    ERROR_EVENT = "CORNERSTONE_ERROR",
    // (undocumented)
    GEOMETRY_CACHE_GEOMETRY_ADDED = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED",
    // (undocumented)
    GEOMETRY_CACHE_GEOMETRY_REMOVED = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_REMOVED",
    // (undocumented)
    GEOMETRY_LOADED = "GEOMETRY_LOADED",
    // (undocumented)
    GEOMETRY_LOADED_FAILED = "GEOMETRY_LOADED_FAILED",
    // (undocumented)
    IMAGE_CACHE_IMAGE_ADDED = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED",
    // (undocumented)
    IMAGE_CACHE_IMAGE_REMOVED = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED",
    // (undocumented)
    IMAGE_LOAD_ERROR = "IMAGE_LOAD_ERROR",
    // (undocumented)
    IMAGE_LOAD_FAILED = "CORNERSTONE_IMAGE_LOAD_FAILED",
    // (undocumented)
    IMAGE_LOADED = "CORNERSTONE_IMAGE_LOADED",
    // (undocumented)
    IMAGE_RENDERED = "CORNERSTONE_IMAGE_RENDERED",
    // (undocumented)
    IMAGE_RETRIEVAL_STAGE = "CORNERSTONE_IMAGE_RETRIEVAL_STAGE",
    // (undocumented)
    IMAGE_SPACING_CALIBRATED = "CORNERSTONE_IMAGE_SPACING_CALIBRATED",
    // (undocumented)
    IMAGE_VOLUME_LOADING_COMPLETED = "CORNERSTONE_IMAGE_VOLUME_LOADING_COMPLETED",
    // (undocumented)
    IMAGE_VOLUME_MODIFIED = "CORNERSTONE_IMAGE_VOLUME_MODIFIED",
    // (undocumented)
    PRE_STACK_NEW_IMAGE = "CORNERSTONE_PRE_STACK_NEW_IMAGE",
    // (undocumented)
    PRESET_MODIFIED = "CORNERSTONE_VIEWPORT_RENDERING_PRESET_MODIFIED",
    // (undocumented)
    STACK_NEW_IMAGE = "CORNERSTONE_STACK_NEW_IMAGE",
    // (undocumented)
    STACK_SCROLL_OUT_OF_BOUNDS = "STACK_SCROLL_OUT_OF_BOUNDS",
    // (undocumented)
    STACK_VIEWPORT_SCROLL = "CORNERSTONE_STACK_VIEWPORT_SCROLL",
    // (undocumented)
    VIEWPORT_NEW_IMAGE_SET = "CORNERSTONE_VIEWPORT_NEW_IMAGE_SET",
    // (undocumented)
    VOI_MODIFIED = "CORNERSTONE_VOI_MODIFIED",
    // (undocumented)
    VOLUME_CACHE_VOLUME_ADDED = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED",
    // (undocumented)
    VOLUME_CACHE_VOLUME_REMOVED = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED",
    // (undocumented)
    VOLUME_LOADED = "CORNERSTONE_VOLUME_LOADED",
    // (undocumented)
    VOLUME_LOADED_FAILED = "CORNERSTONE_VOLUME_LOADED_FAILED",
    // (undocumented)
    VOLUME_NEW_IMAGE = "CORNERSTONE_VOLUME_NEW_IMAGE",
    // (undocumented)
    VOLUME_VIEWPORT_NEW_VOLUME = "CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME",
    // (undocumented)
    VOLUME_VIEWPORT_SCROLL = "VOLUME_VIEWPORT_SCROLL",
    // (undocumented)
    VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS = "VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS",
    // (undocumented)
    WEB_WORKER_PROGRESS = "CORNERSTONE_WEB_WORKER_PROGRESS"
}

// @public (undocumented)
export const eventTarget: CornerstoneEventTarget;

declare namespace EventTypes {
    export {
        ImageLoadStageEventDetail,
        VolumeScrollOutOfBoundsEventDetail,
        VolumeScrollOutOfBoundsEvent,
        CameraModifiedEventDetail,
        CameraModifiedEvent,
        VoiModifiedEvent,
        VoiModifiedEventDetail,
        ColormapModifiedEvent,
        ColormapModifiedEventDetail,
        DisplayAreaModifiedEvent,
        DisplayAreaModifiedEventDetail,
        ElementDisabledEvent,
        ElementDisabledEventDetail,
        ElementEnabledEvent,
        ElementEnabledEventDetail,
        ImageRenderedEventDetail,
        ImageRenderedEvent,
        ImageVolumeModifiedEvent,
        ImageVolumeModifiedEventDetail,
        ImageVolumeLoadingCompletedEvent,
        ImageVolumeLoadingCompletedEventDetail,
        ImageLoadedEvent,
        ImageLoadedEventDetail,
        ImageLoadedFailedEventDetail,
        ImageLoadedFailedEvent,
        VolumeLoadedEvent,
        VolumeLoadedEventDetail,
        VolumeLoadedFailedEvent,
        VolumeLoadedFailedEventDetail,
        ImageCacheImageAddedEvent,
        ImageCacheImageAddedEventDetail,
        ImageCacheImageRemovedEvent,
        ImageCacheImageRemovedEventDetail,
        VolumeCacheVolumeAddedEvent,
        VolumeCacheVolumeAddedEventDetail,
        VolumeCacheVolumeRemovedEvent,
        VolumeCacheVolumeRemovedEventDetail,
        StackNewImageEvent,
        StackNewImageEventDetail,
        PreStackNewImageEvent,
        PreStackNewImageEventDetail,
        ImageSpacingCalibratedEvent,
        ImageSpacingCalibratedEventDetail,
        VolumeNewImageEvent,
        VolumeNewImageEventDetail,
        StackViewportNewStackEvent,
        StackViewportNewStackEventDetail,
        StackViewportScrollEvent,
        StackViewportScrollEventDetail,
        StackScrollOutOfBoundsEvent,
        StackScrollOutOfBoundsEventDetail,
        CameraResetEvent,
        CameraResetEventDetail
    }
}

// @public (undocumented)
function findMatchingColormap(rgbPoints: any, actor: any): ColormapPublic | null;

// @public (undocumented)
interface FlipDirection {
    // (undocumented)
    flipHorizontal?: boolean;
    // (undocumented)
    flipVertical?: boolean;
}

// @public (undocumented)
class FrameRange {
    // (undocumented)
    protected static frameRangeExtractor: RegExp;
    // (undocumented)
    protected static framesToImageId(imageId: string, range: FramesRange | string): string;
    // (undocumented)
    static framesToString(range: any): string;
    // (undocumented)
    static imageIdToFrameEnd(imageId: string): number;
    // (undocumented)
    protected static imageIdToFrames(imageId: string): FramesRange;
    // (undocumented)
    static imageIdToFrameStart(imageId: string): number;
}

// @public (undocumented)
interface GeneralSeriesModuleMetadata {
    // (undocumented)
    modality: string;
    // (undocumented)
    seriesDate: DicomDateObject;
    // (undocumented)
    seriesInstanceUID: string;
    // (undocumented)
    seriesNumber: number;
    // (undocumented)
    seriesTime: DicomTimeObject;
    // (undocumented)
    studyInstanceUID: string;
}

// @public (undocumented)
enum GenerateImageType {
    // (undocumented)
    AVERAGE = "AVERAGE",
    // (undocumented)
    SUBTRACT = "SUBTRACT",
    // (undocumented)
    SUM = "SUM"
}

// @public (undocumented)
function generateVolumePropsFromImageIds(imageIds: string[], volumeId: string): ImageVolumeProps;

declare namespace geometryLoader {
    export {
        loadGeometry,
        loadAndCacheGeometry,
        createAndCacheGeometry,
        registerGeometryLoader,
        registerUnknownGeometryLoader
    }
}
export { geometryLoader }

// @public (undocumented)
type GeometryLoaderFn = (geometryId: string, options?: Record<string, unknown>) => {
    promise: Promise<IGeometry>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
enum GeometryType {
    // (undocumented)
    CONTOUR = "CONTOUR",
    // (undocumented)
    SURFACE = "SURFACE"
}

// @public (undocumented)
function getBufferConfiguration(targetBufferType: PixelDataTypedArrayString, length: number, options?: {
    isVolumeBuffer?: boolean;
}): {
    numBytes: number;
    TypedArrayConstructor: new (length: number) => PixelDataTypedArray;
};

// @public (undocumented)
function getClosestImageId(imageVolume: IImageVolume | {
    direction: mat3;
    spacing: Point3;
    imageIds: string[];
}, worldPos: Point3, viewPlaneNormal: Point3): string;

// @public (undocumented)
function getClosestStackImageIndexForPoint(point: Point3, viewport: StackViewport): number | null;

// @public (undocumented)
function getColormap(name: any): any;

// @public (undocumented)
function getColormapNames(): any[];

// @public (undocumented)
export function getConfiguration(): Cornerstone3DConfig;

// @public (undocumented)
function getCurrentVolumeViewportSlice(viewport: IVolumeViewport): {
    width: number;
    height: number;
    scalarData: PixelDataTypedArray;
    sliceToIndexMatrix: mat4;
    indexToSliceMatrix: mat4;
};

// @public (undocumented)
function getDynamicVolumeInfo(imageIds: any): {
    isDynamicVolume: boolean;
    timePoints: string[][];
    splittingTag: string;
};

// @public (undocumented)
export function getEnabledElement(element: HTMLDivElement | undefined): IEnabledElement | undefined;

// @public (undocumented)
export function getEnabledElementByIds(viewportId: string, renderingEngineId: string): IEnabledElement;

// @public (undocumented)
export function getEnabledElementByViewportId(viewportId: string): IEnabledElement;

// @public (undocumented)
export function getEnabledElements(): IEnabledElement[];

// @public (undocumented)
function getImageLegacy(element: HTMLDivElement): Types.IImage | undefined;

// @public (undocumented)
function getImageSliceDataForVolumeViewport(viewport: IVolumeViewport): ImageSliceData;

// @public (undocumented)
function getMetaData(type: string, ...queries: any[]): any;

// @public (undocumented)
function getMinMax(storedPixelData: PixelDataTypedArray): {
    min: number;
    max: number;
};

// @public (undocumented)
export function getOrCreateCanvas(element: HTMLDivElement): HTMLCanvasElement;

// @public (undocumented)
function getRandomSampleFromArray<T>(array: T[], size: number): T[];

// @public (undocumented)
export function getRenderingEngine(id: string): IRenderingEngine | undefined;

// @public (undocumented)
export function getRenderingEngines(): IRenderingEngine[] | undefined;

// @public (undocumented)
function getRuntimeId(context?: unknown, separator?: string, max?: number): string;

// @public (undocumented)
function getScalingParameters(imageId: string): ScalingParameters;

// @public (undocumented)
export function getShouldUseCPURendering(): boolean;

// @public (undocumented)
function getSliceRange(volumeActor: VolumeActor, viewPlaneNormal: Point3, focalPoint: Point3): ActorSliceRange;

// @public (undocumented)
function getSpacingInNormalDirection(imageVolume: IImageVolume | {
    direction: mat3;
    spacing: Point3;
}, viewPlaneNormal: Point3): number;

// @public (undocumented)
function getTargetVolumeAndSpacingInNormalDir(viewport: IVolumeViewport, camera: ICamera, targetId?: string, useSlabThickness?: boolean): {
    imageVolume: IImageVolume;
    spacingInNormalDirection: number;
    actorUID: string;
};

// @public (undocumented)
function getTransferFunctionNodes(transferFunction: any): any[];

// @public (undocumented)
function getUnknownVolumeLoaderSchema(): string;

// @public (undocumented)
function getViewportImageCornersInWorld(viewport: StackViewport | IVolumeViewport): Point3[];

// @public (undocumented)
function getViewportImageIds(viewport: IViewport): string[];

// @public (undocumented)
const getViewportModality: (viewport: IViewport, volumeId?: string) => string;

// @public (undocumented)
function getViewportsWithImageURI(imageURI: string): Viewport_2[];

// @public (undocumented)
function getViewportsWithVolumeId(volumeId: string): IVolumeViewport[];

// @public (undocumented)
function getVoiFromSigmoidRGBTransferFunction(cfun: vtkColorTransferFunction): [number, number];

// @public (undocumented)
function getVolumeActorCorners(volumeActor: any): Point3[];

// @public (undocumented)
function getVolumeDirectionVectors(imageData: any, camera: any): {
    worldVecRowDir: vec3;
    worldVecColDir: vec3;
    worldVecSliceDir: vec3;
    ijkVecRowDir: vec3;
    ijkVecColDir: vec3;
    ijkVecSliceDir: vec3;
};

// @public (undocumented)
const getVolumeId: (targetId: string) => string;

// @public (undocumented)
function getVolumeLoaderSchemes(): string[];

// @public (undocumented)
function getVolumeSliceRangeInfo(viewport: IVolumeViewport, volumeId: string, useSlabThickness?: boolean): {
    sliceRange: ActorSliceRange;
    spacingInNormalDirection: number;
    camera: ICamera;
};

// @public (undocumented)
function getVolumeViewportsContainingSameVolumes(targetViewport: IVolumeViewport, renderingEngineId?: string): IVolumeViewport[];

// @public (undocumented)
function getVolumeViewportScrollInfo(viewport: IVolumeViewport, volumeId: string, useSlabThickness?: boolean): {
    numScrollSteps: number;
    currentStepIndex: number;
    sliceRangeInfo: {
        sliceRange: ActorSliceRange;
        spacingInNormalDirection: number;
        camera: ICamera;
    };
};

// @public (undocumented)
export function getWebWorkerManager(): any;

// @public (undocumented)
const hasFloatScalingParameters: (scalingParameters: ScalingParameters) => boolean;

// @public (undocumented)
function hasNaNValues(input: number[] | number): boolean;

// @public (undocumented)
function hexToRgb(hex: any): {
    r: number;
    g: number;
    b: number;
};

// @public (undocumented)
class HistoryMemo {
    constructor(label?: string, size?: number);
    // (undocumented)
    readonly label: any;
    // (undocumented)
    push(item: Memo | Memoable): Memo;
    // (undocumented)
    redo(items?: number): void;
    // (undocumented)
    get size(): number;
    set size(newSize: number);
    // (undocumented)
    undo(items?: number): void;
}

declare namespace HistoryMemo_2 {
    export {
        Memo,
        Memoable,
        HistoryMemo,
        DefaultHistoryMemo
    }
}

// @public (undocumented)
type IBaseVolumeViewport = BaseVolumeViewport;

// @public (undocumented)
interface ICache {
    // (undocumented)
    getCacheSize: () => number;
    // (undocumented)
    getImageLoadObject: (imageId: string) => IImageLoadObject | void;
    // (undocumented)
    getMaxCacheSize: () => number;
    // (undocumented)
    getVolumeLoadObject: (volumeId: string) => IVolumeLoadObject | void;
    // (undocumented)
    purgeCache: () => void;
    // (undocumented)
    putImageLoadObject: (imageId: string, imageLoadObject: IImageLoadObject, updateCache?: boolean) => Promise<void>;
    // (undocumented)
    putVolumeLoadObject: (volumeId: string, volumeLoadObject: IVolumeLoadObject) => Promise<void>;
    // (undocumented)
    setMaxCacheSize: (maxCacheSize: number) => void;
}

// @public (undocumented)
interface ICachedGeometry {
    // (undocumented)
    geometry?: IGeometry;
    // (undocumented)
    geometryId: string;
    // (undocumented)
    geometryLoadObject: IGeometryLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedImage {
    // (undocumented)
    image?: IImage;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageLoadObject?: IImageLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedVolume {
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
    // (undocumented)
    volume?: IImageVolume;
    // (undocumented)
    volumeId: string;
    // (undocumented)
    volumeLoadObject: IVolumeLoadObject;
}

// @public (undocumented)
interface ICamera {
    // (undocumented)
    clippingRange?: Point2;
    // (undocumented)
    flipHorizontal?: boolean;
    // (undocumented)
    flipVertical?: boolean;
    // (undocumented)
    focalPoint?: Point3;
    // (undocumented)
    parallelProjection?: boolean;
    // (undocumented)
    parallelScale?: number;
    // (undocumented)
    position?: Point3;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    viewAngle?: number;
    // (undocumented)
    viewPlaneNormal?: Point3;
    // (undocumented)
    viewUp?: Point3;
}

// @public (undocumented)
type ICanvasActor = CanvasActor;

// @public (undocumented)
type IContour = Contour;

// @public (undocumented)
type IContourSet = ContourSet;

// @public (undocumented)
interface IDynamicImageVolume extends IImageVolume {
    // (undocumented)
    get dimensionGroupNumber(): number;
    set dimensionGroupNumber(dimensionGroupNumber: number);
    // (undocumented)
    get numDimensionGroups(): number;
    // (undocumented)
    get numTimePoints(): number;
    // (undocumented)
    scroll(delta: number): void;
    // (undocumented)
    get timePointIndex(): number;
    set timePointIndex(timePointIndex: number);
}

// @public (undocumented)
interface IEnabledElement {
    // (undocumented)
    FrameOfReferenceUID: string;
    // (undocumented)
    renderingEngine: IRenderingEngine;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewport: StackViewport | IVolumeViewport;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
interface IGeometry {
    // (undocumented)
    data: IContourSet | ISurface;
    // (undocumented)
    id: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    type: GeometryType;
}

// @public (undocumented)
interface IGeometryLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IGeometry>;
}

// @public (undocumented)
interface IImage {
    // (undocumented)
    bufferView?: {
        buffer: ArrayBuffer;
        offset: number;
    };
    // (undocumented)
    cachedLut?: {
        windowWidth?: number | number[];
        windowCenter?: number | number[];
        invert?: boolean;
        lutArray?: Uint8ClampedArray;
        modalityLUT?: CPUFallbackLUT;
        voiLUT?: CPUFallbackLUT;
    };
    // (undocumented)
    calibration?: IImageCalibration;
    // (undocumented)
    color: boolean;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    columnPixelSpacing: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    dataType: PixelDataTypedArrayString;
    // (undocumented)
    decodeTimeInMS?: number;
    // (undocumented)
    FrameOfReferenceUID?: string;
    // (undocumented)
    getCanvas: () => HTMLCanvasElement;
    // (undocumented)
    getPixelData: () => PixelDataTypedArray;
    // (undocumented)
    height: number;
    // (undocumented)
    imageFrame?: ImageFrame;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageQualityStatus?: ImageQualityStatus;
    // (undocumented)
    intercept: number;
    // (undocumented)
    invert: boolean;
    // (undocumented)
    isPreScaled?: boolean;
    // (undocumented)
    loadTimeInMS?: number;
    // (undocumented)
    maxPixelValue: number;
    // (undocumented)
    minPixelValue: number;
    // (undocumented)
    modalityLUT?: CPUFallbackLUT;
    // (undocumented)
    numberOfComponents: number;
    // (undocumented)
    photometricInterpretation?: string;
    // (undocumented)
    preScale?: {
        enabled: boolean;
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    // (undocumented)
    referencedImageId?: string;
    // (undocumented)
    render?: (enabledElement: CPUFallbackEnabledElement, invalidated: boolean) => unknown;
    // (undocumented)
    rgba: boolean;
    // (undocumented)
    rowPixelSpacing: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    scaling?: {
        PT?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    sliceThickness?: number;
    // (undocumented)
    slope: number;
    // (undocumented)
    stats?: {
        lastStoredPixelDataToCanvasImageDataTime?: number;
        lastGetPixelDataTime?: number;
        lastPutImageDataTime?: number;
        lastLutGenerateTime?: number;
        lastRenderedViewport?: unknown;
        lastRenderTime?: number;
    };
    // (undocumented)
    voiLUT?: CPUFallbackLUT;
    // (undocumented)
    voiLUTFunction: VOILUTFunctionType;
    // (undocumented)
    voxelManager?: IVoxelManager<number> | IVoxelManager<RGB>;
    // (undocumented)
    width: number;
    // (undocumented)
    windowCenter: number[] | number;
    // (undocumented)
    windowWidth: number[] | number;
}

// @public (undocumented)
interface IImageCalibration {
    // (undocumented)
    aspect?: number;
    // (undocumented)
    columnPixelSpacing?: number;
    // (undocumented)
    rowPixelSpacing?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    sequenceOfUltrasoundRegions?: Record<string, unknown>[];
    // (undocumented)
    tooltip?: string;
    // (undocumented)
    type: CalibrationTypes;
}

// @public (undocumented)
interface IImageData {
    // (undocumented)
    calibration?: IImageCalibration;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    hasPixelSpacing?: boolean;
    // (undocumented)
    imageData: vtkImageData;
    // (undocumented)
    metadata: {
        Modality: string;
        FrameOfReferenceUID: string;
    };
    // (undocumented)
    numberOfComponents?: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    // (undocumented)
    scalarData: PixelDataTypedArray;
    // (undocumented)
    scaling?: Scaling;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    voxelManager?: IVoxelManager<number> | IVoxelManager<RGB>;
}

// @public (undocumented)
interface IImageLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IImage>;
}

// @public (undocumented)
export interface IImagesLoader {
    // (undocumented)
    loadImages: (imageIds: string[], listener: ImageLoadListener) => Promise<unknown>;
}

// @public (undocumented)
type IImageVolume = ImageVolume;

// @public (undocumented)
type ImageActor = vtkImageSlice;

// @public (undocumented)
type ImageCacheImageAddedEvent = CustomEvent_2<ImageCacheImageAddedEventDetail>;

// @public (undocumented)
interface ImageCacheImageAddedEventDetail {
    // (undocumented)
    image: ICachedImage;
}

// @public (undocumented)
type ImageCacheImageRemovedEvent = CustomEvent_2<ImageCacheImageRemovedEventDetail>;

// @public (undocumented)
interface ImageCacheImageRemovedEventDetail {
    // (undocumented)
    imageId: string;
}

// @public (undocumented)
interface ImageFrame {
    // (undocumented)
    bitsAllocated: number;
    // (undocumented)
    bitsStored: number;
    // (undocumented)
    bluePaletteColorLookupTableData: number[];
    // (undocumented)
    bluePaletteColorLookupTableDescriptor: number[];
    // (undocumented)
    columns: number;
    // (undocumented)
    decodeLevel?: unknown;
    // (undocumented)
    decodeTimeInMS?: number;
    // (undocumented)
    greenPaletteColorLookupTableData: number[];
    // (undocumented)
    greenPaletteColorLookupTableDescriptor: number[];
    // (undocumented)
    imageData?: ImageData;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageQualityStatus?: ImageQualityStatus;
    // (undocumented)
    largestPixelValue: number;
    // (undocumented)
    loadTimeInMS?: number;
    // (undocumented)
    photometricInterpretation: string;
    // (undocumented)
    pixelData: PixelDataTypedArray;
    // (undocumented)
    pixelDataLength?: number;
    // (undocumented)
    pixelRepresentation: number;
    // (undocumented)
    planarConfiguration: number;
    // (undocumented)
    preScale?: {
        enabled: boolean;
        scaled: boolean;
        scalingParameters?: {
            intercept?: number;
            slope?: number;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            modality?: string;
            suvbw?: number;
        };
    };
    // (undocumented)
    redPaletteColorLookupTableData: number[];
    // (undocumented)
    redPaletteColorLookupTableDescriptor: number[];
    // (undocumented)
    rows: number;
    // (undocumented)
    samplesPerPixel: number;
    // (undocumented)
    smallestPixelValue: number;
    // (undocumented)
    transferSyntax?: string;
}

// @public (undocumented)
function imageIdToURI(imageId: string): string;

// @public (undocumented)
type ImageLoadedEvent = CustomEvent_2<ImageLoadedEventDetail>;

// @public (undocumented)
interface ImageLoadedEventDetail {
    // (undocumented)
    image: IImage;
}

// @public (undocumented)
type ImageLoadedFailedEvent = CustomEvent_2<ImageLoadedFailedEventDetail>;

// @public (undocumented)
interface ImageLoadedFailedEventDetail {
    // (undocumented)
    error: unknown;
    // (undocumented)
    imageId: string;
}

declare namespace imageLoader {
    export {
        loadImage,
        loadAndCacheImage,
        loadAndCacheImages,
        createAndCacheDerivedImage,
        createAndCacheDerivedImages,
        createAndCacheLocalImage,
        cancelLoadImage,
        cancelLoadImages,
        cancelLoadAll,
        registerImageLoader,
        registerUnknownImageLoader,
        unregisterAllImageLoaders,
        createAndCacheDerivedLabelmapImages,
        createAndCacheDerivedLabelmapImage,
        ImageLoaderOptions
    }
}
export { imageLoader }

// @public (undocumented)
type ImageLoaderFn = (imageId: string, options?: Record<string, unknown>) => {
    promise: Promise<Record<string, unknown>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
interface ImageLoaderOptions {
    // (undocumented)
    additionalDetails?: Record<string, unknown>;
    // (undocumented)
    ignoreCache?: boolean;
    // (undocumented)
    priority: number;
    // (undocumented)
    requestType: string;
}

// @public (undocumented)
export interface ImageLoadListener {
    // (undocumented)
    errorCallback: (imageId: any, permanent: any, reason: any) => void;
    // (undocumented)
    getLoaderImageOptions?: (imageId: any) => Record<string, unknown>;
    // (undocumented)
    successCallback: (imageId: any, image: any) => void;
}

// @public (undocumented)
const imageLoadPoolManager: RequestPoolManager;
export { imageLoadPoolManager }
export { imageLoadPoolManager as requestPoolManager }

// @public (undocumented)
interface ImageLoadRequests {
    // (undocumented)
    additionalDetails: {
        volumeId: string;
    };
    // (undocumented)
    callLoadImage: (imageId: string, imageIdIndex: number, options: unknown) => Promise<void>;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageIdIndex: number;
    // (undocumented)
    options: {
        targetBuffer: {
            type: string;
            rows: number;
            columns: number;
        };
        preScale: {
            enabled: boolean;
            scalingParameters: ScalingParameters;
        };
        transferPixelData: boolean;
    };
    // (undocumented)
    priority: number;
    // (undocumented)
    requestType: RequestType;
}

// @public (undocumented)
interface ImageLoadStageEventDetail {
    // (undocumented)
    numberOfFailures: number;
    // (undocumented)
    numberOfImages: number;
    // (undocumented)
    stageDurationInMS: number;
    // (undocumented)
    stageId: string;
    // (undocumented)
    startDurationInMS: number;
}

// @public (undocumented)
interface ImagePixelModule {
    // (undocumented)
    bitsAllocated: number;
    // (undocumented)
    bitsStored: number;
    // (undocumented)
    highBit: number;
    // (undocumented)
    modality: string;
    // (undocumented)
    photometricInterpretation: string;
    // (undocumented)
    pixelRepresentation: string;
    // (undocumented)
    samplesPerPixel: number;
    // (undocumented)
    voiLUTFunction: VOILUTFunctionType;
    // (undocumented)
    windowCenter: number | number[];
    // (undocumented)
    windowWidth: number | number[];
}

// @public (undocumented)
interface ImagePixelModuleMetadata {
    // (undocumented)
    bitsAllocated: number;
    // (undocumented)
    bitsStored: number;
    // (undocumented)
    bluePaletteColorLookupTableData: number[];
    // (undocumented)
    bluePaletteColorLookupTableDescriptor: number[];
    // (undocumented)
    columns: number;
    // (undocumented)
    greenPaletteColorLookupTableData: number[];
    // (undocumented)
    greenPaletteColorLookupTableDescriptor: number[];
    // (undocumented)
    highBit: number;
    // (undocumented)
    largestPixelValue?: number;
    // (undocumented)
    photometricInterpretation: string;
    // (undocumented)
    pixelAspectRatio: string;
    // (undocumented)
    pixelRepresentation: number;
    // (undocumented)
    planarConfiguration: number;
    // (undocumented)
    redPaletteColorLookupTableData: number[];
    // (undocumented)
    redPaletteColorLookupTableDescriptor: number[];
    // (undocumented)
    rows: number;
    // (undocumented)
    samplesPerPixel: number;
    // (undocumented)
    smallestPixelValue?: number;
}

// @public (undocumented)
interface ImagePlaneModule {
    // (undocumented)
    columnCosines?: Point3;
    // (undocumented)
    columnPixelSpacing?: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    frameOfReferenceUID: string;
    // (undocumented)
    imageOrientationPatient?: Float32Array;
    // (undocumented)
    imagePositionPatient?: Point3;
    // (undocumented)
    pixelSpacing?: Point2;
    // (undocumented)
    rowCosines?: Point3;
    // (undocumented)
    rowPixelSpacing?: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    sliceLocation?: number;
    // (undocumented)
    sliceThickness?: number;
}

// @public (undocumented)
interface ImagePlaneModuleMetadata {
    // (undocumented)
    columnCosines: number[];
    // (undocumented)
    columnPixelSpacing: number | null;
    // (undocumented)
    columns: number;
    // (undocumented)
    frameOfReferenceUID: string;
    // (undocumented)
    imageOrientationPatient: number[];
    // (undocumented)
    imagePositionPatient: number[];
    // (undocumented)
    pixelSpacing: number[];
    // (undocumented)
    rowCosines: number[];
    // (undocumented)
    rowPixelSpacing: number | null;
    // (undocumented)
    rows: number;
    // (undocumented)
    sliceLocation: number;
    // (undocumented)
    sliceThickness: number;
    // (undocumented)
    usingDefaultValues: boolean;
}

// @public (undocumented)
enum ImageQualityStatus {
    // (undocumented)
    ADJACENT_REPLICATE = 3,
    // (undocumented)
    FAR_REPLICATE = 1,
    // (undocumented)
    FULL_RESOLUTION = 8,
    // (undocumented)
    LOSSY = 7,
    // (undocumented)
    SUBRESOLUTION = 6
}

// @public (undocumented)
type ImageRenderedEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public (undocumented)
interface ImageRenderedEventDetail {
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    suppressEvents?: boolean;
    // (undocumented)
    viewportId: string;
    // (undocumented)
    viewportStatus: ViewportStatus;
}

// @public (undocumented)
export const imageRetrievalPoolManager: RequestPoolManager;

// @public (undocumented)
const imageRetrieveMetadataProvider: {
    IMAGE_RETRIEVE_CONFIGURATION: string;
    clear: () => void;
    add: (key: string, payload: any) => void;
    clone: () => Map<string, unknown>;
    restore: (state: Map<string, unknown>) => void;
    get: (type: string, ...queries: string[]) => unknown;
};

// @public (undocumented)
interface ImageSliceData {
    // (undocumented)
    imageIndex: number;
    // (undocumented)
    numberOfSlices: number;
}

// @public (undocumented)
type ImageSpacingCalibratedEvent = CustomEvent_2<ImageSpacingCalibratedEventDetail>;

// @public (undocumented)
interface ImageSpacingCalibratedEventDetail {
    // (undocumented)
    calibration: IImageCalibration;
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    imageData: vtkImageData;
    // (undocumented)
    imageId: string;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
    // (undocumented)
    worldToIndex: mat4;
}

// @public (undocumented)
function imageToWorldCoords(imageId: string, imageCoords: Point2): Point3 | undefined;

// @public (undocumented)
export class ImageVolume {
    constructor(props: ImageVolumeProps);
    // (undocumented)
    additionalDetails?: Record<string, unknown>;
    // (undocumented)
    cancelLoading: () => void;
    // (undocumented)
    protected cornerstoneImageMetaData: any;
    // (undocumented)
    dataType?: PixelDataTypedArrayString;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    getCornerstoneImages(): IImage[];
    // (undocumented)
    getImageIdByIndex(imageIdIndex: number): string;
    // (undocumented)
    getImageIdIndex(imageId: string): number;
    // (undocumented)
    getImageURIIndex(imageURI: string): number;
    // (undocumented)
    getScalarDataLength(): number;
    // (undocumented)
    hasPixelSpacing: boolean;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    protected imageIdIndexToFrameIndex(imageIdIndex: number): number;
    // (undocumented)
    get imageIds(): string[];
    set imageIds(newImageIds: string[]);
    // (undocumented)
    invalidate(): void;
    // (undocumented)
    isDynamicVolume(): boolean;
    // (undocumented)
    isPreScaled: boolean;
    // (undocumented)
    load(callback?: (...args: unknown[]) => void): void;
    // (undocumented)
    loadStatus?: Record<string, unknown>;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    modified(): void;
    // (undocumented)
    numFrames: number;
    // (undocumented)
    numTimePoints?: number;
    // (undocumented)
    numVoxels: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedImageIds?: string[];
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    removeFromCache(): void;
    // (undocumented)
    scaling?: {
        PT?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    get sizeInBytes(): number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    protected totalNumFrames: number;
    // (undocumented)
    readonly volumeId: string;
    // (undocumented)
    voxelManager?: IVoxelManager<number> | IVoxelManager<RGB>;
    // (undocumented)
    vtkOpenGLTexture: vtkStreamingOpenGLTexture;
}

// @public (undocumented)
type ImageVolumeLoadingCompletedEvent = CustomEvent_2<ImageVolumeLoadingCompletedEventDetail>;

// @public (undocumented)
interface ImageVolumeLoadingCompletedEventDetail {
    // (undocumented)
    FrameOfReferenceUID: string;
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
type ImageVolumeModifiedEvent = CustomEvent_2<ImageVolumeModifiedEventDetail>;

// @public (undocumented)
interface ImageVolumeModifiedEventDetail {
    // (undocumented)
    FrameOfReferenceUID: string;
    // (undocumented)
    framesProcessed: number;
    // (undocumented)
    numberOfFrames: number;
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
interface ImageVolumeProps extends VolumeProps {
    // (undocumented)
    imageIds: string[];
    // (undocumented)
    referencedImageIds?: string[];
}

// @public (undocumented)
function indexWithinDimensions(index: Point3, dimensions: Point3): boolean;

// @public (undocumented)
export function init(configuration?: Cornerstone3DConfig): boolean;

// @public (undocumented)
interface InternalVideoCamera {
    // (undocumented)
    panWorld?: Point2;
    // (undocumented)
    parallelScale?: number;
}

// @public (undocumented)
enum InterpolationType {
    // (undocumented)
    FAST_LINEAR = 2,
    // (undocumented)
    LINEAR = 1,
    // (undocumented)
    NEAREST = 0
}

// @public (undocumented)
function invertRgbTransferFunction(rgbTransferFunction: vtkColorTransferFunction): void;

// @public (undocumented)
type IPointsManager<T> = PointsManager<T>;

// @public (undocumented)
interface IRegisterImageLoader {
    // (undocumented)
    registerImageLoader: (scheme: string, imageLoader: ImageLoaderFn) => void;
}

// @public (undocumented)
type IRenderingEngine = RenderingEngine;

// @public (undocumented)
export interface IRetrieveConfiguration {
    // (undocumented)
    create?: (IRetrieveConfiguration: any) => IImagesLoader;
    // (undocumented)
    retrieveOptions?: Record<string, RetrieveOptions>;
    // (undocumented)
    stages?: RetrieveStage[];
}

// @public (undocumented)
type IRLEVoxelMap<T> = RLEVoxelMap<T>;

// @public (undocumented)
export function isCornerstoneInitialized(): boolean;

// @public (undocumented)
function isEqual<ValueType>(v1: ValueType, v2: ValueType, tolerance?: number): boolean;

// @public (undocumented)
const isEqualAbs: <ValueType>(v1: ValueType, v2: ValueType, tolerance?: any) => boolean;

// @public (undocumented)
const isEqualNegative: <ValueType>(v1: ValueType, v2: ValueType, tolerance?: any) => boolean;

// @public (undocumented)
function isImageActor(actorEntry: Types.ActorEntry): boolean;

// @public (undocumented)
function isOpposite(v1: Point3, v2: Point3, tolerance?: number): boolean;

// @public (undocumented)
const isPTPrescaledWithSUV: (image: IImage) => number;

// @public (undocumented)
interface IStackInput {
    // (undocumented)
    [key: string]: unknown;
    // (undocumented)
    actorUID?: string;
    // (undocumented)
    callback?: StackInputCallback;
    // (undocumented)
    imageId: string;
    // (undocumented)
    visibility?: boolean;
}

// @public (undocumented)
interface IStreamingImageVolume extends IImageVolume {
    // (undocumented)
    clearLoadCallbacks(): void;
    // (undocumented)
    decache(completelyRemove?: boolean): void;
    // (undocumented)
    load(): void;
}

// @public (undocumented)
interface IStreamingVolumeProperties {
    // (undocumented)
    imageIds: string[];
    // (undocumented)
    loadStatus: {
        loaded: boolean;
        loading: boolean;
        cancelled: boolean;
        cachedFrames: ImageQualityStatus[];
        callbacks: (() => void)[];
    };
}

// @public (undocumented)
type ISurface = Surface;

// @public (undocumented)
function isValidVolume(imageIds: string[]): boolean;

// @public (undocumented)
function isVideoTransferSyntax(uidOrUids: string | string[]): string | false;

// @public (undocumented)
type IVideoViewport = VideoViewport;

// @public (undocumented)
type IViewport = Viewport;

// @public (undocumented)
interface IViewportId {
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
type IVolume = ImageVolumeProps;

// @public (undocumented)
type IVolumeInput = {
    volumeId: string;
    actorUID?: string;
    visibility?: boolean;
    callback?: VolumeInputCallback;
    blendMode?: BlendModes;
    slabThickness?: number;
    [key: string]: unknown;
};

// @public (undocumented)
interface IVolumeLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IImageVolume>;
}

// @public (undocumented)
type IVolumeViewport = VolumeViewport;

// @public (undocumented)
type IVoxelManager<T> = VoxelManager<T>;

// @public (undocumented)
type IWSIViewport = WSIViewport;

// @public (undocumented)
function jumpToSlice(element: HTMLDivElement, options?: JumpToSliceOptions): Promise<void>;

// @public (undocumented)
type JumpToSliceOptions = {
    imageIndex: number;
    debounceLoading?: boolean;
    volumeId?: string;
};

// @public (undocumented)
function linePlaneIntersection(p0: Point3, p1: Point3, plane: Plane): Point3;

// @public (undocumented)
function loadAndCacheGeometry(geometryId: string, options?: GeometryOptions): Promise<IGeometry>;

// @public (undocumented)
function loadAndCacheImage(imageId: string, options?: ImageLoaderOptions): Promise<IImage>;

// @public (undocumented)
function loadAndCacheImages(imageIds: string[], options?: ImageLoaderOptions): Promise<IImage>[];

// @public (undocumented)
function loadGeometry(geometryId: string, options?: GeometryOptions): Promise<IGeometry>;

// @public (undocumented)
function loadImage(imageId: string, options?: ImageLoaderOptions): Promise<IImage>;

// @public (undocumented)
function loadImageToCanvas(options: LoadImageOptions): Promise<CanvasLoadPosition>;

// @public (undocumented)
function loadVolume(volumeId: string, options?: VolumeLoaderOptions): Promise<IImageVolume>;

// @public (undocumented)
interface LocalVolumeOptions {
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    imageIds?: string[];
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    preventCache?: boolean;
    // (undocumented)
    referencedImageIds?: string[];
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scalarData?: PixelDataTypedArray;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    targetBuffer?: {
        type: PixelDataTypedArrayString;
    };
}

// @public (undocumented)
function makeVolumeMetadata(imageIds: string[]): Metadata;

// @public (undocumented)
type Mat3 = [number, number, number, number, number, number, number, number, number] | Float32Array;

// @public (undocumented)
type Memo = {
    restoreMemo: (undo?: boolean) => void;
    commitMemo?: () => boolean;
};

// @public (undocumented)
type Memoable = {
    createMemo: () => Memo;
};

// @public (undocumented)
interface Metadata {
    // (undocumented)
    BitsAllocated: number;
    // (undocumented)
    BitsStored: number;
    // (undocumented)
    Columns: number;
    // (undocumented)
    FrameOfReferenceUID: string;
    // (undocumented)
    HighBit: number;
    // (undocumented)
    ImageOrientationPatient: number[];
    // (undocumented)
    Modality: string;
    // (undocumented)
    PhotometricInterpretation: string;
    // (undocumented)
    PixelRepresentation: number;
    // (undocumented)
    PixelSpacing: number[];
    // (undocumented)
    Rows: number;
    // (undocumented)
    SamplesPerPixel: number;
    // (undocumented)
    SeriesInstanceUID?: string;
    // (undocumented)
    voiLut: VOI[];
    // (undocumented)
    VOILUTFunction: string;
}

declare namespace metaData {
    export {
        addProvider,
        removeProvider,
        removeAllProviders,
        getMetaData as get
    }
}
export { metaData }

// @public (undocumented)
enum MetadataModules {
    // (undocumented)
    CALIBRATION = "calibrationModule",
    // (undocumented)
    CINE = "cineModule",
    // (undocumented)
    GENERAL_IMAGE = "generalImageModule",
    // (undocumented)
    GENERAL_SERIES = "generalSeriesModule",
    // (undocumented)
    GENERAL_STUDY = "generalStudyModule",
    // (undocumented)
    IMAGE_PIXEL = "imagePixelModule",
    // (undocumented)
    IMAGE_PLANE = "imagePlaneModule",
    // (undocumented)
    IMAGE_URL = "imageUrlModule",
    // (undocumented)
    MODALITY_LUT = "modalityLutModule",
    // (undocumented)
    MULTIFRAME = "multiframeModule",
    // (undocumented)
    NM_MULTIFRAME_GEOMETRY = "nmMultiframeGeometryModule",
    // (undocumented)
    OVERLAY_PLANE = "overlayPlaneModule",
    // (undocumented)
    PATIENT = "patientModule",
    // (undocumented)
    PATIENT_STUDY = "patientStudyModule",
    // (undocumented)
    PET_IMAGE = "petImageModule",
    // (undocumented)
    PET_ISOTOPE = "petIsotopeModule",
    // (undocumented)
    PET_SERIES = "petSeriesModule",
    // (undocumented)
    SOP_COMMON = "sopCommonModule",
    // (undocumented)
    ULTRASOUND_ENHANCED_REGION = "ultrasoundEnhancedRegionModule",
    // (undocumented)
    VOI_LUT = "voiLutModule",
    // (undocumented)
    WADO_WEB_CLIENT = "wadoWebClient"
}

// @public (undocumented)
const metadataProvider: {
    add: (imageId: string, payload: IImageCalibration) => void;
    get: (type: string, imageId: string) => IImageCalibration;
};

// @public (undocumented)
const metadataProvider_2: {
    add: (imageId: string, payload: {
        metadata: unknown;
        type: string;
    }) => void;
    addRaw: (imageId: string, payload: {
        metadata: unknown;
        type: string;
    }) => void;
    get: (type: string, imageId: string) => unknown;
    clear: () => void;
};

// @public (undocumented)
const mprCameraValues: any;

// @public (undocumented)
class MultiTargetEventListenerManager {
    // (undocumented)
    addEventListener(target: EventTarget, type: string, callback: EventListener, options?: AddEventListenerOptions): void;
    // (undocumented)
    removeEventListener(target: EventTarget, type: string, callback?: EventListener, options?: EventListenerOptions): void;
    // (undocumented)
    reset(): void;
}

// @public (undocumented)
interface NearbyFrames {
    // (undocumented)
    imageQualityStatus?: ImageQualityStatus;
    // (undocumented)
    offset: number;
}

// @public (undocumented)
enum OrientationAxis {
    // (undocumented)
    ACQUISITION = "acquisition",
    // (undocumented)
    AXIAL = "axial",
    // (undocumented)
    CORONAL = "coronal",
    // (undocumented)
    SAGITTAL = "sagittal"
}

// @public (undocumented)
interface OrientationVectors {
    // (undocumented)
    viewPlaneNormal: Point3;
    // (undocumented)
    viewUp: Point3;
}

// @public (undocumented)
interface PatientStudyModuleMetadata {
    // (undocumented)
    patientAge: number;
    // (undocumented)
    patientSize: number;
    // (undocumented)
    patientWeight: number;
}

// @public (undocumented)
export function peerImport(moduleId: string): any;

// @public (undocumented)
type PixelDataTypedArray = Float32Array | Int16Array | Uint16Array | Uint8Array | Int8Array | Uint8ClampedArray;

// @public (undocumented)
type PixelDataTypedArrayString = 'Float32Array' | 'Int16Array' | 'Uint16Array' | 'Uint8Array' | 'Int8Array' | 'Uint8ClampedArray' | 'none';

declare namespace planar {
    export {
        linePlaneIntersection,
        planeEquation,
        threePlaneIntersection,
        planeDistanceToPoint
    }
}

// @public (undocumented)
type Plane = [number, number, number, number];

// @public (undocumented)
function planeDistanceToPoint(plane: Plane, point: Point3, signed?: boolean): number;

// @public (undocumented)
function planeEquation(normal: Point3, point: Point3 | vec3, normalized?: boolean): Plane;

// @public (undocumented)
type Point2 = [number, number];

// @public (undocumented)
type Point3 = [number, number, number];

// @public (undocumented)
type Point4 = [number, number, number, number];

// @public (undocumented)
function pointInShapeCallback(imageData: vtkImageData | CPUImageData, options: PointInShapeOptions): Array<PointInShape> | undefined;

// @public (undocumented)
class PointsManager<T> {
    constructor(configuration?: PolyDataPointConfiguration);
    // (undocumented)
    array: ArrayBuffer;
    // (undocumented)
    _byteSize: number;
    // (undocumented)
    static create2(initialSize?: number): PointsManager<Point2>;
    // (undocumented)
    static create3(initialSize?: number, points?: Point3[]): PointsManager<Point3>;
    // (undocumented)
    data: Float32Array;
    // (undocumented)
    get dimensionLength(): number;
    // (undocumented)
    get dimensions(): number;
    // (undocumented)
    _dimensions: number;
    // (undocumented)
    forEach(func: (value: T, index: number) => void): void;
    // (undocumented)
    static fromXYZ({ x, y, z }: PointsXYZ): IPointsManager<Point3>;
    // (undocumented)
    getPoint(index: number): T;
    // (undocumented)
    getPointArray(index: number): T;
    // (undocumented)
    getTypedArray(): Float32Array;
    // (undocumented)
    protected grow(additionalSize?: number, growSize?: number): void;
    // (undocumented)
    growSize: number;
    // (undocumented)
    kIndex: number;
    // (undocumented)
    get length(): number;
    // (undocumented)
    _length: number;
    // (undocumented)
    map<R>(f: (value: any, index: number) => R): R[];
    // (undocumented)
    get points(): T[];
    // (undocumented)
    push(point: T): void;
    // (undocumented)
    reverse(): void;
    // (undocumented)
    sources: IPointsManager<T>[];
    // (undocumented)
    subselect(count?: number, offset?: number): IPointsManager<T>;
    // (undocumented)
    toXYZ(): PointsXYZ;
}

// @public (undocumented)
interface PointsXYZ {
    // (undocumented)
    x: number[];
    // (undocumented)
    y: number[];
    // (undocumented)
    z: number[];
}

// @public (undocumented)
interface PolyDataPointConfiguration {
    // (undocumented)
    dimensions?: number;
    // (undocumented)
    growSize?: number;
    // (undocumented)
    initialSize?: number;
}

// @public (undocumented)
const presets: ViewportPreset[];

// @public (undocumented)
type PreStackNewImageEvent = CustomEvent_2<PreStackNewImageEventDetail>;

// @public (undocumented)
interface PreStackNewImageEventDetail {
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageIdIndex: number;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
class ProgressiveIterator<T> {
    // (undocumented)
    [Symbol.asyncIterator](): AsyncGenerator<any, void, unknown>;
    constructor(name?: any);
    // (undocumented)
    add(x: T, done?: boolean): void;
    // (undocumented)
    static as(promise: any): any;
    // (undocumented)
    done: any;
    // (undocumented)
    donePromise(): Promise<T>;
    // (undocumented)
    forEach(callback: any, errorCallback: any): Promise<void>;
    // (undocumented)
    generate(processFunction: any, errorCallback?: ErrorCallback_2): Promise<unknown>;
    // (undocumented)
    getDonePromise(): PromiseIterator<T>;
    // (undocumented)
    getNextPromise(): PromiseIterator<T>;
    // (undocumented)
    getRecent(): T;
    // (undocumented)
    name?: string;
    // (undocumented)
    nextPromise(): Promise<T>;
    // (undocumented)
    reject(reason: Error): void;
    // (undocumented)
    resolve(): void;
}

// @public (undocumented)
export class ProgressiveRetrieveImages implements IImagesLoader, IRetrieveConfiguration {
    constructor(imageRetrieveConfiguration: IRetrieveConfiguration);
    // (undocumented)
    static createProgressive: typeof createProgressive;
    // (undocumented)
    static interleavedRetrieveStages: {
        stages: RetrieveStage[];
    };
    // (undocumented)
    loadImages(imageIds: string[], listener: ImageLoadListener): Promise<any>;
    // (undocumented)
    retrieveOptions: Record<string, RetrieveOptions>;
    // (undocumented)
    static sequentialRetrieveStages: {
        stages: RetrieveStage[];
    };
    // (undocumented)
    static singleRetrieveStages: {
        stages: RetrieveStage[];
    };
    // (undocumented)
    stages: RetrieveStage[];
}

// @public (undocumented)
interface PTScaling {
    // (undocumented)
    suvbsa?: number;
    // (undocumented)
    suvbw?: number;
    // (undocumented)
    suvbwToSuvbsa?: number;
    // (undocumented)
    suvbwToSuvlbm?: number;
    // (undocumented)
    suvlbm?: number;
}

// @public (undocumented)
type PublicContourSetData = ContourSetData;

// @public (undocumented)
type PublicSurfaceData = SurfaceData;

// @public (undocumented)
interface PublicViewportInput {
    // (undocumented)
    defaultOptions?: ViewportInputOptions;
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    type: ViewportType;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
type RangeRetrieveOptions = BaseRetrieveOptions & {
    rangeIndex: number;
    chunkSize?: number | ((metadata: any) => number);
};

// @public (undocumented)
interface ReferenceCompatibleOptions {
    // (undocumented)
    asNearbyProjection?: boolean;
    // (undocumented)
    asOverlay?: boolean;
    // (undocumented)
    asVolume?: boolean;
    // (undocumented)
    imageURI?: string;
    // (undocumented)
    withNavigation?: boolean;
    // (undocumented)
    withOrientation?: boolean;
}

// @public (undocumented)
function registerColormap(colormap: ColormapRegistration): void;

// @public (undocumented)
function registerGeometryLoader(scheme: string, geometryLoader: GeometryLoaderFn): void;

// @public (undocumented)
export function registerImageLoader(scheme: string, imageLoader: ImageLoaderFn): void;

// @public (undocumented)
function registerUnknownGeometryLoader(geometryLoader: GeometryLoaderFn): GeometryLoaderFn | undefined;

// @public (undocumented)
function registerUnknownImageLoader(imageLoader: ImageLoaderFn): ImageLoaderFn;

// @public (undocumented)
function registerUnknownVolumeLoader(volumeLoader: VolumeLoaderFn): VolumeLoaderFn | undefined;

// @public (undocumented)
function registerVolumeLoader(scheme: string, volumeLoader: VolumeLoaderFn): void;

// @public (undocumented)
function removeAllProviders(): void;

// @public (undocumented)
function removeProvider(provider: (type: string, query: unknown) => unknown): void;

// @public (undocumented)
const RENDERING_DEFAULTS: {
    MINIMUM_SLAB_THICKNESS: number;
    MAXIMUM_RAY_DISTANCE: number;
};

// @public (undocumented)
export class RenderingEngine {
    constructor(id?: string);
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    _downloadOffScreenCanvas(): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(canvas: HTMLCanvasElement, backgroundColor: [number, number, number]): void;
    // (undocumented)
    getStackViewport(viewportId: string): StackViewport;
    // (undocumented)
    getStackViewports(): StackViewport[];
    // (undocumented)
    getViewport(viewportId: string): IViewport;
    // (undocumented)
    getViewports(): IViewport[];
    // (undocumented)
    getVolumeViewports(): IVolumeViewport[];
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly offScreenCanvasContainer: HTMLDivElement;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference: (FrameOfReferenceUID: string) => void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: string[]): void;
    // (undocumented)
    resize(immediate?: boolean, keepCamera?: boolean): void;
    // (undocumented)
    setViewports(publicViewportInputEntries: PublicViewportInput[]): void;
}

// @public (undocumented)
function renderToCanvasCPU(canvas: HTMLCanvasElement, imageOrVolume: IImage | IVolume, modality?: string, _renderingEngineId?: string, _viewportOptions?: ViewportInputOptions): Promise<CanvasLoadPosition>;

// @public (undocumented)
function renderToCanvasGPU(canvas: HTMLCanvasElement, imageOrVolume: IImage | IVolume, modality?: any, renderingEngineId?: string, viewportOptions?: ViewportInputOptions & {
    viewReference?: ViewReference;
}): Promise<CanvasLoadPosition>;

// @public (undocumented)
enum RequestType {
    // (undocumented)
    Compute = "compute",
    // (undocumented)
    Interaction = "interaction",
    // (undocumented)
    Prefetch = "prefetch",
    // (undocumented)
    Thumbnail = "thumbnail"
}

// @public (undocumented)
export function resetInitialization(): void;

// @public (undocumented)
export function resetUseCPURendering(): void;

// @public (undocumented)
export type RetrieveOptions = BaseRetrieveOptions | StreamingRetrieveOptions | RangeRetrieveOptions;

// @public (undocumented)
export interface RetrieveStage {
    // (undocumented)
    decimate?: number;
    // (undocumented)
    id: string;
    // (undocumented)
    nearbyFrames?: NearbyFrames[];
    // (undocumented)
    offset?: number;
    // (undocumented)
    positions?: number[];
    // (undocumented)
    priority?: number;
    // (undocumented)
    requestType?: RequestType;
    // (undocumented)
    retrieveType?: string;
}

// @public (undocumented)
type RGB = [number, number, number];

// @public (undocumented)
function rgbToHex(r: any, g: any, b: any): string;

// @public (undocumented)
interface RLERun_2<T> {
    // (undocumented)
    end: number;
    // (undocumented)
    start: number;
    // (undocumented)
    value: T;
}

// @public (undocumented)
class RLEVoxelMap<T> {
    constructor(width: number, height: number, depth?: number);
    // (undocumented)
    clear(): void;
    // (undocumented)
    static copyMap<T>(destination: RLEVoxelMap<T>, source: RLEVoxelMap<T>): void;
    // (undocumented)
    defaultValue: T;
    // (undocumented)
    delete(index: number): void;
    // (undocumented)
    depth: number;
    // (undocumented)
    fillFrom(getter: (i: number, j: number, k: number) => T, boundsIJK: BoundsIJK): void;
    // (undocumented)
    findAdjacents(item: [RLERun<T>, number, number, Point3[]?], { diagonals, planar, singlePlane }: {
        diagonals?: boolean;
        planar?: boolean;
        singlePlane?: boolean;
    }): any[];
    // (undocumented)
    protected findIndex(row: RLERun<T>[], i: number): number;
    // (undocumented)
    floodFill(i: number, j: number, k: number, value: T, options?: {
        planar?: boolean;
        diagonals?: boolean;
        singlePlane?: boolean;
    }): number;
    // (undocumented)
    forEach(callback: any, options?: {
        rowModified?: boolean;
    }): void;
    // (undocumented)
    forEachRow(callback: any): void;
    // (undocumented)
    get: (index: number) => T;
    // (undocumented)
    getPixelData(k?: number, pixelData?: PixelDataTypedArray): PixelDataTypedArray;
    // (undocumented)
    protected getRLE(i: number, j: number, k?: number): RLERun<T>;
    // (undocumented)
    getRun: (j: number, k: number) => RLERun<T>[];
    // (undocumented)
    static getScalarData: (ArrayType?: Uint8ClampedArrayConstructor) => Uint8ClampedArray;
    // (undocumented)
    has(index: number): boolean;
    // (undocumented)
    height: number;
    // (undocumented)
    protected jMultiple: number;
    // (undocumented)
    keys(): number[];
    // (undocumented)
    protected kMultiple: number;
    // (undocumented)
    normalizer: PlaneNormalizer;
    // (undocumented)
    protected numComps: number;
    // (undocumented)
    pixelDataConstructor: Uint8ArrayConstructor;
    // (undocumented)
    protected rows: Map<number, RLERun<T>[]>;
    // (undocumented)
    set: (index: number, value: T) => void;
    // (undocumented)
    toIJK(index: number): Point3;
    // (undocumented)
    toIndex([i, j, k]: Point3): number;
    // (undocumented)
    updateScalarData: (scalarData: PixelDataTypedArray) => void;
    // (undocumented)
    width: number;
}

// @public (undocumented)
function roundNumber(value: string | number | (string | number)[], precision?: number): string;

// @public (undocumented)
function roundToPrecision(value: any): number;

// @public (undocumented)
function scaleArray(array: Float32Array | Uint8Array | Uint16Array | Int16Array, scalingParameters: ScalingParameters): Float32Array | Uint8Array | Uint16Array | Int16Array;

// @public (undocumented)
function scaleRGBTransferFunction(rgbTransferFunction: ColorTransferFunction, scalingFactor: number): void;

// @public (undocumented)
interface Scaling {
    // (undocumented)
    PT?: PTScaling;
}

// @public (undocumented)
interface ScalingParameters {
    // (undocumented)
    modality: string;
    // (undocumented)
    rescaleIntercept: number;
    // (undocumented)
    rescaleSlope: number;
    // (undocumented)
    suvbsa?: number;
    // (undocumented)
    suvbw?: number;
    // (undocumented)
    suvlbm?: number;
}

// @public (undocumented)
function scroll_2(viewport: IViewport | IVideoViewport, options: ScrollOptions_2): void;

// @public (undocumented)
type ScrollOptions_2 = {
    delta: number;
    volumeId?: string;
    debounceLoading?: boolean;
    loop?: boolean;
    scrollSlabs?: boolean;
};

// @public (undocumented)
export function setConfiguration(c: Cornerstone3DConfig): void;

// @public (undocumented)
export function setPreferSizeOverAccuracy(status: boolean): void;

// @public (undocumented)
export class Settings {
    constructor(base?: Settings);
    // (undocumented)
    static assert(subject: Settings): Settings;
    // (undocumented)
    dump(): Record<string, unknown>;
    // (undocumented)
    extend(): Settings;
    // (undocumented)
    static extendRuntimeSettings(): Settings;
    // (undocumented)
    forEach(callback: (key: string, value: unknown) => void): void;
    // (undocumented)
    get(key: string): unknown;
    // (undocumented)
    static getDefaultSettings(subfield?: any): Settings | unknown;
    // (undocumented)
    static getObjectSettings(subject: unknown, from?: unknown): Settings;
    // (undocumented)
    static getRuntimeSettings(): Settings;
    // (undocumented)
    import(root: Record<string, unknown>): void;
    // (undocumented)
    set(key: string, value: unknown): boolean;
    // (undocumented)
    unset(key: string): boolean;
}

// @public (undocumented)
function setTransferFunctionNodes(transferFunction: any, nodes: any): void;

// @public (undocumented)
export function setUseCPURendering(status: boolean, updateViewports?: boolean): void;

// @public (undocumented)
export function setVolumesForViewports(renderingEngine: IRenderingEngine, volumeInputs: IVolumeInput[], viewportIds: string[], immediateRender?: boolean, suppressEvents?: boolean): Promise<void>;

// @public (undocumented)
function snapFocalPointToSlice(focalPoint: Point3, position: Point3, sliceRange: ActorSliceRange, viewPlaneNormal: Point3, spacingInNormalDirection: number, deltaFrames: number): {
    newFocalPoint: Point3;
    newPosition: Point3;
};

// @public (undocumented)
interface SopCommonModuleMetadata {
    // (undocumented)
    sopClassUID: string;
    // (undocumented)
    sopInstanceUID: string;
}

// @public (undocumented)
function sortImageIdsAndGetSpacing(imageIds: string[], scanAxisNormal?: vec3): SortedImageIdsItem;

// @public (undocumented)
const spatialRegistrationMetadataProvider: {
    add: (query: string[], payload: mat4) => void;
    get: (type: string, viewportId1: string, viewportId2: string) => mat4;
};

// @public (undocumented)
enum SpeedUnit {
    // (undocumented)
    FRAME = "f",
    // (undocumented)
    SECOND = "s"
}

// @public (undocumented)
function splitImageIdsBy4DTags(imageIds: string[]): {
    imageIdGroups: string[][];
    splittingTag: string | null;
};

// @public (undocumented)
type StackInputCallback = (params: {
    imageActor: ImageActor;
    imageId: string;
}) => unknown;

// @public (undocumented)
type StackNewImageEvent = CustomEvent_2<StackNewImageEventDetail>;

// @public (undocumented)
interface StackNewImageEventDetail {
    // (undocumented)
    image: IImage;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageIdIndex: number;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
type StackScrollOutOfBoundsEvent = CustomEvent_2<StackScrollOutOfBoundsEventDetail>;

// @public (undocumented)
type StackScrollOutOfBoundsEventDetail = {
    imageIdIndex: number;
    direction: number;
};

// @public (undocumented)
export class StackViewport extends Viewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addActor: (actorEntry: ActorEntry) => void;
    // (undocumented)
    addActors: (actors: ActorEntry[]) => void;
    // (undocumented)
    addImages(stackInputs: IStackInput[]): void;
    // (undocumented)
    calibrateSpacing(imageId: string): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    clearDefaultProperties(imageId?: string): void;
    // (undocumented)
    createVTKImageData({ origin, direction, dimensions, spacing, numberOfComponents, pixelArray, }: {
        origin: any;
        direction: any;
        dimensions: any;
        spacing: any;
        numberOfComponents: any;
        pixelArray: any;
    }): vtkImageData;
    // (undocumented)
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
        viewportStatus: ViewportStatus;
    };
    // (undocumented)
    errorCallback(imageId: any, permanent: any, error: any): void;
    // (undocumented)
    getActor: (actorUID: string) => ActorEntry;
    // (undocumented)
    getActors: () => ActorEntry[];
    // (undocumented)
    getCamera: () => ICamera;
    // (undocumented)
    getCornerstoneImage: () => IImage;
    // (undocumented)
    getCurrentImageId: (index?: number) => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getDefaultActor: () => ActorEntry;
    // (undocumented)
    getDefaultProperties: (imageId?: string) => StackViewportProperties;
    // (undocumented)
    getFrameOfReferenceUID: (sliceIndex?: number) => string;
    // (undocumented)
    getImageData: () => IImageData | CPUIImageData;
    // (undocumented)
    getImageDataMetadata(image: IImage): ImageDataMetaData;
    // (undocumented)
    getImageIds: () => string[];
    // (undocumented)
    getImagePlaneReferenceData(sliceIndex?: number): ViewReference;
    // (undocumented)
    getLoaderImageOptions(imageId: string): {
        useRGBA: boolean;
        transferSyntaxUID: any;
        priority: number;
        requestType: RequestType;
        additionalDetails: {
            imageId: string;
            imageIdIndex: number;
        };
    };
    // (undocumented)
    getNumberOfSlices: () => number;
    // (undocumented)
    getProperties: () => StackViewportProperties;
    // (undocumented)
    getRenderer: () => vtkRenderer;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getSliceIndex: () => number;
    // (undocumented)
    getSliceIndexForImage(reference: string | ViewReference): number;
    // (undocumented)
    getSliceInfo(): {
        sliceIndex: number;
        slicePlane: number;
        width: number;
        height: number;
    };
    // (undocumented)
    getSliceViewInfo(): {
        width: number;
        height: number;
        sliceIndex: number;
        slicePlane: number;
        sliceToIndexMatrix: mat4;
        indexToSliceMatrix: mat4;
    };
    // (undocumented)
    getTargetImageIdIndex: () => number;
    // (undocumented)
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    // (undocumented)
    getViewReferenceId(specifier?: ViewReferenceSpecifier): string;
    // (undocumented)
    hasImageId: (imageId: string) => boolean;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    protected imagesLoader: IImagesLoader;
    // (undocumented)
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    // (undocumented)
    jumpToWorld(worldPos: Point3): boolean;
    // (undocumented)
    loadImages(imageIds: string[], listener: ImageLoadListener): Promise<unknown>;
    // (undocumented)
    modality: string;
    // (undocumented)
    removeAllActors: () => void;
    // (undocumented)
    renderImageObject: (image: any) => void;
    // (undocumented)
    resetCamera: (options?: {
        resetPan?: boolean;
        resetZoom?: boolean;
        resetToCenter?: boolean;
        suppressEvents?: boolean;
    }) => boolean;
    // (undocumented)
    resetCameraForResize: () => boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resetToDefaultProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scaling: Scaling;
    // (undocumented)
    scroll(delta: number, debounce?: boolean, loop?: boolean): void;
    // (undocumented)
    setActors: (actors: ActorEntry[]) => void;
    // (undocumented)
    setCamera: (cameraInterface: ICamera, storeAsInitialCamera?: boolean) => void;
    // (undocumented)
    setDefaultProperties(ViewportProperties: StackViewportProperties, imageId?: string): void;
    // (undocumented)
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    // (undocumented)
    protected setInterpolationType: (interpolationType: InterpolationType) => void;
    // (undocumented)
    setProperties({ colormap, voiRange, VOILUTFunction, invert, interpolationType, }?: StackViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    protected setRotation: (rotation: number) => void;
    // (undocumented)
    setStack(imageIds: string[], currentImageIdIndex?: number): Promise<string>;
    // (undocumented)
    setUseCPURendering(value: boolean): void;
    // (undocumented)
    setViewReference(viewRef: ViewReference): void;
    // (undocumented)
    stackActorReInitialized: boolean;
    // (undocumented)
    successCallback(imageId: any, image: any): void;
    // (undocumented)
    unsetColormap: () => void;
    // (undocumented)
    updateRenderingPipeline: () => void;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
type StackViewportNewStackEvent = CustomEvent_2<StackViewportNewStackEventDetail>;

// @public (undocumented)
interface StackViewportNewStackEventDetail {
    // (undocumented)
    currentImageIdIndex: number;
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    imageIds: string[];
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
type StackViewportProperties = ViewportProperties & {
    interpolationType?: InterpolationType;
    suppressEvents?: boolean;
    isComputedVOI?: boolean;
};

// @public (undocumented)
type StackViewportScrollEvent = CustomEvent_2<StackViewportScrollEventDetail>;

// @public (undocumented)
interface StackViewportScrollEventDetail {
    // (undocumented)
    direction: number;
    // (undocumented)
    imageId: string;
    // (undocumented)
    newImageIdIndex: number;
}

// @public (undocumented)
export class StreamingDynamicImageVolume extends BaseStreamingImageVolume implements IDynamicImageVolume {
    constructor(imageVolumeProperties: ImageVolumeProps & {
        splittingTag: string;
        imageIdGroups: string[][];
    }, streamingProperties: IStreamingVolumeProperties);
    // (undocumented)
    protected checkDimensionGroupCompletion(imageIdIndex: number): void;
    // (undocumented)
    protected checkTimePointCompletion(imageIdIndex: number): void;
    // (undocumented)
    get dimensionGroupNumber(): number;
    set dimensionGroupNumber(dimensionGroupNumber: number);
    // (undocumented)
    flatImageIdIndexToDimensionGroupNumber(flatImageIdIndex: number): number;
    // (undocumented)
    flatImageIdIndexToImageIdIndex(flatImageIdIndex: number): number;
    // (undocumented)
    flatImageIdIndexToTimePointIndex(flatImageIdIndex: number): number;
    // (undocumented)
    getCurrentDimensionGroupImageIds(): string[];
    // (undocumented)
    getCurrentTimePointImageIds(): string[];
    // (undocumented)
    getImageIdsToLoad(): string[];
    // (undocumented)
    getImageLoadRequests: (priority: number) => {
        callLoadImage: (imageId: any, imageIdIndex: any, options: any) => any;
        imageId: string;
        imageIdIndex: number;
        options: {
            targetBuffer: {
                type: PixelDataTypedArrayString;
                rows: any;
                columns: any;
            };
            allowFloatRendering: boolean;
            preScale: {
                enabled: boolean;
                scalingParameters: ScalingParameters;
            };
            transferPixelData: boolean;
            requestType: RequestType;
            transferSyntaxUID: any;
            additionalDetails: {
                imageId: string;
                imageIdIndex: number;
                volumeId: string;
            };
        };
        priority: number;
        requestType: RequestType;
        additionalDetails: {
            volumeId: string;
        };
    }[];
    // (undocumented)
    isDimensionGroupLoaded(dimensionGroupNumber: number): boolean;
    // (undocumented)
    isTimePointLoaded(timePointIndex: number): boolean;
    // (undocumented)
    numDimensionGroups: number;
    // (undocumented)
    numTimePoints: number;
    // (undocumented)
    scroll(delta: number): void;
    // (undocumented)
    get splittingTag(): string;
    set timePointIndex(index: number);
    // (undocumented)
    get timePointIndex(): number;
}

// @public (undocumented)
export class StreamingImageVolume extends BaseStreamingImageVolume {
    constructor(imageVolumeProperties: ImageVolumeProps, streamingProperties: IStreamingVolumeProperties);
    // (undocumented)
    getImageIdsToLoad: () => string[];
    // (undocumented)
    getImageLoadRequests(priority: number): ImageLoadRequests[];
    // (undocumented)
    getScalarData(): PixelDataTypedArray;
}

// @public (undocumented)
type StreamingRetrieveOptions = BaseRetrieveOptions & {
    streaming: boolean;
};

// @public (undocumented)
export class Surface {
    constructor(props: SurfaceProps);
    // (undocumented)
    get centroid(): Point3;
    // (undocumented)
    get color(): RGB;
    set color(color: RGB);
    // (undocumented)
    get flatPointsArray(): number[];
    // (undocumented)
    readonly frameOfReferenceUID: string;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    get points(): number[];
    set points(points: number[]);
    // (undocumented)
    get polys(): number[];
    set polys(polys: number[]);
    // (undocumented)
    get segmentIndex(): number;
    // (undocumented)
    readonly sizeInBytes: number;
    // (undocumented)
    get totalNumberOfPoints(): number;
}

// @public (undocumented)
interface SurfaceData {
    // (undocumented)
    color?: Point3;
    // (undocumented)
    frameOfReferenceUID: string;
    // (undocumented)
    id: string;
    // (undocumented)
    points: number[];
    // (undocumented)
    polys: number[];
    // (undocumented)
    segmentIndex?: number;
}

// @public (undocumented)
class TargetEventListeners {
    constructor(target: EventTarget);
    // (undocumented)
    addEventListener(type: string, callback: EventListener, options?: AddEventListenerOptions): void;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    removeEventListener(type: string, callback?: EventListener, options?: EventListenerOptions): void;
    // (undocumented)
    reset(): void;
}

// @public (undocumented)
function threePlaneIntersection(firstPlane: Plane, secondPlane: Plane, thirdPlane: Plane): Point3;

// @public (undocumented)
function toLowHighRange(windowWidth: number, windowCenter: number, voiLUTFunction?: VOILUTFunctionType): {
    lower: number;
    upper: number;
};

// @public (undocumented)
function toWindowLevel(low: number, high: number): {
    windowWidth: number;
    windowCenter: number;
};

declare namespace transferFunctionUtils {
    export {
        getTransferFunctionNodes,
        setTransferFunctionNodes
    }
}

// @public (undocumented)
interface TransferSyntaxMetadata {
    // (undocumented)
    transferSyntaxUID: string;
}

// @public (undocumented)
function transformIndexToWorld(imageData: any, voxelPos: Point3): any;

// @public (undocumented)
type TransformMatrix2D = [number, number, number, number, number, number];

// @public (undocumented)
function transformWorldToIndex(imageData: any, worldPos: Point3): any;

// @public (undocumented)
function transformWorldToIndexContinuous(imageData: any, worldPos: Point3): any;

// @public (undocumented)
export function triggerEvent(el: EventTarget, type: string, detail?: unknown): boolean;

declare namespace Types {
    export {
        RetrieveStage,
        RetrieveOptions,
        RangeRetrieveOptions,
        StreamingRetrieveOptions,
        NearbyFrames,
        IRetrieveConfiguration,
        IImagesLoader,
        Cornerstone3DConfig,
        ICamera,
        StackViewport as IStackViewport,
        IVideoViewport,
        IWSIViewport,
        IVolumeViewport,
        IEnabledElement,
        ICache,
        IVolume,
        IViewportId,
        IImageVolume,
        ImageVolumeProps,
        IDynamicImageVolume,
        IRenderingEngine,
        ScalingParameters,
        PTScaling,
        IPointsManager,
        PolyDataPointConfiguration,
        Scaling,
        IStreamingImageVolume,
        IImage,
        IImageData,
        IImageCalibration,
        CPUIImageData,
        CPUImageData,
        EventTypes,
        ImageLoaderFn,
        VolumeLoaderFn,
        IRegisterImageLoader,
        IStreamingVolumeProperties,
        IViewport,
        ViewReference,
        DataSetOptions as ImageSetOptions,
        ViewPresentation,
        ViewPresentationSelector,
        ReferenceCompatibleOptions,
        ViewReferenceSpecifier,
        StackViewportProperties,
        VolumeViewportProperties,
        ViewportProperties,
        PublicViewportInput,
        VolumeActor,
        Actor,
        ActorEntry,
        ImageActor,
        ICanvasActor,
        IImageLoadObject,
        IVolumeLoadObject,
        IVolumeInput,
        VolumeInputCallback,
        IStackInput,
        StackInputCallback,
        ViewportPreset,
        Metadata,
        OrientationVectors,
        AABB2,
        AABB3,
        Point2,
        Point3,
        PointsXYZ,
        Point4,
        Mat3,
        Plane,
        ViewportInputOptions,
        VideoViewportProperties,
        WSIViewportProperties,
        VOIRange,
        VOI,
        DisplayArea,
        FlipDirection,
        ICachedImage,
        ICachedVolume,
        CPUFallbackEnabledElement,
        CPUFallbackViewport,
        CPUFallbackTransform,
        CPUFallbackColormapData,
        CPUFallbackViewportDisplayedArea,
        CPUFallbackColormapsData,
        CPUFallbackColormap,
        TransformMatrix2D,
        CPUFallbackLookupTable,
        CPUFallbackLUT,
        CPUFallbackRenderingTools,
        CustomEvent_2 as CustomEventType,
        ActorSliceRange,
        ImageSliceData,
        IGeometry,
        IGeometryLoadObject,
        ICachedGeometry,
        PublicContourSetData,
        ContourSetData,
        ContourData,
        IContourSet,
        IContour,
        PublicSurfaceData,
        SurfaceData,
        ISurface,
        RGB,
        ColormapPublic,
        ColormapRegistration,
        PixelDataTypedArray,
        PixelDataTypedArrayString,
        ImagePixelModule,
        ImagePlaneModule,
        AffineMatrix,
        ImageLoadListener,
        InternalVideoCamera,
        VideoViewportInput,
        BoundsIJK,
        BoundsLPS,
        Color,
        ColorLUT,
        VolumeProps,
        ImageFrame as IImageFrame,
        DicomDateObject,
        DicomTimeObject,
        GeneralSeriesModuleMetadata,
        ImagePlaneModuleMetadata,
        SopCommonModuleMetadata,
        ImagePixelModuleMetadata,
        PatientStudyModuleMetadata,
        TransferSyntaxMetadata,
        LocalVolumeOptions,
        IVoxelManager,
        IRLEVoxelMap,
        RLERun_2 as RLERun,
        ViewportInput,
        ImageLoadRequests,
        IBaseVolumeViewport,
        GeometryLoaderFn,
        ScrollOptions_2 as ScrollOptions,
        JumpToSliceOptions,
        Memo,
        HistoryMemo,
        VoxelManager,
        RLEVoxelMap
    }
}
export { Types }

// @public (undocumented)
function unregisterAllImageLoaders(): void;

// @public (undocumented)
function updateVTKImageDataWithCornerstoneImage(sourceImageData: vtkImageData, image: IImage): void;

declare namespace utilities {
    export {
        FrameRange,
        eventListener,
        invertRgbTransferFunction,
        createSigmoidRGBTransferFunction,
        getVoiFromSigmoidRGBTransferFunction,
        createLinearRGBTransferFunction,
        scaleRGBTransferFunction as scaleRgbTransferFunction,
        triggerEvent,
        imageIdToURI,
        metadataProvider as calibratedPixelSpacingMetadataProvider,
        clamp,
        uuidv4,
        planar,
        getMinMax,
        getRuntimeId,
        isEqual,
        isEqualAbs,
        isEqualNegative,
        isOpposite,
        getViewportModality,
        windowLevel,
        convertToGrayscale,
        getClosestImageId,
        getSpacingInNormalDirection,
        getTargetVolumeAndSpacingInNormalDir,
        getVolumeActorCorners,
        indexWithinDimensions,
        getVolumeViewportsContainingSameVolumes,
        getViewportsWithVolumeId,
        transformWorldToIndex,
        transformIndexToWorld,
        loadImageToCanvas,
        renderToCanvasCPU,
        renderToCanvasGPU,
        worldToImageCoords,
        imageToWorldCoords,
        getVolumeSliceRangeInfo,
        getVolumeViewportScrollInfo,
        getSliceRange,
        snapFocalPointToSlice,
        getImageSliceDataForVolumeViewport,
        isImageActor,
        isPTPrescaledWithSUV,
        actorIsA,
        getViewportsWithImageURI,
        getClosestStackImageIndexForPoint,
        getCurrentVolumeViewportSlice,
        calculateViewportsSpatialRegistration,
        spatialRegistrationMetadataProvider,
        getViewportImageCornersInWorld,
        hasNaNValues,
        applyPreset,
        deepMerge,
        PointsManager,
        getScalingParameters,
        colormap,
        getImageLegacy,
        ProgressiveIterator,
        decimate,
        imageRetrieveMetadataProvider,
        transferFunctionUtils,
        updateVTKImageDataWithCornerstoneImage,
        sortImageIdsAndGetSpacing,
        makeVolumeMetadata,
        isValidVolume,
        metadataProvider_2 as genericMetadataProvider,
        isVideoTransferSyntax,
        HistoryMemo_2 as HistoryMemo,
        generateVolumePropsFromImageIds,
        getBufferConfiguration,
        VoxelManager,
        RLEVoxelMap,
        convertStackToVolumeViewport,
        convertVolumeToStackViewport,
        roundNumber,
        roundToPrecision,
        getViewportImageIds,
        getRandomSampleFromArray,
        getVolumeId,
        color,
        hasFloatScalingParameters,
        getDynamicVolumeInfo,
        autoLoad,
        scaleArray,
        deepClone,
        splitImageIdsBy4DTags,
        pointInShapeCallback,
        deepEqual,
        jumpToSlice,
        scroll_2 as scroll,
        clip,
        transformWorldToIndexContinuous,
        createSubVolume,
        getVolumeDirectionVectors
    }
}
export { utilities }

// @public (undocumented)
function uuidv4(): string;

declare namespace VideoEnums {
    export {
        SpeedUnit
    }
}

// @public (undocumented)
export class VideoViewport extends Viewport {
    constructor(props: VideoViewportInput);
    // (undocumented)
    addImages(stackInputs: IStackInput[]): void;
    // (undocumented)
    readonly canvasContext: CanvasRenderingContext2D;
    // (undocumented)
    protected canvasToIndex: (canvasPos: Point2) => Point2;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2, destPos?: Point3) => Point3;
    // (undocumented)
    protected createActorMapper(image: any): CanvasActor;
    // (undocumented)
    customRenderViewportToCanvas: () => void;
    // (undocumented)
    end(): Promise<void>;
    // (undocumented)
    static frameRangeExtractor: RegExp;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCurrentImageId(index?: number): string;
    // (undocumented)
    getCurrentImageIdIndex(): number;
    // (undocumented)
    getFrameNumber(): number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getFrameRange(): [number, number];
    // (undocumented)
    getFrameRate(): number;
    // (undocumented)
    getImageData(): IImageData | CPUIImageData;
    // (undocumented)
    getImageDataMetadata(image: IImage | string): {
        bitsAllocated: number;
        numberOfComponents: number;
        origin: any;
        rows: any;
        columns: any;
        direction: number[];
        dimensions: any[];
        spacing: any[];
        hasPixelSpacing: boolean;
        numVoxels: number;
        imagePlaneModule: any;
    };
    // (undocumented)
    getImageIds(): string[];
    // (undocumented)
    getMiddleSliceData: () => never;
    // (undocumented)
    getNumberOfSlices: () => number;
    // (undocumented)
    getPan(): Point2;
    // (undocumented)
    getProperties: () => VideoViewportProperties;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    protected getScalarData(): CanvasScalarData;
    // (undocumented)
    getSliceIndex(): number;
    // (undocumented)
    getSliceIndexForImage(reference: string | ViewReference): number;
    // (undocumented)
    getSliceViewInfo(): {
        width: number;
        height: number;
        sliceIndex: number;
        slicePlane: number;
        sliceToIndexMatrix: mat4;
        indexToSliceMatrix: mat4;
    };
    // (undocumented)
    protected getTransform(): Transform;
    // (undocumented)
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    // (undocumented)
    getViewReferenceId(specifier?: ViewReferenceSpecifier): string;
    // (undocumented)
    hasImageURI(imageURI: string): boolean;
    // (undocumented)
    protected imageId: string;
    // (undocumented)
    protected indexToCanvas: (indexPos: Point2) => Point2;
    // (undocumented)
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    // (undocumented)
    protected metadata: any;
    // (undocumented)
    modality: any;
    // (undocumented)
    pause(): void;
    // (undocumented)
    play(): Promise<void>;
    // (undocumented)
    readonly renderingEngineId: string;
    // (undocumented)
    resetCamera: () => boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scroll(delta?: number): Promise<void>;
    // (undocumented)
    setAverageWhite(averageWhite: [number, number, number]): void;
    // (undocumented)
    setCamera(camera: ICamera): void;
    // (undocumented)
    protected setColorTransform(): void;
    // (undocumented)
    setDataIds(imageIds: string[], options?: DataSetOptions): void;
    // (undocumented)
    setFrameNumber(frame: number): Promise<void>;
    // (undocumented)
    setFrameRange(frameRange: number[]): void;
    // (undocumented)
    setPlaybackRate(rate?: number): void;
    // (undocumented)
    setProperties(props: VideoViewportProperties): void;
    // (undocumented)
    setScrollSpeed(scrollSpeed?: number, unit?: VideoEnums.SpeedUnit): void;
    // (undocumented)
    setTime(timeInSeconds: number): Promise<void>;
    // (undocumented)
    setVideo(imageId: string, frameNumber?: number): Promise<unknown>;
    // (undocumented)
    setViewReference(viewRef: ViewReference): void;
    // (undocumented)
    setVOI(voiRange: VOIRange): void;
    // (undocumented)
    setWindowLevel(windowWidth?: number, windowCenter?: number): void;
    // (undocumented)
    start(): Promise<void>;
    // (undocumented)
    togglePlayPause(): boolean;
    // (undocumented)
    readonly uid: any;
    // (undocumented)
    updateCameraClippingPlanesAndRange(): void;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    useCustomRenderingPipeline: boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
interface VideoViewportInput {
    // (undocumented)
    canvas: HTMLCanvasElement;
    // (undocumented)
    defaultOptions: unknown;
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    id: string;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    sHeight: number;
    // (undocumented)
    sWidth: number;
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    type: ViewportType;
}

// @public (undocumented)
type VideoViewportProperties = ViewportProperties & {
    loop?: boolean;
    muted?: boolean;
    pan?: Point2;
    playbackRate?: number;
    scrollSpeed?: number;
};

// @public (undocumented)
export class Viewport {
    constructor(props: ViewportInput);
    // (undocumented)
    _actors: Map<string, ActorEntry>;
    // (undocumented)
    addActor(actorEntry: ActorEntry): void;
    // (undocumented)
    addActors(actors: ActorEntry[], options?: {
        resetCamera?: boolean;
    }): void;
    // (undocumented)
    addWidget: (widgetId: any, widget: any) => void;
    // (undocumented)
    static boundsRadius(bounds: number[]): number;
    // (undocumented)
    protected calibration: IImageCalibration;
    // (undocumented)
    static readonly CameraViewPresentation: ViewPresentationSelector;
    // (undocumented)
    readonly canvas: HTMLCanvasElement;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => unknown;
    // (undocumented)
    readonly defaultOptions: ViewportInputOptions;
    // (undocumented)
    readonly element: HTMLDivElement;
    // (undocumented)
    protected fitToCanvasCamera: ICamera;
    // (undocumented)
    protected flip({ flipHorizontal, flipVertical }: FlipDirection): void;
    // (undocumented)
    protected flipHorizontal: boolean;
    // (undocumented)
    protected flipVertical: boolean;
    // (undocumented)
    getActor(actorUID: string): ActorEntry;
    // (undocumented)
    getActorByIndex(index: number): ActorEntry;
    // (undocumented)
    getActors(): ActorEntry[];
    // (undocumented)
    getActorUIDByIndex(index: number): string;
    // (undocumented)
    getActorUIDs(): string[];
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    protected getCameraNoRotation(): ICamera;
    // (undocumented)
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    getClippingPlanesForActor(actorEntry?: ActorEntry): vtkPlane[];
    // (undocumented)
    _getCorners(bounds: number[]): number[][];
    // (undocumented)
    getCurrentImageIdIndex(): number;
    // (undocumented)
    getDefaultActor(): ActorEntry;
    // (undocumented)
    getDisplayArea(): DisplayArea | undefined;
    // (undocumented)
    _getEdges(bounds: number[]): [number[], number[]][];
    // (undocumented)
    _getFocalPointForResetCamera(centeredFocalPoint: Point3, previousCamera: ICamera, { resetPan, resetToCenter }: {
        resetPan?: boolean;
        resetToCenter?: boolean;
    }): Point3;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageActor(volumeId?: string): ImageActor | null;
    // (undocumented)
    getImageData(): any;
    // (undocumented)
    getNumberOfSlices: () => number;
    // (undocumented)
    getPan(initialCamera?: ICamera): Point2;
    // (undocumented)
    getProperties: () => ViewportProperties;
    // (undocumented)
    getRenderer(): vtkRenderer;
    // (undocumented)
    getRenderingEngine(): IRenderingEngine;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getSliceIndex(): number;
    // (undocumented)
    getSliceViewInfo(): {
        width: number;
        height: number;
        sliceIndex: number;
        slicePlane: number;
        sliceToIndexMatrix: mat4;
        indexToSliceMatrix: mat4;
    };
    // (undocumented)
    getViewPresentation(viewPresSel?: ViewPresentationSelector): ViewPresentation;
    // (undocumented)
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    // (undocumented)
    getViewReferenceId(_specifier?: ViewReferenceSpecifier): string;
    // (undocumented)
    protected getVtkActiveCamera(): vtkCamera | vtkSlabCamera;
    // (undocumented)
    getWidget: (id: any) => any;
    // (undocumented)
    getWidgets: () => any[];
    // (undocumented)
    getZoom(compareCamera?: ICamera): number;
    // (undocumented)
    protected hasPixelSpacing: boolean;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    protected initialCamera: ICamera;
    // (undocumented)
    protected insetImageMultiplier: number;
    // (undocumented)
    isDisabled: boolean;
    // (undocumented)
    _isInBounds(point: Point3, bounds: number[]): boolean;
    // (undocumented)
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    // (undocumented)
    options: ViewportInputOptions;
    // (undocumented)
    _removeActor(actorUID: string): void;
    // (undocumented)
    removeActors(actorUIDs: string[]): void;
    // (undocumented)
    removeAllActors(): void;
    // (undocumented)
    removeWidgets: () => void;
    // (undocumented)
    render(): void;
    // (undocumented)
    readonly renderingEngineId: string;
    // (undocumented)
    reset(immediate?: boolean): void;
    // (undocumented)
    resetCamera(options?: {
        resetPan?: boolean;
        resetZoom?: boolean;
        resetToCenter?: boolean;
        storeAsInitialCamera?: boolean;
    }): boolean;
    // (undocumented)
    protected resetCameraNoEvent(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    setActors(actors: ActorEntry[]): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    protected setCameraNoEvent(camera: ICamera): void;
    // (undocumented)
    setDataIds(_imageIds: string[], _options?: DataSetOptions): void;
    // (undocumented)
    setDisplayArea(displayArea: DisplayArea, suppressEvents?: boolean): void;
    // (undocumented)
    protected setDisplayAreaFit(displayArea: DisplayArea): void;
    // (undocumented)
    protected setDisplayAreaScale(displayArea: DisplayArea): void;
    // (undocumented)
    protected setFitToCanvasCamera(camera: ICamera): void;
    // (undocumented)
    protected setInitialCamera(camera: ICamera): void;
    // (undocumented)
    protected setInterpolationType(_interpolationType: InterpolationType, _arg?: any): void;
    // (undocumented)
    setOptions(options: ViewportInputOptions, immediate?: boolean): void;
    // (undocumented)
    setOrientationOfClippingPlanes(vtkPlanes: vtkPlane[], slabThickness: number, viewPlaneNormal: Point3, focalPoint: Point3): void;
    // (undocumented)
    setPan(pan: Point2, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    setRendered(): void;
    // (undocumented)
    protected setRotation: (_rotation: number) => void;
    // (undocumented)
    setViewPresentation(viewPres: ViewPresentation): void;
    // (undocumented)
    setViewReference(viewRef: ViewReference): void;
    // (undocumented)
    setZoom(value: number, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    sHeight: number;
    // (undocumented)
    _suppressCameraModifiedEvents: boolean;
    // (undocumented)
    readonly suppressEvents: boolean;
    // (undocumented)
    sWidth: number;
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    static readonly TransferViewPresentation: ViewPresentationSelector;
    // (undocumented)
    triggerCameraModifiedEventIfNecessary(previousCamera: ICamera, updatedCamera: ICamera): void;
    // (undocumented)
    readonly type: ViewportType;
    // (undocumented)
    updateCameraClippingPlanesAndRange(): void;
    // (undocumented)
    protected updateClippingPlanesForActors(updatedCamera: ICamera): Promise<void>;
    // (undocumented)
    updateRenderingPipeline: () => void;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    viewportStatus: ViewportStatus;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
interface ViewportInput {
    // (undocumented)
    canvas: HTMLCanvasElement;
    // (undocumented)
    defaultOptions: ViewportInputOptions;
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    id: string;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    sHeight: number;
    // (undocumented)
    sWidth: number;
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    type: ViewportType;
}

// @public (undocumented)
interface ViewportInputOptions {
    // (undocumented)
    background?: RGB;
    // (undocumented)
    displayArea?: DisplayArea;
    // (undocumented)
    orientation?: OrientationAxis | OrientationVectors;
    // (undocumented)
    parallelProjection?: boolean;
    // (undocumented)
    suppressEvents?: boolean;
}

// @public (undocumented)
interface ViewportPreset {
    // (undocumented)
    ambient: string;
    // (undocumented)
    colorTransfer: string;
    // (undocumented)
    diffuse: string;
    // (undocumented)
    gradientOpacity: string;
    // (undocumented)
    interpolation: string;
    // (undocumented)
    name: string;
    // (undocumented)
    scalarOpacity: string;
    // (undocumented)
    shade: string;
    // (undocumented)
    specular: string;
    // (undocumented)
    specularPower: string;
}

// @public (undocumented)
interface ViewportProperties {
    // (undocumented)
    colormap?: ColormapPublic;
    // (undocumented)
    interpolationType?: InterpolationType;
    // (undocumented)
    invert?: boolean;
    // (undocumented)
    preset?: string;
    // (undocumented)
    VOILUTFunction?: VOILUTFunctionType;
    // (undocumented)
    voiRange?: VOIRange;
}

// @public (undocumented)
enum ViewportStatus {
    // (undocumented)
    LOADING = "loading",
    // (undocumented)
    NO_DATA = "noData",
    // (undocumented)
    PRE_RENDER = "preRender",
    // (undocumented)
    RENDERED = "rendered",
    // (undocumented)
    RESIZE = "resize"
}

// @public (undocumented)
enum ViewportType {
    // (undocumented)
    ORTHOGRAPHIC = "orthographic",
    // (undocumented)
    PERSPECTIVE = "perspective",
    // (undocumented)
    STACK = "stack",
    // (undocumented)
    VIDEO = "video",
    // (undocumented)
    VOLUME_3D = "volume3d",
    // (undocumented)
    WHOLE_SLIDE = "wholeSlide"
}

// @public (undocumented)
interface ViewPresentation {
    // (undocumented)
    displayArea?: DisplayArea;
    // (undocumented)
    flipHorizontal?: boolean;
    // (undocumented)
    flipVertical?: boolean;
    // (undocumented)
    pan?: Point2;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    slabThickness?: number;
    // (undocumented)
    zoom?: number;
}

// @public (undocumented)
interface ViewPresentationSelector {
    // (undocumented)
    displayArea?: boolean;
    // (undocumented)
    flipHorizontal?: boolean;
    // (undocumented)
    flipVertical?: boolean;
    // (undocumented)
    paletteLut?: boolean;
    // (undocumented)
    pan?: boolean;
    // (undocumented)
    rotation?: boolean;
    // (undocumented)
    slabThickness?: number;
    // (undocumented)
    windowLevel?: boolean;
    // (undocumented)
    zoom?: boolean;
}

// @public (undocumented)
type ViewReference = {
    FrameOfReferenceUID?: string;
    referencedImageId?: string;
    referencedImageURI?: string;
    multiSliceReference?: ReferencedImageRange;
    cameraFocalPoint?: Point3;
    viewPlaneNormal?: Point3;
    viewUp?: Point3;
    sliceIndex?: number;
    volumeId?: string;
    bounds?: BoundsLPS;
};

// @public (undocumented)
type ViewReferenceSpecifier = {
    sliceIndex?: number;
    rangeEndSliceIndex?: number;
    frameNumber?: number;
    forFrameOfReference?: boolean;
    points?: Point3[];
    volumeId?: string;
};

// @public (undocumented)
interface VOI {
    // (undocumented)
    windowCenter: number;
    // (undocumented)
    windowWidth: number;
}

// @public (undocumented)
enum VOILUTFunctionType {
    // (undocumented)
    LINEAR = "LINEAR",
    // (undocumented)
    LINEAR_EXACT = "LINEAR_EXACT",
    // (undocumented)
    SAMPLED_SIGMOID = "SIGMOID"
}

// @public (undocumented)
type VoiModifiedEvent = CustomEvent_2<VoiModifiedEventDetail>;

// @public (undocumented)
interface VoiModifiedEventDetail {
    // (undocumented)
    colormap?: ColormapPublic;
    // (undocumented)
    invert?: boolean;
    // (undocumented)
    invertStateChanged?: boolean;
    // (undocumented)
    range: VOIRange;
    // (undocumented)
    viewportId: string;
    // (undocumented)
    VOILUTFunction?: VOILUTFunctionType;
    // (undocumented)
    volumeId?: string;
}

// @public (undocumented)
interface VOIRange {
    // (undocumented)
    lower: number;
    // (undocumented)
    upper: number;
}

// @public (undocumented)
type VolumeActor = vtkVolume;

// @public (undocumented)
type VolumeCacheVolumeAddedEvent = CustomEvent_2<VolumeCacheVolumeAddedEventDetail>;

// @public (undocumented)
interface VolumeCacheVolumeAddedEventDetail {
    // (undocumented)
    volume: ICachedVolume;
}

// @public (undocumented)
type VolumeCacheVolumeRemovedEvent = CustomEvent_2<VolumeCacheVolumeRemovedEventDetail>;

// @public (undocumented)
interface VolumeCacheVolumeRemovedEventDetail {
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
type VolumeInputCallback = (params: {
    volumeActor: VolumeActor;
    volumeId: string;
}) => unknown;

// @public (undocumented)
type VolumeLoadedEvent = CustomEvent_2<VolumeLoadedEventDetail>;

// @public (undocumented)
interface VolumeLoadedEventDetail {
    // (undocumented)
    volume: IImageVolume;
}

// @public (undocumented)
type VolumeLoadedFailedEvent = CustomEvent_2<VolumeLoadedFailedEventDetail>;

// @public (undocumented)
interface VolumeLoadedFailedEventDetail {
    // (undocumented)
    error: unknown;
    // (undocumented)
    volumeId: string;
}

declare namespace volumeLoader {
    export {
        loadVolume,
        createAndCacheVolume,
        createAndCacheDerivedVolume,
        createAndCacheVolumeFromImages,
        createAndCacheVolumeFromImagesSync,
        createLocalVolume,
        registerVolumeLoader,
        getVolumeLoaderSchemes,
        registerUnknownVolumeLoader,
        getUnknownVolumeLoaderSchema,
        createAndCacheDerivedLabelmapVolume,
        createLocalLabelmapVolume,
        LocalVolumeOptions
    }
}
export { volumeLoader }

// @public (undocumented)
type VolumeLoaderFn = (volumeId: string, options?: Record<string, unknown>) => {
    promise: Promise<IImageVolume>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
type VolumeNewImageEvent = CustomEvent_2<VolumeNewImageEventDetail>;

// @public (undocumented)
interface VolumeNewImageEventDetail {
    // (undocumented)
    imageIndex: number;
    // (undocumented)
    numberOfSlices: number;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
interface VolumeProps {
    // (undocumented)
    additionalDetails?: Record<string, unknown>;
    // (undocumented)
    dataType: PixelDataTypedArrayString;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    numberOfComponents?: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scalarData?: PixelDataTypedArray | PixelDataTypedArray[];
    // (undocumented)
    scaling?: {
        PT?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    volumeId: string;
    // (undocumented)
    voxelManager?: IVoxelManager<number> | IVoxelManager<RGB>;
}

// @public (undocumented)
type VolumeScrollOutOfBoundsEvent = CustomEvent_2<VolumeScrollOutOfBoundsEventDetail>;

// @public (undocumented)
type VolumeScrollOutOfBoundsEventDetail = {
    volumeId: string;
    viewport: IVolumeViewport;
    desiredStepIndex: number;
    currentStepIndex: number;
    delta: number;
    numScrollSteps: number;
    currentImageId: string;
};

// @public (undocumented)
export class VolumeViewport extends BaseVolumeViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addVolumes(volumeInputArray: IVolumeInput[], immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    getBlendMode(filterActorUIDs?: string[]): BlendModes;
    // (undocumented)
    getCurrentImageId: () => string | undefined;
    // (undocumented)
    getCurrentImageIdIndex: (volumeId?: string, useSlabThickness?: boolean) => number;
    // (undocumented)
    getCurrentSlicePixelData(): PixelDataTypedArray;
    // (undocumented)
    getNumberOfSlices: () => number;
    // (undocumented)
    getSliceIndex: () => number;
    // (undocumented)
    getSlicePlaneCoordinates: () => {
        sliceIndex: number;
        point: Point3;
    }[];
    // (undocumented)
    getSlicesClippingPlanes(): {
        sliceIndex: number;
        planes: {
            normal: Point3;
            origin: Point3;
        }[];
    }[];
    // (undocumented)
    getSliceViewInfo(): {
        sliceIndex: number;
        slicePlane: number;
        width: number;
        height: number;
        sliceToIndexMatrix: mat4;
        indexToSliceMatrix: mat4;
    };
    // (undocumented)
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    // (undocumented)
    jumpToWorld(worldPos: Point3): boolean;
    // (undocumented)
    resetCamera(options?: any): boolean;
    // (undocumented)
    resetCameraForResize: () => boolean;
    // (undocumented)
    resetProperties(volumeId?: string): void;
    // (undocumented)
    resetSlabThickness(): void;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: any[], immediate?: boolean): void;
    // (undocumented)
    protected setCameraClippingRange(): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis | OrientationVectors, immediate?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: any[]): void;
    // (undocumented)
    setVolumes(volumeInputArray: IVolumeInput[], immediate?: boolean, suppressEvents?: boolean): Promise<void>;
}

// @public (undocumented)
export class VolumeViewport3D extends BaseVolumeViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getNumberOfSlices: () => number;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getSliceIndex(): number;
    // (undocumented)
    resetCamera({ resetPan, resetZoom, resetToCenter, }?: {
        resetPan?: boolean;
        resetZoom?: boolean;
        resetToCenter?: boolean;
    }): boolean;
    // (undocumented)
    resetCameraForResize: () => boolean;
    // (undocumented)
    resetProperties(volumeId?: string): void;
    // (undocumented)
    resetSlabThickness(): void;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: string[], immediate?: boolean): void;
    // (undocumented)
    setCamera(props: any): void;
    // (undocumented)
    protected setCameraClippingRange(): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: string[]): void;
}

// @public (undocumented)
type VolumeViewportProperties = ViewportProperties & {
    preset?: string;
    slabThickness?: number;
    orientation?: OrientationAxis;
};

// @public (undocumented)
class VoxelManager<T> {
    constructor(dimensions: any, options: {
        _get: (index: number) => T;
        _set?: (index: number, v: T) => boolean;
        _getScalarData?: () => ArrayLike<number>;
        _id?: string;
        _updateScalarData?: (scalarData: ArrayLike<number>) => PixelDataTypedArray;
        numberOfComponents?: number;
        scalarData?: ArrayLike<number>;
        _getConstructor?: () => new (length: number) => PixelDataTypedArray;
    });
    // (undocumented)
    static addBounds(bounds: BoundsIJK, point: Point3): void;
    // (undocumented)
    static addInstanceToImage(image: IImage): void;
    // (undocumented)
    addPoint(point: Point3 | number): void;
    // (undocumented)
    get bytePerVoxel(): number;
    // (undocumented)
    clear(): void;
    // (undocumented)
    static createHistoryVoxelManager<T>({ sourceVoxelManager, }: {
        sourceVoxelManager: VoxelManager<T>;
    }): VoxelManager<T>;
    // (undocumented)
    static createImageVolumeVoxelManager({ dimensions, imageIds, numberOfComponents, }: {
        dimensions: Point3;
        imageIds: string[];
        numberOfComponents: number;
    }): IVoxelManager<number> | IVoxelManager<RGB>;
    // (undocumented)
    static createImageVoxelManager({ width, height, scalarData, numberOfComponents, }: {
        width: number;
        height: number;
        scalarData: PixelDataTypedArray;
        numberOfComponents?: number;
    }): IVoxelManager<number> | IVoxelManager<RGB>;
    // (undocumented)
    static createLazyVoxelManager<T>({ dimensions, planeFactory, }: {
        dimensions: Point3;
        planeFactory: (width: number, height: number) => T;
    }): VoxelManager<T>;
    // (undocumented)
    static createMapVoxelManager<T>({ dimension, }: {
        dimension: Point3;
    }): IVoxelManager<T>;
    // (undocumented)
    static createRLEHistoryVoxelManager<T>(sourceVoxelManager: VoxelManager<T>): VoxelManager<T>;
    // (undocumented)
    static createRLEImageVoxelManager<T>({ dimensions, }: {
        dimensions: Point2;
    }): VoxelManager<T>;
    // (undocumented)
    static createRLEVolumeVoxelManager<T>({ dimensions, }: {
        dimensions: Point3;
    }): VoxelManager<T>;
    // (undocumented)
    static createScalarDynamicVolumeVoxelManager({ imageIdGroups, dimensions, dimensionGroupNumber, timePoint, numberOfComponents, }: {
        imageIdGroups: string[][];
        dimensions: Point3;
        dimensionGroupNumber?: number;
        timePoint?: number;
        numberOfComponents?: number;
    }): IVoxelManager<number> | IVoxelManager<RGB>;
    // (undocumented)
    static createScalarVolumeVoxelManager({ dimensions, scalarData, numberOfComponents, }: {
        dimensions: Point3;
        scalarData: any;
        numberOfComponents?: number;
    }): IVoxelManager<number> | IVoxelManager<RGB>;
    // (undocumented)
    readonly dimensions: Point3;
    // (undocumented)
    forEach: (callback: (args: {
        value: unknown;
        index: number;
        pointIJK: Point3;
        pointLPS: Point3;
    }) => void, options?: {
        boundsIJK?: BoundsIJK;
        isInObject?: (pointLPS: any, pointIJK: any) => boolean;
        returnPoints?: boolean;
        imageData?: vtkImageData | CPUImageData;
    }) => void | any[];
    // (undocumented)
    frameSize: number;
    // (undocumented)
    readonly _get: (index: number) => T;
    // (undocumented)
    getArrayOfModifiedSlices(): number[];
    // (undocumented)
    getAtIJK: (i: any, j: any, k: any) => T;
    // (undocumented)
    getAtIJKPoint: ([i, j, k]: [any, any, any]) => T;
    // (undocumented)
    getAtIndex: (index: any) => T;
    // (undocumented)
    getBoundsIJK(): BoundsIJK;
    // (undocumented)
    getCompleteScalarDataArray?: () => ArrayLike<number>;
    // (undocumented)
    getConstructor(): new (length: number) => PixelDataTypedArray;
    // (undocumented)
    readonly _getConstructor?: () => new (length: number) => PixelDataTypedArray;
    // (undocumented)
    getDefaultBounds(): BoundsIJK;
    // (undocumented)
    getMiddleSliceData: () => PixelDataTypedArray;
    // (undocumented)
    getMinMax(): {
        min: any;
        max: any;
    };
    // (undocumented)
    getPoints(): Point3[];
    // (undocumented)
    getRange: () => [number, number];
    // (undocumented)
    getScalarData(storeScalarData?: boolean): PixelDataTypedArray;
    // (undocumented)
    _getScalarData?: () => ArrayLike<number>;
    // (undocumented)
    getScalarDataLength(): number;
    // (undocumented)
    _getScalarDataLength?: () => number;
    // (undocumented)
    getSliceData: ({ sliceIndex, slicePlane, }: {
        sliceIndex: number;
        slicePlane: number;
    }) => PixelDataTypedArray;
    // (undocumented)
    _getSliceData: (args: {
        sliceIndex: number;
        slicePlane: number;
    }) => PixelDataTypedArray;
    // (undocumented)
    readonly _id: string;
    // (undocumented)
    isInObject: (pointLPS: any, pointIJK: any) => boolean;
    // (undocumented)
    map: Map<number, T> | IRLEVoxelMap<T>;
    // (undocumented)
    modifiedSlices: Set<number>;
    // (undocumented)
    readonly numberOfComponents: any;
    // (undocumented)
    points: Set<number>;
    // (undocumented)
    resetModifiedSlices(): void;
    // (undocumented)
    rleForEach(callback: any, options?: any): void;
    // (undocumented)
    readonly _set: (index: number, v: T) => boolean;
    // (undocumented)
    setAtIJK: (i: number, j: number, k: number, v: any) => boolean;
    // (undocumented)
    setAtIJKPoint: ([i, j, k]: Point3, v: any) => void;
    // (undocumented)
    setAtIndex: (index: any, v: any) => boolean;
    // (undocumented)
    setCompleteScalarDataArray?: (scalarData: ArrayLike<number>) => void;
    // (undocumented)
    setScalarData(newScalarData: PixelDataTypedArray): void;
    // (undocumented)
    get sizeInBytes(): number;
    // (undocumented)
    sourceVoxelManager: IVoxelManager<T>;
    // (undocumented)
    static: any;
    // (undocumented)
    toIJK(index: number): Point3;
    // (undocumented)
    toIndex(ijk: Point3): number;
    // (undocumented)
    _updateScalarData?: (scalarData: ArrayLike<number>) => PixelDataTypedArray;
    // (undocumented)
    width: number;
}

// @public (undocumented)
enum VoxelManagerEnum {
    // (undocumented)
    RLE = "RLE",
    // (undocumented)
    Volume = "Volume"
}

declare namespace windowLevel {
    export {
        toWindowLevel,
        toLowHighRange
    }
}

// @public (undocumented)
function worldToImageCoords(imageId: string, worldCoords: Point3): Point2 | undefined;

// @public (undocumented)
export class WSIViewport extends Viewport {
    constructor(props: ViewportInput);
    // (undocumented)
    static addMiniNavigationOverlayCss(): void;
    // (undocumented)
    protected canvasToIndex: (canvasPos: Point2) => Point2;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => void;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCurrentImageId(): string;
    // (undocumented)
    getCurrentImageIdIndex(): number;
    // (undocumented)
    static getDicomMicroscopyViewer: () => Promise<any>;
    // (undocumented)
    getFrameNumber(): number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(): CPUIImageData;
    // (undocumented)
    getImageIds: () => Array<string>;
    // (undocumented)
    getNumberOfSlices: () => number;
    // (undocumented)
    getProperties: () => WSIViewportProperties;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    protected getScalarData(): any;
    // (undocumented)
    getSliceIndex(): number;
    // (undocumented)
    protected getTransform(): Transform;
    // (undocumented)
    getView(): any;
    // (undocumented)
    getViewReferenceId(): string;
    // (undocumented)
    getZoom(): any;
    // (undocumented)
    hasImageURI(imageURI: string): boolean;
    // (undocumented)
    protected imageIds: string[];
    // (undocumented)
    protected indexToCanvas: (indexPos: Point2) => Point2;
    // (undocumented)
    protected map: any;
    // (undocumented)
    protected metadata: any;
    // (undocumented)
    protected metadataDicomweb: any;
    // (undocumented)
    modality: any;
    // (undocumented)
    postrender: () => void;
    // (undocumented)
    readonly renderingEngineId: string;
    // (undocumented)
    resetCamera: () => boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scroll(delta: number): void;
    // (undocumented)
    setCamera(camera: ICamera): void;
    // (undocumented)
    setDataIds(imageIds: string[], options?: DataSetOptions & {
        miniNavigationOverlay?: boolean;
        webClient: unknown;
    }): Promise<void>;
    // (undocumented)
    setFrameNumber(frame: number): Promise<void>;
    // (undocumented)
    setProperties(props: WSIViewportProperties): void;
    // (undocumented)
    setWSI(imageIds: string[], client: any): Promise<void>;
    // (undocumented)
    setZoom(zoom: number): void;
    // (undocumented)
    readonly uid: any;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
type WSIViewportProperties = ViewportProperties;

// (No @packageDocumentation comment for this package)

```

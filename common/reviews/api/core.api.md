## API Report File for "@cornerstonejs/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { GetGPUTier } from 'detect-gpu';
import { mat3 } from 'gl-matrix';
import { mat4 } from 'gl-matrix';
import type { TierResult } from 'detect-gpu';
import { vec3 } from 'gl-matrix';
import type vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';
import type { vtkCamera } from '@kitware/vtk.js/Rendering/Core/Camera';
import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';
import { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';
import vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import type { vtkObject } from '@kitware/vtk.js/interfaces';
import vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';
import type vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';

// @public (undocumented)
type AABB2 = {
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
};

// @public (undocumented)
type AABB3 = {
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
    minZ: number;
    maxZ: number;
};

// @public (undocumented)
type Actor = vtkActor;

// @public (undocumented)
type ActorEntry = {
    uid: string;
    actor: Actor | VolumeActor | ImageActor | ICanvasActor;
    referenceId?: string;
    slabThickness?: number;
    clippingFilter?: any;
};

// @public (undocumented)
function actorIsA(actorEntry: Types.ActorEntry, actorType: actorTypes): boolean;

// @public (undocumented)
type ActorSliceRange = {
    actor: VolumeActor;
    viewPlaneNormal: Point3;
    focalPoint: Point3;
    min: number;
    max: number;
    current: number;
};

// @public (undocumented)
export function addImageSlicesToViewports(renderingEngine: IRenderingEngine, stackInputs: Array<IStackInput>, viewportIds: Array<string>, immediateRender?: boolean, suppressEvents?: boolean): Promise<void>;

// @public (undocumented)
function addProvider(provider: (type: string, ...query: string[]) => any, priority?: number): void;

// @public (undocumented)
export function addVolumesToViewports(renderingEngine: IRenderingEngine, volumeInputs: Array<IVolumeInput>, viewportIds: Array<string>, immediateRender?: boolean, suppressEvents?: boolean): Promise<void>;

// @public (undocumented)
type AffineMatrix = [
[
number,
number,
number,
number
],
[
number,
number,
number,
number
],
[
number,
number,
number,
number
],
[
number,
number,
number,
number
]
];

// @public (undocumented)
function applyPreset(actor: VolumeActor, preset: ViewportPreset): void;

// @public (undocumented)
const backgroundColors: {
    slicer3D: number[];
};

// @public (undocumented)
export abstract class BaseVolumeViewport extends Viewport implements IVolumeViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    protected applyViewOrientation(orientation: OrientationAxis | OrientationVectors): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    clearDefaultProperties(volumeId?: string): void;
    // (undocumented)
    flip(flipDirection: FlipDirection): void;
    // (undocumented)
    getBounds(): number[];
    // (undocumented)
    abstract getCurrentImageId(): string;
    // (undocumented)
    getDefaultProperties: (volumeId?: string) => VolumeViewportProperties;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(volumeId?: string): IImageData | undefined;
    // (undocumented)
    getImageIds: (volumeId?: string) => Array<string>;
    // (undocumented)
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    protected _getOrientationVectors(orientation: OrientationAxis | OrientationVectors): OrientationVectors;
    // (undocumented)
    getProperties: (volumeId?: string) => VolumeViewportProperties;
    // (undocumented)
    getReferenceId(specifier?: ViewReferenceSpecifier): string;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getSlabThickness(): number;
    // (undocumented)
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    // (undocumented)
    protected getVolumeId(specifier: ViewReferenceSpecifier): string;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    hasVolumeId(volumeId: string): boolean;
    // (undocumented)
    protected initialTransferFunctionNodes: any;
    // (undocumented)
    protected initialViewUp: Point3;
    // (undocumented)
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    // (undocumented)
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    // (undocumented)
    abstract resetProperties(volumeId?: string): void;
    // (undocumented)
    resetToDefaultProperties(volumeId: string): void;
    // (undocumented)
    protected resetVolumeViewportClippingRange(): void;
    // (undocumented)
    abstract setBlendMode(blendMode: BlendModes, filterActorUIDs?: Array<string>, immediate?: boolean): void;
    // (undocumented)
    setDefaultProperties(ViewportProperties: VolumeViewportProperties, volumeId?: string): void;
    // (undocumented)
    protected setInterpolationType(interpolationType: InterpolationType, volumeId?: string): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis, immediate?: boolean): void;
    // (undocumented)
    setProperties({ voiRange, VOILUTFunction, invert, colormap, preset, interpolationType, slabThickness, rotation, }?: VolumeViewportProperties, volumeId?: string, suppressEvents?: boolean): void;
    // (undocumented)
    protected setRotation: (rotation: number) => void;
    // (undocumented)
    abstract setSlabThickness(slabThickness: number, filterActorUIDs?: Array<string>): void;
    // (undocumented)
    setVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    useNativeDataType: boolean;
    // (undocumented)
    protected viewportProperties: VolumeViewportProperties;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
enum BlendModes {
    // (undocumented)
    AVERAGE_INTENSITY_BLEND = 3,
    // (undocumented)
    COMPOSITE = 0,
    // (undocumented)
    MAXIMUM_INTENSITY_BLEND = 1,
    // (undocumented)
    MINIMUM_INTENSITY_BLEND = 2
}

// @public (undocumented)
type BoundsIJK = [Point2, Point2, Point2];

// @public (undocumented)
type BoundsLPS = [Point3, Point3, Point3];

// @public (undocumented)
export const cache: Cache_2;

declare namespace cacheUtils {
    export {
        setupCacheOptimizationEventListener,
        performCacheOptimizationForVolume
    }
}

// @public (undocumented)
function calculateViewportsSpatialRegistration(viewport1: IStackViewport | IVolumeViewport, viewport2: IStackViewport | IVolumeViewport): void;

// @public (undocumented)
enum CalibrationTypes {
    // (undocumented)
    ERMF = "ERMF",
    // (undocumented)
    ERROR = "Error",
    // (undocumented)
    NOT_APPLICABLE = "",
    // (undocumented)
    PROJECTION = "Proj",
    // (undocumented)
    REGION = "Region",
    // (undocumented)
    UNCALIBRATED = "Uncalibrated",
    // (undocumented)
    USER = "User"
}

// @public (undocumented)
type CameraModifiedEvent = CustomEvent_2<CameraModifiedEventDetail>;

// @public (undocumented)
type CameraModifiedEventDetail = {
    previousCamera: ICamera;
    camera: ICamera;
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    rotation?: number;
};

// @public (undocumented)
function cancelLoadAll(): void;

// @public (undocumented)
function cancelLoadImage(imageId: string): void;

// @public (undocumented)
function cancelLoadImages(imageIds: Array<string>): void;

// @public (undocumented)
function clamp(value: number, min: number, max: number): number;

// @public (undocumented)
type Color = [number, number, number, number];

declare namespace color {
    export {
        hexToRgb,
        rgbToHex
    }
}

// @public (undocumented)
type ColorLUT = Array<Color>;

declare namespace colormap {
    export {
        getColormap,
        getColormapNames,
        registerColormap
    }
}

// @public (undocumented)
type ColormapModifiedEvent = CustomEvent_2<ColormapModifiedEventDetail>;

// @public (undocumented)
type ColormapModifiedEventDetail = {
    viewportId: string;
    colormap: ColormapPublic;
    volumeId?: string;
};

// @public (undocumented)
type ColormapPublic = {
    name?: string;
    opacity?: OpacityMapping[] | number;
};

// @public (undocumented)
type ColormapRegistration = {
    ColorSpace: string;
    Name: string;
    RGBPoints: RGB[];
};

// @public (undocumented)
const colormapsData: CPUFallbackColormapsData;

declare namespace CONSTANTS {
    export {
        colormapsData as CPU_COLORMAPS,
        RENDERING_DEFAULTS,
        mprCameraValues as MPR_CAMERA_VALUES,
        EPSILON,
        presets as VIEWPORT_PRESETS,
        backgroundColors as BACKGROUND_COLORS
    }
}
export { CONSTANTS }

// @public (undocumented)
type ContourData = {
    points: Point3[];
    type: ContourType;
    color: Point3;
    segmentIndex: number;
};

// @public (undocumented)
type ContourSetData = {
    id: string;
    data: ContourData[];
    frameOfReferenceUID: string;
    color?: Point3;
    segmentIndex?: number;
};

// @public (undocumented)
enum ContourType {
    // (undocumented)
    CLOSED_PLANAR = "CLOSED_PLANAR",
    // (undocumented)
    OPEN_PLANAR = "OPEN_PLANAR"
}

// @public (undocumented)
function convertStackToVolumeViewport({ viewport, options, }: {
    viewport: IStackViewport;
    options: {
        volumeId: string;
        viewportId?: string;
        background?: Point3;
        orientation?: OrientationAxis;
    };
}): Promise<IVolumeViewport>;

// @public (undocumented)
function convertToGrayscale(scalarData: any, width: number, height: number): any;

// @public (undocumented)
function convertVolumeToStackViewport({ viewport, options, }: {
    viewport: Types.IVolumeViewport;
    options: {
        viewportId?: string;
        background?: Types.Point3;
    };
}): Promise<Types.IStackViewport>;

// @public (undocumented)
type Cornerstone3DConfig = {
    gpuTier?: TierResult;
    detectGPUConfig: GetGPUTier;
    rendering: {
        preferSizeOverAccuracy: boolean;
        useNorm16Texture: boolean;
        useCPURendering: boolean;
        strictZSpacingForVolumeViewport: boolean;
    };
    enableCacheOptimization: boolean;
};

// @public (undocumented)
interface CPUFallbackColormap {
    // (undocumented)
    addColor: (rgba: Point4) => void;
    // (undocumented)
    buildLookupTable: (lut: CPUFallbackLookupTable) => void;
    // (undocumented)
    clearColors: () => void;
    // (undocumented)
    createLookupTable: () => CPUFallbackLookupTable;
    // (undocumented)
    getColor: (index: number) => Point4;
    // (undocumented)
    getColorRepeating: (index: number) => Point4;
    // (undocumented)
    getColorSchemeName: () => string;
    // (undocumented)
    getId: () => string;
    // (undocumented)
    getNumberOfColors: () => number;
    // (undocumented)
    insertColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    isValidIndex: (index: number) => boolean;
    // (undocumented)
    removeColor: (index: number) => void;
    // (undocumented)
    setColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    setColorSchemeName: (name: string) => void;
    // (undocumented)
    setNumberOfColors: (numColors: number) => void;
}

// @public (undocumented)
type CPUFallbackColormapData = {
    name: string;
    numOfColors?: number;
    colors?: Point4[];
    segmentedData?: unknown;
    numColors?: number;
    gamma?: number;
};

// @public (undocumented)
type CPUFallbackColormapsData = {
    [key: string]: CPUFallbackColormapData;
};

// @public (undocumented)
interface CPUFallbackEnabledElement {
    // (undocumented)
    canvas?: HTMLCanvasElement;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    image?: IImage;
    // (undocumented)
    invalid?: boolean;
    // (undocumented)
    metadata?: {
        direction?: Mat3;
        dimensions?: Point3;
        spacing?: Point3;
        origin?: Point3;
        imagePlaneModule?: ImagePlaneModule;
        imagePixelModule?: ImagePixelModule;
    };
    // (undocumented)
    needsRedraw?: boolean;
    // (undocumented)
    options?: {
        [key: string]: unknown;
        colormap?: CPUFallbackColormap;
    };
    // (undocumented)
    pan?: Point2;
    // (undocumented)
    renderingTools?: CPUFallbackRenderingTools;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    transform?: CPUFallbackTransform;
    // (undocumented)
    viewport?: CPUFallbackViewport;
    // (undocumented)
    zoom?: number;
}

// @public (undocumented)
interface CPUFallbackLookupTable {
    // (undocumented)
    build: (force: boolean) => void;
    // (undocumented)
    getColor: (scalar: number) => Point4;
    // (undocumented)
    setAlphaRange: (start: number, end: number) => void;
    // (undocumented)
    setHueRange: (start: number, end: number) => void;
    // (undocumented)
    setNumberOfTableValues: (number: number) => void;
    // (undocumented)
    setRamp: (ramp: string) => void;
    // (undocumented)
    setRange: (start: number, end: number) => void;
    // (undocumented)
    setSaturationRange: (start: number, end: number) => void;
    // (undocumented)
    setTableRange: (start: number, end: number) => void;
    // (undocumented)
    setTableValue(index: number, rgba: Point4): any;
    // (undocumented)
    setValueRange: (start: number, end: number) => void;
}

// @public (undocumented)
type CPUFallbackLUT = {
    lut: number[];
};

// @public (undocumented)
type CPUFallbackRenderingTools = {
    renderCanvas?: HTMLCanvasElement;
    lastRenderedIsColor?: boolean;
    lastRenderedImageId?: string;
    lastRenderedViewport?: {
        windowWidth: number | number[];
        windowCenter: number | number[];
        invert: boolean;
        rotation: number;
        hflip: boolean;
        vflip: boolean;
        modalityLUT: CPUFallbackLUT;
        voiLUT: CPUFallbackLUT;
        colormap: unknown;
    };
    renderCanvasContext?: CanvasRenderingContext2D;
    colormapId?: string;
    colorLUT?: CPUFallbackLookupTable;
    renderCanvasData?: ImageData;
};

// @public (undocumented)
interface CPUFallbackTransform {
    // (undocumented)
    clone: () => CPUFallbackTransform;
    // (undocumented)
    getMatrix: () => TransformMatrix2D;
    // (undocumented)
    invert: () => void;
    // (undocumented)
    multiply: (matrix: TransformMatrix2D) => void;
    // (undocumented)
    reset: () => void;
    // (undocumented)
    rotate: (rad: number) => void;
    // (undocumented)
    scale: (sx: number, sy: number) => void;
    // (undocumented)
    transformPoint: (point: Point2) => Point2;
    // (undocumented)
    translate: (x: number, y: number) => void;
}

// @public (undocumented)
type CPUFallbackViewport = {
    scale?: number;
    parallelScale?: number;
    focalPoint?: number[];
    translation?: {
        x: number;
        y: number;
    };
    voi?: {
        windowWidth: number;
        windowCenter: number;
    };
    invert?: boolean;
    pixelReplication?: boolean;
    rotation?: number;
    hflip?: boolean;
    vflip?: boolean;
    modalityLUT?: CPUFallbackLUT;
    voiLUT?: CPUFallbackLUT;
    colormap?: CPUFallbackColormap;
    displayedArea?: CPUFallbackViewportDisplayedArea;
    modality?: string;
};

// @public (undocumented)
type CPUFallbackViewportDisplayedArea = {
    tlhc: {
        x: number;
        y: number;
    };
    brhc: {
        x: number;
        y: number;
    };
    rowPixelSpacing: number;
    columnPixelSpacing: number;
    presentationSizeMode: string;
};

// @public (undocumented)
type CPUIImageData = {
    dimensions: Point3;
    direction: Mat3;
    spacing: Point3;
    origin: Point3;
    imageData: CPUImageData;
    metadata: {
        Modality: string;
    };
    scalarData: PixelDataTypedArray;
    scaling: Scaling;
    hasPixelSpacing?: boolean;
    calibration?: IImageCalibration;
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
};

// @public (undocumented)
type CPUImageData = {
    worldToIndex?: (point: Point3) => Point3;
    indexToWorld?: (point: Point3) => Point3;
    getWorldToIndex?: () => Point3;
    getIndexToWorld?: () => Point3;
    getSpacing?: () => Point3;
    getDirection?: () => Mat3;
    getScalarData?: () => PixelDataTypedArray;
    getDimensions?: () => Point3;
};

// @public (undocumented)
function createAndCacheDerivedImage(referencedImageId: string, options?: DerivedImageOptions, preventCache?: boolean): Promise<IImage>;

// @public (undocumented)
function createAndCacheDerivedImages(referencedImageIds: Array<string>, options?: DerivedImageOptions & {
    getDerivedImageId?: (referencedImageId: string) => string;
    targetBufferType?: PixelDataTypedArrayString;
}): DerivedImages;

// @public (undocumented)
function createAndCacheDerivedSegmentationImage(referencedImageId: string, options?: DerivedImageOptions): Promise<IImage>;

// @public (undocumented)
function createAndCacheDerivedSegmentationImages(referencedImageIds: Array<string>, options?: DerivedImageOptions): DerivedImages;

// @public (undocumented)
function createAndCacheDerivedSegmentationVolume(referencedVolumeId: string, options?: DerivedVolumeOptions): Promise<IImageVolume>;

// @public (undocumented)
function createAndCacheDerivedVolume(referencedVolumeId: string, options: DerivedVolumeOptions): Promise<IImageVolume>;

// @public (undocumented)
function createAndCacheGeometry(geometryId: string, options: GeometryOptions): Promise<IGeometry>;

// @public (undocumented)
function createAndCacheLocalImage(options: LocalImageOptions, imageId: string, preventCache?: boolean): IImage;

// @public (undocumented)
function createAndCacheVolume(volumeId: string, options?: VolumeLoaderOptions): Promise<Record<string, any>>;

// @public (undocumented)
function createAndCacheVolumeFromImages(volumeId: string, imageIds: string[], options?: {
    preventCache?: boolean;
    additionalDetails?: Record<string, any>;
}): Promise<IImageVolume>;

// @public (undocumented)
function createFloat32SharedArray(length: number): Float32Array;

// @public (undocumented)
function createInt16SharedArray(length: number): Int16Array;

// @public (undocumented)
function createLinearRGBTransferFunction(voiRange: VOIRange): vtkColorTransferFunction;

// @public (undocumented)
function createLocalSegmentationVolume(options: LocalVolumeOptions, volumeId: string, preventCache?: boolean): Promise<IImageVolume>;

// @public (undocumented)
function createLocalVolume(options: LocalVolumeOptions, volumeId: string, preventCache?: boolean): IImageVolume;

// @public (undocumented)
function createSigmoidRGBTransferFunction(voiRange: VOIRange, approximationNodes?: number): vtkColorTransferFunction;

// @public (undocumented)
function createUint16SharedArray(length: number): Uint16Array;

// @public (undocumented)
function createUint8SharedArray(length: number): Uint8Array;

// @public (undocumented)
export function createVolumeActor(props: createVolumeActorInterface, element: HTMLDivElement, viewportId: string, suppressEvents?: boolean, useNativeDataType?: boolean): Promise<VolumeActor>;

// @public (undocumented)
export function createVolumeMapper(imageData: any, vtkOpenGLTexture: any): any;

// @public (undocumented)
interface CustomEvent_2<T = any> extends Event {
    // (undocumented)
    readonly detail: T;
    // (undocumented)
    initCustomEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, detailArg: T): void;
}

// @public (undocumented)
function decimate(list: Array<unknown>, interleave: number, offset?: number): number[];

// @public (undocumented)
const deepMerge: (target?: {}, source?: {}, optionsArgument?: any) => any;

// @public (undocumented)
type DisplayArea = {
    type?: 'SCALE' | 'FIT';
    scale?: number;
    interpolationType?: InterpolationType;
    imageArea?: [number, number];
    imageCanvasPoint?: {
        imagePoint: [number, number];
        canvasPoint?: [number, number];
    };
    storeAsInitialCamera?: boolean;
};

// @public (undocumented)
type DisplayAreaModifiedEvent = CustomEvent_2<DisplayAreaModifiedEventDetail>;

// @public (undocumented)
type DisplayAreaModifiedEventDetail = {
    viewportId: string;
    displayArea: DisplayArea;
    volumeId?: string;
    storeAsInitialCamera?: boolean;
};

// @public (undocumented)
enum DynamicOperatorType {
    // (undocumented)
    AVERAGE = "AVERAGE",
    // (undocumented)
    SUBTRACT = "SUBTRACT",
    // (undocumented)
    SUM = "SUM"
}

// @public (undocumented)
type ElementDisabledEvent = CustomEvent_2<ElementDisabledEventDetail>;

// @public (undocumented)
type ElementDisabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type ElementEnabledEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public (undocumented)
type ElementEnabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

declare namespace Enums {
    export {
        EVENTS as Events,
        BlendModes,
        CalibrationTypes,
        InterpolationType,
        RequestType,
        ViewportType,
        OrientationAxis,
        SharedArrayBufferModes,
        GeometryType,
        ContourType,
        VOILUTFunctionType,
        DynamicOperatorType,
        ViewportStatus,
        VideoEnums,
        MetadataModules,
        ImageQualityStatus
    }
}
export { Enums }

// @public (undocumented)
const EPSILON = 0.001;

declare namespace eventListener {
    export {
        TargetEventListeners,
        MultiTargetEventListenerManager
    }
}

// @public (undocumented)
export enum EVENTS {
    // (undocumented)
    CACHE_SIZE_EXCEEDED = "CACHE_SIZE_EXCEEDED",
    // (undocumented)
    CAMERA_MODIFIED = "CORNERSTONE_CAMERA_MODIFIED",
    // (undocumented)
    CAMERA_RESET = "CORNERSTONE_CAMERA_RESET",
    // (undocumented)
    CLIPPING_PLANES_UPDATED = "CORNERSTONE_CLIPPING_PLANES_UPDATED",
    // (undocumented)
    COLORMAP_MODIFIED = "CORNERSTONE_COLORMAP_MODIFIED",
    // (undocumented)
    DISPLAY_AREA_MODIFIED = "CORNERSTONE_DISPLAY_AREA_MODIFIED",
    // (undocumented)
    ELEMENT_DISABLED = "CORNERSTONE_ELEMENT_DISABLED",
    // (undocumented)
    ELEMENT_ENABLED = "CORNERSTONE_ELEMENT_ENABLED",
    // (undocumented)
    ERROR_EVENT = "CORNERSTONE_ERROR",
    // (undocumented)
    GEOMETRY_CACHE_GEOMETRY_ADDED = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED",
    // (undocumented)
    IMAGE_CACHE_IMAGE_ADDED = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED",
    // (undocumented)
    IMAGE_CACHE_IMAGE_REMOVED = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED",
    // (undocumented)
    IMAGE_LOAD_ERROR = "IMAGE_LOAD_ERROR",
    // (undocumented)
    IMAGE_LOAD_FAILED = "CORNERSTONE_IMAGE_LOAD_FAILED",
    // (undocumented)
    IMAGE_LOADED = "CORNERSTONE_IMAGE_LOADED",
    // (undocumented)
    IMAGE_RENDERED = "CORNERSTONE_IMAGE_RENDERED",
    // (undocumented)
    IMAGE_RETRIEVAL_STAGE = "CORNERSTONE_IMAGE_RETRIEVAL_STAGE",
    // (undocumented)
    IMAGE_SPACING_CALIBRATED = "CORNERSTONE_IMAGE_SPACING_CALIBRATED",
    // (undocumented)
    IMAGE_VOLUME_LOADING_COMPLETED = "CORNERSTONE_IMAGE_VOLUME_LOADING_COMPLETED",
    // (undocumented)
    IMAGE_VOLUME_MODIFIED = "CORNERSTONE_IMAGE_VOLUME_MODIFIED",
    // (undocumented)
    PRE_STACK_NEW_IMAGE = "CORNERSTONE_PRE_STACK_NEW_IMAGE",
    // (undocumented)
    PRESET_MODIFIED = "CORNERSTONE_VIEWPORT_RENDERING_PRESET_MODIFIED",
    // (undocumented)
    STACK_NEW_IMAGE = "CORNERSTONE_STACK_NEW_IMAGE",
    // (undocumented)
    STACK_VIEWPORT_NEW_STACK = "CORNERSTONE_STACK_VIEWPORT_NEW_STACK",
    // (undocumented)
    STACK_VIEWPORT_SCROLL = "CORNERSTONE_STACK_VIEWPORT_SCROLL",
    // (undocumented)
    VOI_MODIFIED = "CORNERSTONE_VOI_MODIFIED",
    // (undocumented)
    VOLUME_CACHE_VOLUME_ADDED = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED",
    // (undocumented)
    VOLUME_CACHE_VOLUME_REMOVED = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED",
    // (undocumented)
    VOLUME_LOADED = "CORNERSTONE_VOLUME_LOADED",
    // (undocumented)
    VOLUME_LOADED_FAILED = "CORNERSTONE_VOLUME_LOADED_FAILED",
    // (undocumented)
    VOLUME_NEW_IMAGE = "CORNERSTONE_VOLUME_NEW_IMAGE",
    // (undocumented)
    VOLUME_SCROLL_OUT_OF_BOUNDS = "VOLUME_SCROLL_OUT_OF_BOUNDS",
    // (undocumented)
    VOLUME_VIEWPORT_NEW_VOLUME = "CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME",
    // (undocumented)
    VOLUME_VIEWPORT_SCROLL = "VOLUME_VIEWPORT_SCROLL",
    // (undocumented)
    WEB_WORKER_PROGRESS = "CORNERSTONE_WEB_WORKER_PROGRESS"
}

// @public (undocumented)
export const eventTarget: CornerstoneEventTarget;

declare namespace EventTypes {
    export {
        ImageLoadStageEventDetail,
        CameraModifiedEventDetail,
        CameraModifiedEvent,
        VoiModifiedEvent,
        VoiModifiedEventDetail,
        ColormapModifiedEvent,
        ColormapModifiedEventDetail,
        DisplayAreaModifiedEvent,
        DisplayAreaModifiedEventDetail,
        ElementDisabledEvent,
        ElementDisabledEventDetail,
        ElementEnabledEvent,
        ElementEnabledEventDetail,
        ImageRenderedEventDetail,
        ImageRenderedEvent,
        ImageVolumeModifiedEvent,
        ImageVolumeModifiedEventDetail,
        ImageVolumeLoadingCompletedEvent,
        ImageVolumeLoadingCompletedEventDetail,
        ImageLoadedEvent,
        ImageLoadedEventDetail,
        ImageLoadedFailedEventDetail,
        ImageLoadedFailedEvent,
        VolumeLoadedEvent,
        VolumeLoadedEventDetail,
        VolumeLoadedFailedEvent,
        VolumeLoadedFailedEventDetail,
        ImageCacheImageAddedEvent,
        ImageCacheImageAddedEventDetail,
        ImageCacheImageRemovedEvent,
        ImageCacheImageRemovedEventDetail,
        VolumeCacheVolumeAddedEvent,
        VolumeCacheVolumeAddedEventDetail,
        VolumeCacheVolumeRemovedEvent,
        VolumeCacheVolumeRemovedEventDetail,
        StackNewImageEvent,
        StackNewImageEventDetail,
        PreStackNewImageEvent,
        PreStackNewImageEventDetail,
        ImageSpacingCalibratedEvent,
        ImageSpacingCalibratedEventDetail,
        VolumeNewImageEvent,
        VolumeNewImageEventDetail,
        StackViewportNewStackEvent,
        StackViewportNewStackEventDetail,
        StackViewportScrollEvent,
        StackViewportScrollEventDetail
    }
}

// @public (undocumented)
type FlipDirection = {
    flipHorizontal?: boolean;
    flipVertical?: boolean;
};

// @public (undocumented)
function generateVolumePropsFromImageIds(imageIds: string[], volumeId: string): ImageVolumeProps;

declare namespace geometryLoader {
    export {
        createAndCacheGeometry
    }
}
export { geometryLoader }

// @public (undocumented)
enum GeometryType {
    // (undocumented)
    CONTOUR = "contour",
    // (undocumented)
    SURFACE = "Surface"
}

// @public (undocumented)
function getBufferConfiguration(targetBufferType: PixelDataTypedArrayString, length: number, options?: {
    use16BitTexture?: boolean;
    isVolumeBuffer?: boolean;
}): {
    numBytes: number;
    TypedArrayConstructor: new (length: number | SharedArrayBuffer) => PixelDataTypedArray;
};

// @public (undocumented)
function getClosestImageId(imageVolume: IImageVolume, worldPos: Point3, viewPlaneNormal: Point3): string;

// @public (undocumented)
function getClosestStackImageIndexForPoint(point: Point3, viewport: IStackViewport): number | null;

// @public (undocumented)
function getColormap(name: any): any;

// @public (undocumented)
function getColormapNames(): any[];

// @public (undocumented)
export function getConfiguration(): Cornerstone3DConfig;

// @public (undocumented)
function getCurrentVolumeViewportSlice(viewport: IVolumeViewport): {
    width: number;
    height: number;
    scalarData: any;
    sliceToIndexMatrix: mat4;
    indexToSliceMatrix: mat4;
};

// @public (undocumented)
export function getEnabledElement(element: HTMLDivElement | undefined): IEnabledElement | undefined;

// @public (undocumented)
export function getEnabledElementByIds(viewportId: string, renderingEngineId: string): IEnabledElement;

// @public (undocumented)
export function getEnabledElementByViewportId(viewportId: string): IEnabledElement;

// @public (undocumented)
export function getEnabledElements(): IEnabledElement[];

// @public (undocumented)
function getImageLegacy(element: HTMLDivElement): Types.IImage | undefined;

// @public (undocumented)
function getImageSliceDataForVolumeViewport(viewport: IVolumeViewport): ImageSliceData;

// @public (undocumented)
function getMetaData(type: string, ...queries: any[]): any;

// @public (undocumented)
function getMinMax(storedPixelData: number[]): {
    min: number;
    max: number;
};

// @public (undocumented)
export function getOrCreateCanvas(element: HTMLDivElement): HTMLCanvasElement;

// @public (undocumented)
function getRandomSampleFromArray<T>(array: T[], size: number): T[];

// @public (undocumented)
export function getRenderingEngine(id: string): IRenderingEngine | undefined;

// @public (undocumented)
export function getRenderingEngines(): IRenderingEngine[] | undefined;

// @public (undocumented)
function getRuntimeId(context?: unknown, separator?: string, max?: number): string;

// @public (undocumented)
function getScalarDataType(scalingParameters: ScalingParameters, scalarData?: any): string;

// @public (undocumented)
function getScalingParameters(imageId: string): ScalingParameters;

// @public (undocumented)
export function getShouldUseCPURendering(): boolean;

// @public (undocumented)
export function getShouldUseSharedArrayBuffer(): boolean;

// @public (undocumented)
function getSliceRange(volumeActor: VolumeActor, viewPlaneNormal: Point3, focalPoint: Point3): ActorSliceRange;

// @public (undocumented)
function getSpacingInNormalDirection(imageVolume: IImageVolume | {
    direction: mat3;
    spacing: Point3;
}, viewPlaneNormal: Point3): number;

// @public (undocumented)
function getTargetVolumeAndSpacingInNormalDir(viewport: IVolumeViewport, camera: ICamera, targetId?: string, useSlabThickness?: boolean): {
    imageVolume: IImageVolume;
    spacingInNormalDirection: number;
    actorUID: string;
};

// @public (undocumented)
function getTransferFunctionNodes(transferFunction: any): any[];

// @public (undocumented)
function getUnknownVolumeLoaderSchema(): string;

// @public (undocumented)
function getViewportImageCornersInWorld(viewport: IStackViewport | IVolumeViewport): Point3[];

// @public (undocumented)
function getViewportImageIds(viewport: IViewport): string[];

// @public (undocumented)
function getViewportModality(viewport: IViewport, volumeId?: string): string;

// @public (undocumented)
function getViewportsWithImageURI(imageURI: string, renderingEngineId?: string): Array<Viewport_2>;

// @public (undocumented)
function getViewportsWithVolumeId(volumeId: string, renderingEngineId?: string): Array<IVolumeViewport>;

// @public (undocumented)
function getVoiFromSigmoidRGBTransferFunction(cfun: vtkColorTransferFunction): [number, number];

// @public (undocumented)
function getVolumeActorCorners(volumeActor: any): Array<Point3>;

// @public (undocumented)
const getVolumeId: (targetId: string) => string;

// @public (undocumented)
function getVolumeLoaderSchemes(): string[];

// @public (undocumented)
function getVolumeSliceRangeInfo(viewport: IVolumeViewport, volumeId: string, useSlabThickness?: boolean): {
    sliceRange: ActorSliceRange;
    spacingInNormalDirection: number;
    camera: ICamera;
};

// @public (undocumented)
function getVolumeViewportsContainingSameVolumes(targetViewport: IVolumeViewport, renderingEngineId?: string): Array<IVolumeViewport>;

// @public (undocumented)
function getVolumeViewportScrollInfo(viewport: IVolumeViewport, volumeId: string, useSlabThickness?: boolean): {
    numScrollSteps: number;
    currentStepIndex: number;
    sliceRangeInfo: {
        sliceRange: ActorSliceRange;
        spacingInNormalDirection: number;
        camera: ICamera;
    };
};

// @public (undocumented)
export function getWebWorkerManager(): any;

// @public (undocumented)
function hasNaNValues(input: number[] | number): boolean;

// @public (undocumented)
function hexToRgb(hex: any): {
    r: number;
    g: number;
    b: number;
};

// @public (undocumented)
interface ICache {
    // (undocumented)
    getCacheSize: () => number;
    // (undocumented)
    getImageLoadObject: (imageId: string) => IImageLoadObject | void;
    // (undocumented)
    getMaxCacheSize: () => number;
    // (undocumented)
    getVolumeLoadObject: (volumeId: string) => IVolumeLoadObject | void;
    // (undocumented)
    purgeCache: () => void;
    // (undocumented)
    putImageLoadObject: (imageId: string, imageLoadObject: IImageLoadObject, updateCache?: boolean) => Promise<any>;
    // (undocumented)
    putVolumeLoadObject: (volumeId: string, volumeLoadObject: IVolumeLoadObject) => Promise<any>;
    // (undocumented)
    setMaxCacheSize: (maxCacheSize: number) => void;
}

// @public (undocumented)
interface ICachedGeometry {
    // (undocumented)
    geometry?: IGeometry;
    // (undocumented)
    geometryId: string;
    // (undocumented)
    geometryLoadObject: IGeometryLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedImage {
    // (undocumented)
    image?: IImage;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageLoadObject: IImageLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedVolume {
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
    // (undocumented)
    volume?: IImageVolume;
    // (undocumented)
    volumeId: string;
    // (undocumented)
    volumeLoadObject: IVolumeLoadObject;
}

// @public (undocumented)
interface ICamera {
    // (undocumented)
    clippingRange?: Point2;
    // (undocumented)
    flipHorizontal?: boolean;
    // (undocumented)
    flipVertical?: boolean;
    // (undocumented)
    focalPoint?: Point3;
    // (undocumented)
    parallelProjection?: boolean;
    // (undocumented)
    parallelScale?: number;
    // (undocumented)
    position?: Point3;
    // (undocumented)
    scale?: number;
    // (undocumented)
    viewAngle?: number;
    // (undocumented)
    viewPlaneNormal?: Point3;
    // (undocumented)
    viewUp?: Point3;
}

// @public (undocumented)
interface ICanvasActor {
    // (undocumented)
    getClassName(): string;
    // (undocumented)
    getMapper(): any;
    // (undocumented)
    getProperty(): any;
    // (undocumented)
    isA(actorType: any): boolean;
    // (undocumented)
    render(viewport: any, context: any): void;
}

// @public (undocumented)
interface IContour {
    // (undocumented)
    color: any;
    // (undocumented)
    getColor(): Point3;
    // (undocumented)
    getFlatPointsArray(): number[];
    // (undocumented)
    getPoints(): Point3[];
    // (undocumented)
    _getSizeInBytes(): number;
    // (undocumented)
    getType(): ContourType;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    points: Point3[];
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public (undocumented)
interface IContourSet {
    // (undocumented)
    contours: IContour[];
    // (undocumented)
    _createEachContour(data: ContourData[]): void;
    // (undocumented)
    readonly frameOfReferenceUID: string;
    // (undocumented)
    getCentroid(): Point3;
    // (undocumented)
    getColor(): any;
    // (undocumented)
    getContours(): IContour[];
    // (undocumented)
    getFlatPointsArray(): Point3[];
    // (undocumented)
    getNumberOfContours(): number;
    // (undocumented)
    getNumberOfPointsArray(): number[];
    // (undocumented)
    getNumberOfPointsInAContour(contourIndex: number): number;
    // (undocumented)
    getPointsInContour(contourIndex: number): Point3[];
    // (undocumented)
    getSegmentIndex(): number;
    // (undocumented)
    getSizeInBytes(): number;
    // (undocumented)
    getTotalNumberOfPoints(): number;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public (undocumented)
interface IDynamicImageVolume extends IImageVolume {
    // (undocumented)
    getScalarDataArrays(): PixelDataTypedArray[];
    // (undocumented)
    get numTimePoints(): number;
    // (undocumented)
    get timePointIndex(): number;
    set timePointIndex(newTimePointIndex: number);
}

// @public (undocumented)
interface IEnabledElement {
    // (undocumented)
    FrameOfReferenceUID: string;
    // (undocumented)
    renderingEngine: IRenderingEngine;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewport: IStackViewport | IVolumeViewport;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
interface IGeometry {
    // (undocumented)
    data: IContourSet | ISurface;
    // (undocumented)
    id: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    type: GeometryType;
}

// @public (undocumented)
interface IGeometryLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IGeometry>;
}

// @public (undocumented)
interface IImage {
    // (undocumented)
    bufferView?: {
        buffer: ArrayBuffer;
        offset: number;
    };
    // (undocumented)
    cachedLut?: {
        windowWidth?: number | number[];
        windowCenter?: number | number[];
        invert?: boolean;
        lutArray?: Uint8ClampedArray;
        modalityLUT?: unknown;
        voiLUT?: CPUFallbackLUT;
    };
    // (undocumented)
    calibration?: IImageCalibration;
    // (undocumented)
    color: boolean;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    columnPixelSpacing: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    decodeTimeInMS?: number;
    // (undocumented)
    getCanvas: () => HTMLCanvasElement;
    // (undocumented)
    getPixelData: () => PixelDataTypedArray;
    // (undocumented)
    height: number;
    // (undocumented)
    imageFrame?: any;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageQualityStatus?: ImageQualityStatus;
    // (undocumented)
    intercept: number;
    // (undocumented)
    invert: boolean;
    // (undocumented)
    isPreScaled?: boolean;
    // (undocumented)
    loadTimeInMS?: number;
    // (undocumented)
    maxPixelValue: number;
    // (undocumented)
    minPixelValue: number;
    // (undocumented)
    modalityLUT?: CPUFallbackLUT;
    // (undocumented)
    numComps: number;
    // (undocumented)
    photometricInterpretation?: string;
    // (undocumented)
    preScale?: {
        enabled: boolean;
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    // (undocumented)
    referencedImageId?: string;
    // (undocumented)
    render?: (enabledElement: CPUFallbackEnabledElement, invalidated: boolean) => unknown;
    // (undocumented)
    rgba: boolean;
    // (undocumented)
    rowPixelSpacing: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    scaling?: {
        PT?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    sliceThickness?: number;
    // (undocumented)
    slope: number;
    // (undocumented)
    stats?: {
        lastStoredPixelDataToCanvasImageDataTime?: number;
        lastGetPixelDataTime?: number;
        lastPutImageDataTime?: number;
        lastLutGenerateTime?: number;
        lastRenderedViewport?: unknown;
        lastRenderTime?: number;
    };
    // (undocumented)
    voiLUT?: CPUFallbackLUT;
    // (undocumented)
    voiLUTFunction: string;
    // (undocumented)
    voxelManager?: VoxelManager<number> | VoxelManager<RGB>;
    // (undocumented)
    width: number;
    // (undocumented)
    windowCenter: number[] | number;
    // (undocumented)
    windowWidth: number[] | number;
}

// @public (undocumented)
interface IImageCalibration {
    // (undocumented)
    aspect?: number;
    // (undocumented)
    columnPixelSpacing?: number;
    // (undocumented)
    rowPixelSpacing?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    sequenceOfUltrasoundRegions?: Record<string, unknown>[];
    // (undocumented)
    tooltip?: string;
    // (undocumented)
    type: CalibrationTypes;
}

// @public (undocumented)
interface IImageData {
    // (undocumented)
    calibration?: IImageCalibration;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    hasPixelSpacing?: boolean;
    // (undocumented)
    imageData: vtkImageData;
    // (undocumented)
    metadata: {
        Modality: string;
    };
    // (undocumented)
    origin: Point3;
    // (undocumented)
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    // (undocumented)
    scalarData: Float32Array | Uint16Array | Uint8Array | Int16Array;
    // (undocumented)
    scaling?: Scaling;
    // (undocumented)
    spacing: Point3;
}

// @public (undocumented)
interface IImageLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IImage>;
}

// @public (undocumented)
export interface IImagesLoader {
    // (undocumented)
    loadImages: (imageIds: string[], listener: ImageLoadListener) => Promise<unknown>;
}

// @public (undocumented)
interface IImageVolume {
    // (undocumented)
    additionalDetails?: Record<string, any>;
    // (undocumented)
    cancelLoading?: () => void;
    // (undocumented)
    convertToCornerstoneImage?: (imageId: string, imageIdIndex: number) => IImageLoadObject;
    // (undocumented)
    convertToImageSlicesAndCache(): string[];
    // (undocumented)
    decache?: (completelyRemove?: boolean) => void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    getImageIdIndex(imageId: string): number;
    // (undocumented)
    getImageURIIndex(imageURI: string): number;
    // (undocumented)
    getScalarData(): PixelDataTypedArray;
    // (undocumented)
    hasPixelSpacing: boolean;
    // (undocumented)
    get imageCacheOffsetMap(): Map<string, any>;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    imageIds: Array<string>;
    // (undocumented)
    isDynamicVolume(): boolean;
    // (undocumented)
    isPreScaled: boolean;
    // (undocumented)
    loadStatus?: Record<string, any>;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    modified(): void;
    // (undocumented)
    numVoxels: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedImageIds?: Array<string>;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scaling?: {
        PT?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    readonly volumeId: string;
    // (undocumented)
    voxelManager?: VoxelManager<number> | VoxelManager<RGB>;
    // (undocumented)
    vtkOpenGLTexture: any;
}

// @public (undocumented)
type ImageActor = vtkImageSlice;

// @public (undocumented)
type ImageCacheImageAddedEvent = CustomEvent_2<ImageCacheImageAddedEventDetail>;

// @public (undocumented)
type ImageCacheImageAddedEventDetail = {
    image: ICachedImage;
};

// @public (undocumented)
type ImageCacheImageRemovedEvent = CustomEvent_2<ImageCacheImageRemovedEventDetail>;

// @public (undocumented)
type ImageCacheImageRemovedEventDetail = {
    imageId: string;
};

// @public (undocumented)
function imageIdToURI(imageId: string): string;

// @public (undocumented)
type ImageLoadedEvent = CustomEvent_2<ImageLoadedEventDetail>;

// @public (undocumented)
type ImageLoadedEventDetail = {
    image: IImage;
};

// @public (undocumented)
type ImageLoadedFailedEvent = CustomEvent_2<ImageLoadedFailedEventDetail>;

// @public (undocumented)
type ImageLoadedFailedEventDetail = {
    imageId: string;
    error: unknown;
};

declare namespace imageLoader {
    export {
        loadImage,
        loadAndCacheImage,
        loadAndCacheImages,
        createAndCacheDerivedImage,
        createAndCacheDerivedImages,
        createAndCacheLocalImage,
        cancelLoadImage,
        cancelLoadImages,
        cancelLoadAll,
        registerImageLoader,
        registerUnknownImageLoader,
        unregisterAllImageLoaders,
        createAndCacheDerivedSegmentationImages,
        createAndCacheDerivedSegmentationImage,
        ImageLoaderOptions
    }
}
export { imageLoader }

// @public (undocumented)
type ImageLoaderFn = (imageId: string, options?: Record<string, any>) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
interface ImageLoaderOptions {
    // (undocumented)
    additionalDetails?: Record<string, unknown>;
    // (undocumented)
    ignoreCache?: boolean;
    // (undocumented)
    priority: number;
    // (undocumented)
    requestType: string;
}

// @public (undocumented)
export type ImageLoadListener = {
    successCallback: (imageId: any, image: any) => void;
    errorCallback: (imageId: any, permanent: any, reason: any) => void;
    getLoaderImageOptions?: (imageId: any) => Record<string, unknown>;
};

// @public (undocumented)
const imageLoadPoolManager: RequestPoolManager;
export { imageLoadPoolManager }
export { imageLoadPoolManager as requestPoolManager }

// @public (undocumented)
type ImageLoadStageEventDetail = {
    stageId: string;
    numberOfImages: number;
    numberOfFailures: number;
    stageDurationInMS: number;
    startDurationInMS: number;
};

// @public (undocumented)
interface ImagePixelModule {
    // (undocumented)
    bitsAllocated: number;
    // (undocumented)
    bitsStored: number;
    // (undocumented)
    highBit: number;
    // (undocumented)
    modality: string;
    // (undocumented)
    photometricInterpretation: string;
    // (undocumented)
    pixelRepresentation: string;
    // (undocumented)
    samplesPerPixel: number;
    // (undocumented)
    voiLUTFunction: VOILUTFunctionType;
    // (undocumented)
    windowCenter: number | number[];
    // (undocumented)
    windowWidth: number | number[];
}

// @public (undocumented)
interface ImagePlaneModule {
    // (undocumented)
    columnCosines?: Point3;
    // (undocumented)
    columnPixelSpacing?: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    frameOfReferenceUID: string;
    // (undocumented)
    imageOrientationPatient?: Float32Array;
    // (undocumented)
    imagePositionPatient?: Point3;
    // (undocumented)
    pixelSpacing?: Point2;
    // (undocumented)
    rowCosines?: Point3;
    // (undocumented)
    rowPixelSpacing?: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    sliceLocation?: number;
    // (undocumented)
    sliceThickness?: number;
}

// @public (undocumented)
enum ImageQualityStatus {
    // (undocumented)
    ADJACENT_REPLICATE = 3,
    // (undocumented)
    FAR_REPLICATE = 1,
    // (undocumented)
    FULL_RESOLUTION = 8,
    // (undocumented)
    LOSSY = 7,
    // (undocumented)
    SUBRESOLUTION = 6
}

// @public (undocumented)
type ImageRenderedEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public (undocumented)
type ImageRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    suppressEvents?: boolean;
    viewportStatus: ViewportStatus;
};

// @public (undocumented)
export const imageRetrievalPoolManager: RequestPoolManager;

// @public (undocumented)
const imageRetrieveMetadataProvider: {
    IMAGE_RETRIEVE_CONFIGURATION: string;
    clear: () => void;
    add: (key: string, payload: any) => void;
    get: (type: string, ...queries: string[]) => any;
};

// @public (undocumented)
type ImageSliceData = {
    numberOfSlices: number;
    imageIndex: number;
};

// @public (undocumented)
type ImageSpacingCalibratedEvent = CustomEvent_2<ImageSpacingCalibratedEventDetail>;

// @public (undocumented)
type ImageSpacingCalibratedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    imageId: string;
    calibration: IImageCalibration;
    imageData: vtkImageData;
    worldToIndex: mat4;
};

// @public (undocumented)
function imageToWorldCoords(imageId: string, imageCoords: Point2): Point3 | undefined;

// @public (undocumented)
export class ImageVolume implements IImageVolume {
    constructor(props: ImageVolumeProps);
    // (undocumented)
    additionalDetails?: Record<string, any>;
    // (undocumented)
    cancelLoading: () => void;
    // (undocumented)
    convertToCornerstoneImage(imageId: string, imageIdIndex: number): IImageLoadObject;
    // (undocumented)
    convertToImageSlicesAndCache(): string[];
    // (undocumented)
    protected cornerstoneImageMetaData: any;
    // (undocumented)
    decache(completelyRemove?: boolean): void | Array<string>;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    getCornerstoneImage(imageId: string, imageIdIndex: number): IImage;
    // (undocumented)
    getCornerstoneImageLoadObject(imageId: string, imageIdIndex: number): IImageLoadObject;
    // (undocumented)
    getCornerstoneImages(): IImage[];
    // (undocumented)
    getImageIdIndex(imageId: string): number;
    // (undocumented)
    getImageURIIndex(imageURI: string): number;
    // (undocumented)
    getScalarData(): PixelDataTypedArray;
    // (undocumented)
    getScalarDataArrays(): PixelDataTypedArray[];
    // (undocumented)
    protected getScalarDataByImageIdIndex(imageIdIndex: number): PixelDataTypedArray;
    // (undocumented)
    getScalarDataLength(): number;
    // (undocumented)
    hasPixelSpacing: boolean;
    // (undocumented)
    imageCacheOffsetMap: Map<any, any>;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    protected imageIdIndexToFrameIndex(imageIdIndex: number): number;
    // (undocumented)
    get imageIds(): Array<string>;
    set imageIds(newImageIds: Array<string>);
    // (undocumented)
    isDynamicVolume(): boolean;
    // (undocumented)
    isPreScaled: boolean;
    // (undocumented)
    loadStatus?: Record<string, any>;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    modified(): void;
    // (undocumented)
    protected numFrames: number;
    // (undocumented)
    numVoxels: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedImageIds?: Array<string>;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    removeFromCache(): void;
    // (undocumented)
    protected scalarData: PixelDataTypedArray | Array<PixelDataTypedArray>;
    // (undocumented)
    scaling?: {
        PT?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    protected totalNumFrames: number;
    // (undocumented)
    readonly volumeId: string;
    // (undocumented)
    vtkOpenGLTexture: any;
}

// @public (undocumented)
type ImageVolumeLoadingCompletedEvent = CustomEvent_2<ImageVolumeLoadingCompletedEventDetail>;

// @public (undocumented)
type ImageVolumeLoadingCompletedEventDetail = {
    volumeId: string;
    FrameOfReferenceUID: string;
};

// @public (undocumented)
type ImageVolumeModifiedEvent = CustomEvent_2<ImageVolumeModifiedEventDetail>;

// @public (undocumented)
type ImageVolumeModifiedEventDetail = {
    imageVolume: IImageVolume;
    FrameOfReferenceUID: string;
};

// @public (undocumented)
interface ImageVolumeProps extends VolumeProps {
    // (undocumented)
    imageIds: Array<string>;
    // (undocumented)
    referencedImageIds?: Array<string>;
}

// @public (undocumented)
function indexWithinDimensions(index: Point3, dimensions: Point3): boolean;

// @public (undocumented)
export function init(configuration?: Cornerstone3DConfig): Promise<boolean>;

// @public (undocumented)
type InternalVideoCamera = {
    panWorld?: Point2;
    parallelScale?: number;
};

// @public (undocumented)
enum InterpolationType {
    // (undocumented)
    FAST_LINEAR = 2,
    // (undocumented)
    LINEAR = 1,
    // (undocumented)
    NEAREST = 0
}

// @public (undocumented)
function invertRgbTransferFunction(rgbTransferFunction: any): void;

// @public (undocumented)
interface IRegisterImageLoader {
    // (undocumented)
    registerImageLoader: (scheme: string, imageLoader: ImageLoaderFn) => void;
}

// @public (undocumented)
interface IRenderingEngine {
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(canvas: HTMLCanvasElement, backgroundColor: [number, number, number]): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getVideoViewports(): Array<IVideoViewport>;
    // (undocumented)
    getViewport(id: string): IViewport;
    // (undocumented)
    getViewports(): Array<IViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference(FrameOfReferenceUID: string): void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, keepCamera?: boolean): void;
    // (undocumented)
    setViewports(viewports: Array<PublicViewportInput>): void;
}

// @public (undocumented)
export interface IRetrieveConfiguration {
    // (undocumented)
    create?: (IRetrieveConfiguration: any) => IImagesLoader;
    // (undocumented)
    retrieveOptions?: Record<string, RetrieveOptions>;
    // (undocumented)
    stages?: RetrieveStage[];
}

// @public (undocumented)
export function isCornerstoneInitialized(): boolean;

// @public (undocumented)
function isEqual<ValueType>(v1: ValueType, v2: ValueType, tolerance?: number): boolean;

// @public (undocumented)
function isImageActor(actorEntry: Types.ActorEntry): boolean;

// @public (undocumented)
function isOpposite(v1: Point3, v2: Point3, tolerance?: number): boolean;

// @public (undocumented)
const isPTPrescaledWithSUV: (image: IImage) => number;

// @public (undocumented)
interface IStackInput {
    // (undocumented)
    actorUID?: string;
    // (undocumented)
    callback?: StackInputCallback;
    // (undocumented)
    imageId: string;
    // (undocumented)
    visibility?: boolean;
}

// @public (undocumented)
interface IStackViewport extends IViewport {
    // (undocumented)
    addImages(stackInputs: Array<IStackInput>, immediateRender: boolean, suppressEvents: boolean): any;
    // (undocumented)
    calibrateSpacing(imageId: string): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    clearDefaultProperties(imageId?: string): void;
    // (undocumented)
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCornerstoneImage: () => IImage;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getDefaultProperties: (imageId?: string) => StackViewportProperties;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(): IImageData | CPUIImageData;
    // (undocumented)
    getImageDataMetadata(image: IImage): any;
    // (undocumented)
    getImageIds: () => string[];
    // (undocumented)
    getProperties: () => StackViewportProperties;
    // (undocumented)
    getRenderer(): any;
    // (undocumented)
    hasImageId: (imageId: string) => boolean;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    modality: string;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resetToDefaultProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scaling: Scaling;
    // (undocumented)
    setCamera(cameraInterface: ICamera): void;
    // (undocumented)
    setDefaultProperties(ViewportProperties: StackViewportProperties, imageId?: string): void;
    // (undocumented)
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    // (undocumented)
    setProperties({ voiRange, invert, interpolationType, rotation, colormap, }: StackViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    setStack(imageIds: Array<string>, currentImageIdIndex?: number): Promise<string>;
    // (undocumented)
    stackActorReInitialized: boolean;
    // (undocumented)
    unsetColormap(): void;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
interface IStreamingImageVolume extends ImageVolume {
    // (undocumented)
    clearLoadCallbacks(): void;
    // (undocumented)
    convertToCornerstoneImage(imageId: string, imageIdIndex: number): any;
    // (undocumented)
    decache(completelyRemove: boolean): void;
}

// @public (undocumented)
interface IStreamingVolumeProperties {
    // (undocumented)
    imageIds: Array<string>;
    // (undocumented)
    loadStatus: {
        loaded: boolean;
        loading: boolean;
        cancelled: boolean;
        cachedFrames: Array<ImageQualityStatus>;
        callbacks: Array<() => void>;
    };
}

// @public (undocumented)
interface ISurface {
    // (undocumented)
    readonly frameOfReferenceUID: string;
    // (undocumented)
    getColor(): Point3;
    // (undocumented)
    getPoints(): number[];
    // (undocumented)
    getPolys(): number[];
    // (undocumented)
    getSizeInBytes(): number;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    setColor(color: Point3): void;
    // (undocumented)
    setPoints(points: number[]): void;
    // (undocumented)
    setPolys(polys: number[]): void;
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public (undocumented)
function isValidVolume(imageIds: string[]): boolean;

// @public (undocumented)
function isVideoTransferSyntax(uidOrUids: string | string[]): string | false;

// @public (undocumented)
interface IVideoViewport extends IViewport {
    // (undocumented)
    getCurrentImageId(): string;
    // (undocumented)
    getFrameNumber(): number;
    // (undocumented)
    getFrameRange(): [number, number];
    // (undocumented)
    getProperties: () => VideoViewportProperties;
    // (undocumented)
    pause: () => void;
    // (undocumented)
    play: () => void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    setFrameNumber(frameNo: number): any;
    // (undocumented)
    setFrameRange(range?: [number, number]): any;
    // (undocumented)
    setProperties(props: VideoViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    setTime(time: number): any;
    // (undocumented)
    setVideo: (imageIds: string, imageIdIndex?: number) => Promise<unknown>;
    // (undocumented)
    setVideoURL: (url: string) => void;
}

// @public (undocumented)
interface IViewport {
    // (undocumented)
    _actors: Map<string, any>;
    // (undocumented)
    addActor(actorEntry: ActorEntry): void;
    // (undocumented)
    addActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    addWidget: (id: string, widget: any) => void;
    // (undocumented)
    canvas: HTMLCanvasElement;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => unknown;
    // (undocumented)
    defaultOptions: any;
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    getActor(actorUID: string): ActorEntry;
    // (undocumented)
    getActorByIndex(index: number): ActorEntry;
    // (undocumented)
    getActors(): Array<ActorEntry>;
    // (undocumented)
    getActorUIDByIndex(index: number): string;
    // (undocumented)
    getActorUIDs(): Array<string>;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    // (undocumented)
    getCurrentImageIdIndex(): number;
    // (undocumented)
    getDefaultActor(): ActorEntry;
    // (undocumented)
    getDisplayArea(): DisplayArea | undefined;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getNumberOfSlices(): number;
    // (undocumented)
    getPan(): Point2;
    // (undocumented)
    getReferenceId(viewRefSpecifier?: ViewReferenceSpecifier): string;
    // (undocumented)
    getRenderer(): void;
    // (undocumented)
    getRenderingEngine(): any;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getViewPresentation(viewPresSel?: ViewPresentationSelector): ViewPresentation;
    // (undocumented)
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    // (undocumented)
    getWidget: (id: string) => any;
    // (undocumented)
    getWidgets: () => any;
    // (undocumented)
    getZoom(): number;
    // (undocumented)
    id: string;
    // (undocumented)
    isDisabled: boolean;
    // (undocumented)
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    // (undocumented)
    options: ViewportInputOptions;
    // (undocumented)
    removeActors(actorUIDs: Array<string>): void;
    // (undocumented)
    removeAllActors(): void;
    // (undocumented)
    removeWidgets: () => void;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    reset(immediate: boolean): void;
    // (undocumented)
    setActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    setDisplayArea(displayArea: DisplayArea, callResetCamera?: boolean, suppressEvents?: boolean): any;
    // (undocumented)
    setOptions(options: ViewportInputOptions, immediate: boolean): void;
    // (undocumented)
    setPan(pan: Point2, storeAsInitialCamera?: boolean): any;
    // (undocumented)
    setRendered(): void;
    // (undocumented)
    setView(viewRef?: ViewReference, viewPres?: ViewPresentation): any;
    // (undocumented)
    setZoom(zoom: number, storeAsInitialCamera?: boolean): any;
    // (undocumented)
    sHeight: number;
    // (undocumented)
    suppressEvents: boolean;
    // (undocumented)
    sWidth: number;
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    type: ViewportType;
    // (undocumented)
    updateRenderingPipeline: () => void;
    // (undocumented)
    viewportStatus: ViewportStatus;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
interface IViewportId {
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
type IVolume = ImageVolumeProps;

// @public (undocumented)
interface IVolumeInput {
    // (undocumented)
    actorUID?: string;
    // (undocumented)
    blendMode?: BlendModes;
    // (undocumented)
    callback?: VolumeInputCallback;
    // (undocumented)
    slabThickness?: number;
    // (undocumented)
    visibility?: boolean;
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
interface IVolumeLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IImageVolume>;
}

// @public (undocumented)
interface IVolumeViewport extends IViewport {
    // (undocumented)
    addVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    clearDefaultProperties(volumeId?: string): void;
    // (undocumented)
    flip(flipDirection: FlipDirection): void;
    // (undocumented)
    getBounds(): any;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getDefaultProperties: (volumeId?: string) => VolumeViewportProperties;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(volumeId?: string): IImageData | undefined;
    // (undocumented)
    getImageIds: (volumeId?: string) => string[];
    // (undocumented)
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    getProperties: (volumeId?: string) => VolumeViewportProperties;
    // (undocumented)
    getSlabThickness(): number;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    hasVolumeId: (volumeId: string) => boolean;
    // (undocumented)
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean, resetRotation?: boolean): boolean;
    // (undocumented)
    resetProperties(volumeId: string): void;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: Array<string>, immediate?: boolean): void;
    // (undocumented)
    setDefaultProperties(ViewportProperties: VolumeViewportProperties, volumeId?: string): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis): void;
    // (undocumented)
    setProperties({ voiRange }: VolumeViewportProperties, volumeId?: string, suppressEvents?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: Array<string>): void;
    // (undocumented)
    setVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
function linePlaneIntersection(p0: Point3, p1: Point3, plane: Plane): Point3;

// @public (undocumented)
function loadAndCacheImage(imageId: string, options?: ImageLoaderOptions): Promise<IImage>;

// @public (undocumented)
function loadAndCacheImages(imageIds: Array<string>, options?: ImageLoaderOptions): Promise<IImage>[];

// @public (undocumented)
function loadImage(imageId: string, options?: ImageLoaderOptions): Promise<IImage>;

// @public (undocumented)
function loadImageToCanvas(options: LoadImageOptions): Promise<string>;

// @public (undocumented)
function loadVolume(volumeId: string, options?: VolumeLoaderOptions): Promise<IImageVolume>;

// @public (undocumented)
function makeVolumeMetadata(imageIds: Array<string>): Metadata;

// @public (undocumented)
type Mat3 = [number, number, number, number, number, number, number, number, number] | Float32Array;

// @public (undocumented)
type Metadata = {
    BitsAllocated: number;
    BitsStored: number;
    SamplesPerPixel: number;
    HighBit: number;
    PhotometricInterpretation: string;
    PixelRepresentation: number;
    Modality: string;
    SeriesInstanceUID?: string;
    ImageOrientationPatient: Array<number>;
    PixelSpacing: Array<number>;
    FrameOfReferenceUID: string;
    Columns: number;
    Rows: number;
    voiLut: Array<VOI>;
    VOILUTFunction: string;
};

declare namespace metaData {
    export {
        addProvider,
        removeProvider,
        removeAllProviders,
        getMetaData as get
    }
}
export { metaData }

// @public (undocumented)
enum MetadataModules {
    // (undocumented)
    CALIBRATION = "calibrationModule",
    // (undocumented)
    CINE = "cineModule",
    // (undocumented)
    GENERAL_IMAGE = "generalImageModule",
    // (undocumented)
    GENERAL_SERIES = "generalSeriesModule",
    // (undocumented)
    GENERAL_STUDY = "generalStudyModule",
    // (undocumented)
    IMAGE_PIXEL = "imagePixelModule",
    // (undocumented)
    IMAGE_PLANE = "imagePlaneModule",
    // (undocumented)
    IMAGE_URL = "imageUrlModule",
    // (undocumented)
    MODALITY_LUT = "modalityLutModule",
    // (undocumented)
    MULTIFRAME = "multiframeModule",
    // (undocumented)
    NM_MULTIFRAME_GEOMETRY = "nmMultiframeGeometryModule",
    // (undocumented)
    OVERLAY_PLANE = "overlayPlaneModule",
    // (undocumented)
    PATIENT = "patientModule",
    // (undocumented)
    PATIENT_STUDY = "patientStudyModule",
    // (undocumented)
    PET_IMAGE = "petImageModule",
    // (undocumented)
    PET_ISOTOPE = "petIsotopeModule",
    // (undocumented)
    PET_SERIES = "petSeriesModule",
    // (undocumented)
    SOP_COMMON = "sopCommonModule",
    // (undocumented)
    ULTRASOUND_ENHANCED_REGION = "ultrasoundEnhancedRegionModule",
    // (undocumented)
    VOI_LUT = "voiLutModule"
}

// @public (undocumented)
const metadataProvider: {
    add: (imageId: string, payload: IImageCalibration) => void;
    get: (type: string, imageId: string) => IImageCalibration;
};

// @public (undocumented)
const metadataProvider_2: {
    add: (imageId: string, payload: any) => void;
    get: (type: string, imageId: string) => any;
    clear: () => void;
};

// @public (undocumented)
const mprCameraValues: any;

// @public (undocumented)
class MultiTargetEventListenerManager {
    // (undocumented)
    addEventListener(target: EventTarget, type: string, callback: EventListener, options?: AddEventListenerOptions): void;
    // (undocumented)
    removeEventListener(target: EventTarget, type: string, callback?: EventListener, options?: EventListenerOptions): void;
    // (undocumented)
    reset(): void;
}

// @public (undocumented)
type NearbyFrames = {
    offset: number;
    imageQualityStatus?: ImageQualityStatus;
};

// @public (undocumented)
enum OrientationAxis {
    // (undocumented)
    ACQUISITION = "acquisition",
    // (undocumented)
    AXIAL = "axial",
    // (undocumented)
    CORONAL = "coronal",
    // (undocumented)
    SAGITTAL = "sagittal"
}

// @public (undocumented)
type OrientationVectors = {
    viewPlaneNormal: Point3;
    viewUp: Point3;
};

// @public (undocumented)
function performCacheOptimizationForVolume(volume: any): void;

// @public (undocumented)
type PixelDataTypedArray = Float32Array | Int16Array | Uint16Array | Uint8Array | Int8Array | Uint8ClampedArray;

// @public (undocumented)
type PixelDataTypedArrayString = 'Float32Array' | 'Int16Array' | 'Uint16Array' | 'Uint8Array' | 'Int8Array' | 'Uint8ClampedArray';

declare namespace planar {
    export {
        linePlaneIntersection,
        planeEquation,
        threePlaneIntersection,
        planeDistanceToPoint
    }
}

// @public (undocumented)
type Plane = [number, number, number, number];

// @public (undocumented)
function planeDistanceToPoint(plane: Plane, point: Point3, signed?: boolean): number;

// @public (undocumented)
function planeEquation(normal: Point3, point: Point3 | vec3, normalized?: boolean): Plane;

// @public (undocumented)
type Point2 = [number, number];

// @public (undocumented)
type Point3 = [number, number, number];

// @public (undocumented)
type Point4 = [number, number, number, number];

// @public (undocumented)
class PointsManager<T> {
    constructor(configuration?: PolyDataPointConfiguration);
    // (undocumented)
    array: ArrayBuffer;
    // (undocumented)
    _byteSize: number;
    // (undocumented)
    static create2(initialSize?: number): PointsManager<Point2>;
    // (undocumented)
    static create3(initialSize?: number): PointsManager<Point3>;
    // (undocumented)
    data: Float32Array;
    // (undocumented)
    get dimensionLength(): number;
    // (undocumented)
    get dimensions(): number;
    // (undocumented)
    _dimensions: number;
    // (undocumented)
    forEach(func: (value: T, index: number) => void): void;
    // (undocumented)
    static fromXYZ({ x, y, z }: PointsXYZ): PointsManager<Point3>;
    // (undocumented)
    getPoint(index: number): T;
    // (undocumented)
    getPointArray(index: number): T;
    // (undocumented)
    protected grow(additionalSize?: number, growSize?: number): void;
    // (undocumented)
    growSize: number;
    // (undocumented)
    kIndex: number;
    // (undocumented)
    get length(): number;
    // (undocumented)
    _length: number;
    // (undocumented)
    map<R>(f: (value: any, index: number) => R): R[];
    // (undocumented)
    get points(): T[];
    // (undocumented)
    push(point: T): void;
    // (undocumented)
    reverse(): void;
    // (undocumented)
    sources: PointsManager<T>[];
    // (undocumented)
    subselect(count?: number, offset?: number): PointsManager<T>;
    // (undocumented)
    toXYZ(): PointsXYZ;
}

// @public (undocumented)
type PointsXYZ = {
    x: number[];
    y: number[];
    z: number[];
};

// @public (undocumented)
const presets: ViewportPreset[];

// @public (undocumented)
type PreStackNewImageEvent = CustomEvent_2<PreStackNewImageEventDetail>;

// @public (undocumented)
type PreStackNewImageEventDetail = {
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
class ProgressiveIterator<T> {
    // (undocumented)
    [Symbol.asyncIterator](): AsyncGenerator<any, void, unknown>;
    constructor(name?: any);
    // (undocumented)
    add(x: T, done?: boolean): void;
    // (undocumented)
    static as(promise: any): any;
    // (undocumented)
    done: any;
    // (undocumented)
    donePromise(): Promise<T>;
    // (undocumented)
    forEach(callback: any, errorCallback: any): Promise<void>;
    // (undocumented)
    generate(processFunction: any, errorCallback?: ErrorCallback_2): Promise<any>;
    // (undocumented)
    getDonePromise(): PromiseIterator<T>;
    // (undocumented)
    getNextPromise(): PromiseIterator<T>;
    // (undocumented)
    getRecent(): T;
    // (undocumented)
    name?: string;
    // (undocumented)
    nextPromise(): Promise<T>;
    // (undocumented)
    reject(reason: Error): void;
    // (undocumented)
    resolve(): void;
}

// @public (undocumented)
export class ProgressiveRetrieveImages implements IImagesLoader, IRetrieveConfiguration {
    constructor(imageRetrieveConfiguration: IRetrieveConfiguration);
    // (undocumented)
    static createProgressive: typeof createProgressive;
    // (undocumented)
    static interleavedRetrieveStages: {
        stages: RetrieveStage[];
    };
    // (undocumented)
    loadImages(imageIds: string[], listener: ImageLoadListener): Promise<any>;
    // (undocumented)
    retrieveOptions: Record<string, RetrieveOptions>;
    // (undocumented)
    static sequentialRetrieveStages: {
        stages: RetrieveStage[];
    };
    // (undocumented)
    static singleRetrieveStages: {
        stages: RetrieveStage[];
    };
    // (undocumented)
    stages: RetrieveStage[];
}

// @public (undocumented)
type PTScaling = {
    suvbwToSuvlbm?: number;
    suvbwToSuvbsa?: number;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
type PublicContourSetData = ContourSetData;

// @public (undocumented)
type PublicSurfaceData = {
    id: string;
    data: SurfaceData;
    frameOfReferenceUID: string;
    color?: Point3;
};

// @public (undocumented)
type PublicViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions?: ViewportInputOptions;
};

// @public (undocumented)
type RangeRetrieveOptions = BaseRetrieveOptions & {
    rangeIndex: number;
    chunkSize?: number | ((metadata: any) => number);
};

// @public (undocumented)
type ReferenceCompatibleOptions = {
    withNavigation?: boolean;
    asVolume?: boolean;
    imageURI?: string;
};

// @public (undocumented)
function registerColormap(colormap: ColormapRegistration): void;

// @public (undocumented)
export function registerImageLoader(scheme: string, imageLoader: ImageLoaderFn): void;

// @public (undocumented)
function registerUnknownImageLoader(imageLoader: ImageLoaderFn): ImageLoaderFn;

// @public (undocumented)
function registerUnknownVolumeLoader(volumeLoader: VolumeLoaderFn): VolumeLoaderFn | undefined;

// @public (undocumented)
function registerVolumeLoader(scheme: string, volumeLoader: VolumeLoaderFn): void;

// @public (undocumented)
function removeAllProviders(): void;

// @public (undocumented)
function removeProvider(provider: (type: string, query: any) => {
    any: any;
}): void;

// @public (undocumented)
const RENDERING_DEFAULTS: {
    MINIMUM_SLAB_THICKNESS: number;
    MAXIMUM_RAY_DISTANCE: number;
};

// @public (undocumented)
export class RenderingEngine implements IRenderingEngine {
    constructor(id?: string);
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    _downloadOffScreenCanvas(): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(canvas: HTMLCanvasElement, backgroundColor: [number, number, number]): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getVideoViewports(): Array<IVideoViewport>;
    // (undocumented)
    getViewport(viewportId: string): IViewport;
    // (undocumented)
    getViewports(): Array<IViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference: (FrameOfReferenceUID: string) => void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, keepCamera?: boolean): void;
    // (undocumented)
    setViewports(publicViewportInputEntries: Array<PublicViewportInput>): void;
}

// @public (undocumented)
function renderToCanvasCPU(canvas: HTMLCanvasElement, image: IImage, modality?: string, _renderingEngineId?: string, _viewportOptions?: ViewportInputOptions): Promise<string>;

// @public (undocumented)
function renderToCanvasGPU(canvas: HTMLCanvasElement, image: IImage, modality?: any, renderingEngineId?: string, viewportOptions?: ViewportInputOptions): Promise<string>;

// @public (undocumented)
enum RequestType {
    // (undocumented)
    Compute = "compute",
    // (undocumented)
    Interaction = "interaction",
    // (undocumented)
    Prefetch = "prefetch",
    // (undocumented)
    Thumbnail = "thumbnail"
}

// @public (undocumented)
export function resetUseCPURendering(): void;

// @public (undocumented)
export function resetUseSharedArrayBuffer(): void;

// @public (undocumented)
export type RetrieveOptions = BaseRetrieveOptions | StreamingRetrieveOptions | RangeRetrieveOptions;

// @public (undocumented)
export interface RetrieveStage {
    // (undocumented)
    decimate?: number;
    // (undocumented)
    id: string;
    // (undocumented)
    nearbyFrames?: NearbyFrames[];
    // (undocumented)
    offset?: number;
    // (undocumented)
    positions?: number[];
    // (undocumented)
    priority?: number;
    // (undocumented)
    requestType?: RequestType;
    // (undocumented)
    retrieveType?: string;
}

// @public (undocumented)
type RGB = [number, number, number];

// @public (undocumented)
function rgbToHex(r: any, g: any, b: any): string;

// @public (undocumented)
function roundNumber(value: string | number | (string | number)[], precision?: number): string;

// @public (undocumented)
function roundToPrecision(value: any): number;

// @public (undocumented)
function scaleRGBTransferFunction(rgbTransferFunction: any, scalingFactor: number): void;

// @public (undocumented)
type Scaling = {
    PT?: PTScaling;
};

// @public (undocumented)
type ScalingParameters = {
    rescaleSlope: number;
    rescaleIntercept: number;
    modality: string;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
export function setConfiguration(c: Cornerstone3DConfig): void;

// @public (undocumented)
export function setPreferSizeOverAccuracy(status: boolean): void;

// @public (undocumented)
export class Settings {
    constructor(base?: Settings);
    // (undocumented)
    static assert(subject: Settings): Settings;
    // (undocumented)
    dump(): Record<string, unknown>;
    // (undocumented)
    extend(): Settings;
    // (undocumented)
    static extendRuntimeSettings(): Settings;
    // (undocumented)
    forEach(callback: (key: string, value: unknown) => void): void;
    // (undocumented)
    get(key: string): unknown;
    // (undocumented)
    static getDefaultSettings(subfield?: any): Settings | any;
    // (undocumented)
    static getObjectSettings(subject: unknown, from?: unknown): Settings;
    // (undocumented)
    static getRuntimeSettings(): Settings;
    // (undocumented)
    import(root: Record<string, unknown>): void;
    // (undocumented)
    set(key: string, value: unknown): boolean;
    // (undocumented)
    unset(key: string): boolean;
}

// @public (undocumented)
function setTransferFunctionNodes(transferFunction: any, nodes: any): void;

// @public (undocumented)
function setupCacheOptimizationEventListener(volumeId: any): void;

// @public (undocumented)
export function setUseCPURendering(status: boolean): void;

// @public (undocumented)
export function setUseSharedArrayBuffer(mode: SharedArrayBufferModes | boolean): void;

// @public (undocumented)
export function setVolumesForViewports(renderingEngine: IRenderingEngine, volumeInputs: Array<IVolumeInput>, viewportIds: Array<string>, immediateRender?: boolean, suppressEvents?: boolean): Promise<void>;

// @public (undocumented)
enum SharedArrayBufferModes {
    // (undocumented)
    AUTO = "auto",
    // (undocumented)
    FALSE = "false",
    // (undocumented)
    TRUE = "true"
}

// @public (undocumented)
function snapFocalPointToSlice(focalPoint: Point3, position: Point3, sliceRange: ActorSliceRange, viewPlaneNormal: Point3, spacingInNormalDirection: number, deltaFrames: number): {
    newFocalPoint: Point3;
    newPosition: Point3;
};

// @public (undocumented)
function sortImageIdsAndGetSpacing(imageIds: Array<string>, scanAxisNormal?: vec3): SortedImageIdsItem;

// @public (undocumented)
const spatialRegistrationMetadataProvider: {
    add: (query: string[], payload: mat4) => void;
    get: (type: string, viewportId1: string, viewportId2: string) => mat4;
};

// @public (undocumented)
enum SpeedUnit {
    // (undocumented)
    FRAME = "f",
    // (undocumented)
    SECOND = "s"
}

// @public (undocumented)
type StackInputCallback = (params: {
    imageActor: ImageActor;
    imageId: string;
}) => unknown;

// @public (undocumented)
type StackNewImageEvent = CustomEvent_2<StackNewImageEventDetail>;

// @public (undocumented)
type StackNewImageEventDetail = {
    image: IImage;
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
export class StackViewport extends Viewport implements IStackViewport, IImagesLoader {
    constructor(props: ViewportInput);
    // (undocumented)
    addActor: (actorEntry: ActorEntry) => void;
    // (undocumented)
    addActors: (actors: Array<ActorEntry>) => void;
    // (undocumented)
    addImages(stackInputs: Array<IStackInput>): Promise<void>;
    // (undocumented)
    calibrateSpacing(imageId: string): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    clearDefaultProperties(imageId?: string): void;
    // (undocumented)
    createVTKImageData({ origin, direction, dimensions, spacing, numComps, pixelArray, }: {
        origin: any;
        direction: any;
        dimensions: any;
        spacing: any;
        numComps: any;
        pixelArray: any;
    }): vtkImageData;
    // (undocumented)
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
        viewportStatus: ViewportStatus;
    };
    // (undocumented)
    errorCallback(imageId: any, permanent: any, error: any): void;
    // (undocumented)
    getActor: (actorUID: string) => ActorEntry;
    // (undocumented)
    getActors: () => Array<ActorEntry>;
    // (undocumented)
    getCamera: () => ICamera;
    // (undocumented)
    getCornerstoneImage: () => IImage;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getDefaultActor: () => ActorEntry;
    // (undocumented)
    getDefaultProperties: (imageId?: string) => StackViewportProperties;
    // (undocumented)
    getFrameOfReferenceUID: () => string | undefined;
    // (undocumented)
    getImageData: () => IImageData | CPUIImageData;
    // (undocumented)
    getImageDataMetadata(image: IImage): ImageDataMetaData;
    // (undocumented)
    getImageIds: () => Array<string>;
    // (undocumented)
    getLoaderImageOptions(imageId: string): {
        targetBuffer: {
            type: string;
        };
        preScale: {
            enabled: boolean;
        };
        useRGBA: boolean;
        transferSyntaxUID: any;
        priority: number;
        requestType: RequestType;
        additionalDetails: {
            imageId: string;
            imageIdIndex: number;
        };
    };
    // (undocumented)
    getNumberOfSlices: () => number;
    // (undocumented)
    getProperties: () => StackViewportProperties;
    // (undocumented)
    getReferenceId(specifier?: ViewReferenceSpecifier): string;
    // (undocumented)
    getRenderer: () => any;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getSliceIndex: () => number;
    // (undocumented)
    getTargetImageIdIndex: () => number;
    // (undocumented)
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    // (undocumented)
    hasImageId: (imageId: string) => boolean;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    protected imagesLoader: IImagesLoader;
    // (undocumented)
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    // (undocumented)
    loadImages(imageIds: string[], listener: ImageLoadListener): Promise<unknown>;
    // (undocumented)
    modality: string;
    // (undocumented)
    removeAllActors: () => void;
    // (undocumented)
    renderImageObject: (image: any) => void;
    // (undocumented)
    resetCamera: (resetPan?: boolean, resetZoom?: boolean) => boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resetToDefaultProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scaling: Scaling;
    // (undocumented)
    scroll(delta: number, debounce?: boolean, loop?: boolean): void;
    // (undocumented)
    setActors: (actors: Array<ActorEntry>) => void;
    // (undocumented)
    setCamera: (cameraInterface: ICamera, storeAsInitialCamera?: boolean) => void;
    // (undocumented)
    setDefaultProperties(ViewportProperties: StackViewportProperties, imageId?: string): void;
    // (undocumented)
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    // (undocumented)
    protected setInterpolationType: (interpolationType: InterpolationType) => void;
    // (undocumented)
    setProperties({ colormap, voiRange, VOILUTFunction, invert, interpolationType, rotation, }?: StackViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    protected setRotation: (rotation: number) => void;
    // (undocumented)
    setStack(imageIds: Array<string>, currentImageIdIndex?: number): Promise<string>;
    // (undocumented)
    setUseCPURendering(value: boolean): void;
    // (undocumented)
    setView(viewRef?: ViewReference, viewPres?: ViewPresentation): void;
    // (undocumented)
    stackActorReInitialized: boolean;
    // (undocumented)
    successCallback(imageId: any, image: any): void;
    // (undocumented)
    unsetColormap: () => void;
    // (undocumented)
    updateRenderingPipeline: () => void;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
type StackViewportNewStackEvent = CustomEvent_2<StackViewportNewStackEventDetail>;

// @public (undocumented)
type StackViewportNewStackEventDetail = {
    imageIds: string[];
    viewportId: string;
    element: HTMLDivElement;
    currentImageIdIndex: number;
};

// @public (undocumented)
type StackViewportProperties = ViewportProperties & {
    interpolationType?: InterpolationType;
    rotation?: number;
    suppressEvents?: boolean;
    isComputedVOI?: boolean;
};

// @public (undocumented)
type StackViewportScrollEvent = CustomEvent_2<StackViewportScrollEventDetail>;

// @public (undocumented)
type StackViewportScrollEventDetail = {
    newImageIdIndex: number;
    imageId: string;
    direction: number;
};

// @public (undocumented)
type StreamingRetrieveOptions = BaseRetrieveOptions & {
    streaming: boolean;
};

// @public (undocumented)
export class Surface implements ISurface {
    constructor(props: SurfaceProps);
    // (undocumented)
    readonly frameOfReferenceUID: string;
    // (undocumented)
    getColor(): RGB;
    // (undocumented)
    getPoints(): number[];
    // (undocumented)
    getPolys(): number[];
    // (undocumented)
    getSizeInBytes(): number;
    // (undocumented)
    _getSizeInBytes(): number;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    setColor(color: RGB): void;
    // (undocumented)
    setPoints(points: number[]): void;
    // (undocumented)
    setPolys(polys: number[]): void;
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public (undocumented)
type SurfaceData = {
    points: number[];
    polys: number[];
};

// @public (undocumented)
class TargetEventListeners {
    constructor(target: EventTarget);
    // (undocumented)
    addEventListener(type: string, callback: EventListener, options?: AddEventListenerOptions): void;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    removeEventListener(type: string, callback?: EventListener, options?: EventListenerOptions): void;
    // (undocumented)
    reset(): void;
}

// @public (undocumented)
function threePlaneIntersection(firstPlane: Plane, secondPlane: Plane, thirdPlane: Plane): Point3;

// @public (undocumented)
function toLowHighRange(windowWidth: number, windowCenter: number): {
    lower: number;
    upper: number;
};

// @public (undocumented)
function toWindowLevel(low: number, high: number): {
    windowWidth: number;
    windowCenter: number;
};

declare namespace transferFunctionUtils {
    export {
        getTransferFunctionNodes,
        setTransferFunctionNodes
    }
}

// @public (undocumented)
function transformIndexToWorld(imageData: any, voxelPos: Point3): any;

// @public (undocumented)
type TransformMatrix2D = [number, number, number, number, number, number];

// @public (undocumented)
function transformWorldToIndex(imageData: any, worldPos: Point3): any;

// @public (undocumented)
export function triggerEvent(el: EventTarget, type: string, detail?: unknown): boolean;

declare namespace Types {
    export {
        RetrieveStage,
        RetrieveOptions,
        RangeRetrieveOptions,
        StreamingRetrieveOptions,
        NearbyFrames,
        IRetrieveConfiguration,
        IImagesLoader,
        Cornerstone3DConfig,
        ICamera,
        IStackViewport,
        IVideoViewport,
        IVolumeViewport,
        IEnabledElement,
        ICache,
        IVolume,
        IViewportId,
        IImageVolume,
        ImageVolumeProps,
        IDynamicImageVolume,
        IRenderingEngine,
        ScalingParameters,
        PTScaling,
        PointsManager,
        Scaling,
        IStreamingImageVolume,
        IImage,
        IImageData,
        IImageCalibration,
        CPUIImageData,
        CPUImageData,
        EventTypes,
        ImageLoaderFn,
        VolumeLoaderFn,
        IRegisterImageLoader,
        IStreamingVolumeProperties,
        IViewport,
        ViewReference,
        ViewPresentation,
        ViewPresentationSelector,
        ReferenceCompatibleOptions,
        ViewReferenceSpecifier,
        StackViewportProperties,
        VolumeViewportProperties,
        ViewportProperties,
        PublicViewportInput,
        VolumeActor,
        Actor,
        ActorEntry,
        ImageActor,
        ICanvasActor,
        IImageLoadObject,
        IVolumeLoadObject,
        IVolumeInput,
        VolumeInputCallback,
        IStackInput,
        StackInputCallback,
        ViewportPreset,
        Metadata,
        OrientationVectors,
        AABB2,
        AABB3,
        Point2,
        Point3,
        PointsXYZ,
        Point4,
        Mat3,
        Plane,
        ViewportInputOptions,
        VideoViewportProperties,
        VOIRange,
        VOI,
        DisplayArea,
        FlipDirection,
        ICachedImage,
        ICachedVolume,
        CPUFallbackEnabledElement,
        CPUFallbackViewport,
        CPUFallbackTransform,
        CPUFallbackColormapData,
        CPUFallbackViewportDisplayedArea,
        CPUFallbackColormapsData,
        CPUFallbackColormap,
        TransformMatrix2D,
        CPUFallbackLookupTable,
        CPUFallbackLUT,
        CPUFallbackRenderingTools,
        CustomEvent_2 as CustomEventType,
        ActorSliceRange,
        ImageSliceData,
        IGeometry,
        IGeometryLoadObject,
        ICachedGeometry,
        PublicContourSetData,
        ContourSetData,
        ContourData,
        IContourSet,
        IContour,
        PublicSurfaceData,
        SurfaceData,
        ISurface,
        RGB,
        ColormapPublic,
        ColormapRegistration,
        PixelDataTypedArray,
        PixelDataTypedArrayString,
        ImagePixelModule,
        ImagePlaneModule,
        AffineMatrix,
        ImageLoadListener,
        InternalVideoCamera,
        VideoViewportInput,
        BoundsIJK,
        BoundsLPS,
        Color,
        ColorLUT,
        VolumeProps
    }
}
export { Types }

// @public (undocumented)
function unregisterAllImageLoaders(): void;

// @public (undocumented)
function updateVTKImageDataWithCornerstoneImage(sourceImageData: vtkImageData, image: IImage): void;

declare namespace utilities {
    export {
        eventListener,
        invertRgbTransferFunction,
        createSigmoidRGBTransferFunction,
        getVoiFromSigmoidRGBTransferFunction,
        createLinearRGBTransferFunction,
        scaleRGBTransferFunction as scaleRgbTransferFunction,
        triggerEvent,
        imageIdToURI,
        metadataProvider as calibratedPixelSpacingMetadataProvider,
        clamp,
        uuidv4,
        planar,
        getMinMax,
        getRuntimeId,
        isEqual,
        isOpposite,
        createFloat32SharedArray,
        createUint8SharedArray,
        createUint16SharedArray,
        createInt16SharedArray,
        getViewportModality,
        windowLevel,
        convertToGrayscale,
        getClosestImageId,
        getSpacingInNormalDirection,
        getTargetVolumeAndSpacingInNormalDir,
        getVolumeActorCorners,
        indexWithinDimensions,
        getVolumeViewportsContainingSameVolumes,
        getViewportsWithVolumeId,
        transformWorldToIndex,
        transformIndexToWorld,
        loadImageToCanvas,
        renderToCanvasCPU,
        renderToCanvasGPU,
        worldToImageCoords,
        imageToWorldCoords,
        getVolumeSliceRangeInfo,
        getVolumeViewportScrollInfo,
        getSliceRange,
        snapFocalPointToSlice,
        getImageSliceDataForVolumeViewport,
        isImageActor,
        isPTPrescaledWithSUV,
        actorIsA,
        getViewportsWithImageURI,
        getClosestStackImageIndexForPoint,
        getCurrentVolumeViewportSlice,
        calculateViewportsSpatialRegistration,
        spatialRegistrationMetadataProvider,
        getViewportImageCornersInWorld,
        hasNaNValues,
        applyPreset,
        deepMerge,
        PointsManager,
        getScalingParameters,
        getScalarDataType,
        colormap,
        getImageLegacy,
        ProgressiveIterator,
        decimate,
        imageRetrieveMetadataProvider,
        transferFunctionUtils,
        updateVTKImageDataWithCornerstoneImage,
        sortImageIdsAndGetSpacing,
        makeVolumeMetadata,
        isValidVolume,
        metadataProvider_2 as genericMetadataProvider,
        isVideoTransferSyntax,
        getBufferConfiguration,
        VoxelManager,
        generateVolumePropsFromImageIds,
        convertStackToVolumeViewport,
        convertVolumeToStackViewport,
        cacheUtils,
        roundNumber,
        roundToPrecision,
        getViewportImageIds,
        getRandomSampleFromArray,
        getVolumeId,
        color
    }
}
export { utilities }

// @public (undocumented)
function uuidv4(): string;

declare namespace VideoEnums {
    export {
        SpeedUnit
    }
}

// @public (undocumented)
export class VideoViewport extends Viewport implements IVideoViewport {
    constructor(props: VideoViewportInput);
    // (undocumented)
    addImages(stackInputs: Array<any>): void;
    // (undocumented)
    readonly canvasContext: CanvasRenderingContext2D;
    // (undocumented)
    protected canvasToIndex: (canvasPos: Point2) => Point2;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2, destPos?: Point3) => Point3;
    // (undocumented)
    protected createActorMapper(image: any): CanvasActor;
    // (undocumented)
    customRenderViewportToCanvas: () => void;
    // (undocumented)
    end(): Promise<void>;
    // (undocumented)
    static frameRangeExtractor: RegExp;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCurrentImageId(): string;
    // (undocumented)
    getCurrentImageIdIndex(): number;
    // (undocumented)
    getFrameNumber(): number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getFrameRange(): [number, number];
    // (undocumented)
    getImageData(): {
        dimensions: any;
        spacing: any;
        origin: any;
        direction: any;
        metadata: {
            Modality: any;
        };
        getScalarData: () => CanvasScalarData;
        imageData: {
            getDirection: () => any;
            getDimensions: () => any;
            getRange: () => number[];
            getScalarData: () => CanvasScalarData;
            getSpacing: () => any;
            worldToIndex: (point: Point3) => number[];
            indexToWorld: (point: Point2, destPoint?: Point3) => Point3;
        };
        hasPixelSpacing: boolean;
        calibration: IImageCalibration;
        preScale: {
            scaled: boolean;
        };
    };
    // (undocumented)
    getImageDataMetadata(image: IImage | string): {
        bitsAllocated: number;
        numComps: number;
        origin: any;
        rows: any;
        columns: any;
        direction: number[];
        dimensions: any[];
        spacing: any[];
        hasPixelSpacing: boolean;
        numVoxels: number;
        imagePlaneModule: any;
    };
    // (undocumented)
    getImageIds(): string[];
    // (undocumented)
    getNumberOfSlices: () => number;
    // (undocumented)
    getPan(): Point2;
    // (undocumented)
    getProperties: () => VideoViewportProperties;
    // (undocumented)
    getReferenceId(specifier?: ViewReferenceSpecifier): string;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    protected getScalarData(): CanvasScalarData;
    // (undocumented)
    protected getTransform(): Transform;
    // (undocumented)
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    // (undocumented)
    hasImageURI(imageURI: string): boolean;
    // (undocumented)
    protected imageId: string;
    // (undocumented)
    protected indexToCanvas: (indexPos: Point2) => Point2;
    // (undocumented)
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    // (undocumented)
    protected metadata: any;
    // (undocumented)
    modality: any;
    // (undocumented)
    pause(): Promise<void>;
    // (undocumented)
    play(): Promise<void>;
    // (undocumented)
    readonly renderingEngineId: string;
    // (undocumented)
    resetCamera: () => boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scroll(delta?: number): Promise<void>;
    // (undocumented)
    setAverageWhite(averageWhite: [number, number, number]): void;
    // (undocumented)
    setCamera(camera: ICamera): void;
    // (undocumented)
    protected setColorTransform(): void;
    // (undocumented)
    setFrameNumber(frame: number): Promise<void>;
    // (undocumented)
    setFrameRange(frameRange: number[]): void;
    // (undocumented)
    setPlaybackRate(rate?: number): void;
    // (undocumented)
    setProperties(props: VideoViewportProperties): void;
    // (undocumented)
    setScrollSpeed(scrollSpeed?: number, unit?: VideoEnums.SpeedUnit): void;
    // (undocumented)
    setTime(timeInSeconds: number): Promise<void>;
    // (undocumented)
    setVideo(imageId: string, frameNumber?: number): Promise<unknown>;
    // (undocumented)
    setVideoURL(videoURL: string): Promise<unknown>;
    // (undocumented)
    setVOI(voiRange: VOIRange): void;
    // (undocumented)
    setWindowLevel(windowWidth?: number, windowCenter?: number): void;
    // (undocumented)
    start(): Promise<void>;
    // (undocumented)
    togglePlayPause(): boolean;
    // (undocumented)
    readonly uid: any;
    // (undocumented)
    updateCameraClippingPlanesAndRange(): void;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
type VideoViewportInput = {
    id: string;
    renderingEngineId: string;
    type: ViewportType;
    element: HTMLDivElement;
    sx: number;
    sy: number;
    sWidth: number;
    sHeight: number;
    defaultOptions: any;
    canvas: HTMLCanvasElement;
};

// @public (undocumented)
type VideoViewportProperties = ViewportProperties & {
    loop?: boolean;
    muted?: boolean;
    pan?: Point2;
    playbackRate?: number;
    scrollSpeed?: number;
};

// @public (undocumented)
export class Viewport implements IViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    _actors: Map<string, any>;
    // (undocumented)
    addActor(actorEntry: ActorEntry): void;
    // (undocumented)
    addActors(actors: Array<ActorEntry>, resetCameraPanAndZoom?: boolean): void;
    // (undocumented)
    addWidget: (widgetId: any, widget: any) => void;
    // (undocumented)
    static boundsRadius(bounds: number[]): number;
    // (undocumented)
    protected calibration: IImageCalibration;
    // (undocumented)
    static readonly CameraViewPresentation: ViewPresentationSelector;
    // (undocumented)
    readonly canvas: HTMLCanvasElement;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => unknown;
    // (undocumented)
    readonly defaultOptions: Record<string, any>;
    // (undocumented)
    readonly element: HTMLDivElement;
    // (undocumented)
    protected fitToCanvasCamera: ICamera;
    // (undocumented)
    protected flip({ flipHorizontal, flipVertical }: FlipDirection): void;
    // (undocumented)
    protected flipHorizontal: boolean;
    // (undocumented)
    protected flipVertical: boolean;
    // (undocumented)
    getActor(actorUID: string): ActorEntry;
    // (undocumented)
    getActorByIndex(index: number): ActorEntry;
    // (undocumented)
    getActors(): Array<ActorEntry>;
    // (undocumented)
    getActorUIDByIndex(index: number): string;
    // (undocumented)
    getActorUIDs(): Array<string>;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    getClippingPlanesForActor(actorEntry?: ActorEntry): vtkPlane[];
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    // (undocumented)
    getCurrentImageIdIndex(): number;
    // (undocumented)
    getDefaultActor(): ActorEntry;
    // (undocumented)
    getDisplayArea(): DisplayArea | undefined;
    // (undocumented)
    _getEdges(bounds: Array<number>): Array<[number[], number[]]>;
    // (undocumented)
    _getFocalPointForResetCamera(centeredFocalPoint: Point3, previousCamera: ICamera, { resetPan, resetToCenter }: {
        resetPan?: boolean;
        resetToCenter?: boolean;
    }): Point3;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getNumberOfSlices: () => number;
    // (undocumented)
    getPan(initialCamera?: ICamera): Point2;
    // (undocumented)
    getProperties: () => ViewportProperties;
    // (undocumented)
    getReferenceId(_specifier?: ViewReferenceSpecifier): string;
    // (undocumented)
    getRenderer(): any;
    // (undocumented)
    getRenderingEngine(): IRenderingEngine;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getViewPresentation(viewPresSel?: ViewPresentationSelector): ViewPresentation;
    // (undocumented)
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    // (undocumented)
    protected getVtkActiveCamera(): vtkCamera | vtkSlabCamera;
    // (undocumented)
    getWidget: (id: any) => any;
    // (undocumented)
    getWidgets: () => any[];
    // (undocumented)
    getZoom(compareCamera?: ICamera): number;
    // (undocumented)
    protected hasPixelSpacing: boolean;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    protected initialCamera: ICamera;
    // (undocumented)
    protected insetImageMultiplier: number;
    // (undocumented)
    isDisabled: boolean;
    // (undocumented)
    _isInBounds(point: Point3, bounds: number[]): boolean;
    // (undocumented)
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    // (undocumented)
    options: ViewportInputOptions;
    // (undocumented)
    _removeActor(actorUID: string): void;
    // (undocumented)
    removeActors(actorUIDs: Array<string>): void;
    // (undocumented)
    removeAllActors(): void;
    // (undocumented)
    removeWidgets: () => void;
    // (undocumented)
    render(): void;
    // (undocumented)
    readonly renderingEngineId: string;
    // (undocumented)
    reset(immediate?: boolean): void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean, storeAsInitialCamera?: boolean): boolean;
    // (undocumented)
    protected resetCameraNoEvent(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    setActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    protected setCameraNoEvent(camera: ICamera): void;
    // (undocumented)
    setDisplayArea(displayArea: DisplayArea, suppressEvents?: boolean): void;
    // (undocumented)
    protected setDisplayAreaFit(displayArea: DisplayArea): void;
    // (undocumented)
    protected setDisplayAreaScale(displayArea: DisplayArea): void;
    // (undocumented)
    protected setFitToCanvasCamera(camera: ICamera): void;
    // (undocumented)
    protected setInitialCamera(camera: ICamera): void;
    // (undocumented)
    protected setInterpolationType(_interpolationType: InterpolationType, _arg?: any): void;
    // (undocumented)
    setOptions(options: ViewportInputOptions, immediate?: boolean): void;
    // (undocumented)
    setOrientationOfClippingPlanes(vtkPlanes: Array<vtkPlane>, slabThickness: number, viewPlaneNormal: Point3, focalPoint: Point3): void;
    // (undocumented)
    setPan(pan: Point2, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    setRendered(): void;
    // (undocumented)
    protected setRotation: (_rotation: number) => void;
    // (undocumented)
    setView(viewRef?: ViewReference, viewPres?: ViewPresentation): void;
    // (undocumented)
    setZoom(value: number, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    sHeight: number;
    // (undocumented)
    protected _shouldUseNativeDataType(): boolean;
    // (undocumented)
    _suppressCameraModifiedEvents: boolean;
    // (undocumented)
    readonly suppressEvents: boolean;
    // (undocumented)
    sWidth: number;
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    static readonly TransferViewPresentation: ViewPresentationSelector;
    // (undocumented)
    triggerCameraModifiedEventIfNecessary(previousCamera: ICamera, updatedCamera: ICamera): void;
    // (undocumented)
    readonly type: ViewportType;
    // (undocumented)
    updateCameraClippingPlanesAndRange(): void;
    // (undocumented)
    protected updateClippingPlanesForActors(updatedCamera: ICamera): Promise<void>;
    // (undocumented)
    updateRenderingPipeline: () => void;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    viewportStatus: ViewportStatus;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
type ViewportInputOptions = {
    background?: RGB;
    orientation?: OrientationAxis | OrientationVectors;
    displayArea?: DisplayArea;
    suppressEvents?: boolean;
    parallelProjection?: boolean;
};

// @public (undocumented)
interface ViewportPreset {
    // (undocumented)
    ambient: string;
    // (undocumented)
    colorTransfer: string;
    // (undocumented)
    diffuse: string;
    // (undocumented)
    gradientOpacity: string;
    // (undocumented)
    interpolation: string;
    // (undocumented)
    name: string;
    // (undocumented)
    scalarOpacity: string;
    // (undocumented)
    shade: string;
    // (undocumented)
    specular: string;
    // (undocumented)
    specularPower: string;
}

// @public (undocumented)
type ViewportProperties = {
    voiRange?: VOIRange;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
    colormap?: ColormapPublic;
    interpolationType?: InterpolationType;
    rotation?: number;
};

// @public (undocumented)
enum ViewportStatus {
    // (undocumented)
    LOADING = "loading",
    // (undocumented)
    NO_DATA = "noData",
    // (undocumented)
    PRE_RENDER = "preRender",
    // (undocumented)
    RENDERED = "rendered",
    // (undocumented)
    RESIZE = "resize"
}

// @public (undocumented)
enum ViewportType {
    // (undocumented)
    ORTHOGRAPHIC = "orthographic",
    // (undocumented)
    PERSPECTIVE = "perspective",
    // (undocumented)
    STACK = "stack",
    // (undocumented)
    VIDEO = "video",
    // (undocumented)
    VOLUME_3D = "volume3d"
}

// @public (undocumented)
type ViewPresentation = {
    slabThickness?: number;
    rotation?: number;
    displayArea?: DisplayArea;
    zoom?: number;
    pan?: Point2;
};

// @public (undocumented)
type ViewPresentationSelector = {
    slabThickness?: boolean;
    rotation?: boolean;
    displayArea?: boolean;
    zoom?: boolean;
    pan?: boolean;
    windowLevel?: boolean;
    paletteLut?: boolean;
};

// @public (undocumented)
type ViewReference = {
    FrameOfReferenceUID: string;
    referencedImageId?: string;
    cameraFocalPoint?: Point3;
    viewPlaneNormal?: Point3;
    sliceIndex?: number | [number, number];
    volumeId?: string;
    bounds?: BoundsLPS;
};

// @public (undocumented)
type ViewReferenceSpecifier = {
    sliceIndex?: number | [number, number];
    forFrameOfReference?: boolean;
    points?: Point3[];
    volumeId?: string;
};

// @public (undocumented)
type VOI = {
    windowWidth: number;
    windowCenter: number;
};

// @public (undocumented)
enum VOILUTFunctionType {
    // (undocumented)
    LINEAR = "LINEAR",
    // (undocumented)
    SAMPLED_SIGMOID = "SIGMOID"
}

// @public (undocumented)
type VoiModifiedEvent = CustomEvent_2<VoiModifiedEventDetail>;

// @public (undocumented)
type VoiModifiedEventDetail = {
    viewportId: string;
    range: VOIRange;
    volumeId?: string;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
    invertStateChanged?: boolean;
};

// @public (undocumented)
type VOIRange = {
    upper: number;
    lower: number;
};

// @public (undocumented)
type VolumeActor = vtkVolume;

// @public (undocumented)
type VolumeCacheVolumeAddedEvent = CustomEvent_2<VolumeCacheVolumeAddedEventDetail>;

// @public (undocumented)
type VolumeCacheVolumeAddedEventDetail = {
    volume: ICachedVolume;
};

// @public (undocumented)
type VolumeCacheVolumeRemovedEvent = CustomEvent_2<VolumeCacheVolumeRemovedEventDetail>;

// @public (undocumented)
type VolumeCacheVolumeRemovedEventDetail = {
    volumeId: string;
};

// @public (undocumented)
type VolumeInputCallback = (params: {
    volumeActor: VolumeActor;
    volumeId: string;
}) => unknown;

// @public (undocumented)
type VolumeLoadedEvent = CustomEvent_2<VolumeLoadedEventDetail>;

// @public (undocumented)
type VolumeLoadedEventDetail = {
    volume: IImageVolume;
};

// @public (undocumented)
type VolumeLoadedFailedEvent = CustomEvent_2<VolumeLoadedFailedEventDetail>;

// @public (undocumented)
type VolumeLoadedFailedEventDetail = {
    volumeId: string;
    error: unknown;
};

declare namespace volumeLoader {
    export {
        loadVolume,
        createAndCacheVolume,
        createAndCacheDerivedVolume,
        createLocalVolume,
        createAndCacheVolumeFromImages,
        registerVolumeLoader,
        getVolumeLoaderSchemes,
        registerUnknownVolumeLoader,
        getUnknownVolumeLoaderSchema,
        createAndCacheDerivedSegmentationVolume,
        createLocalSegmentationVolume
    }
}
export { volumeLoader }

// @public (undocumented)
type VolumeLoaderFn = (volumeId: string, options?: Record<string, any>) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
type VolumeNewImageEvent = CustomEvent_2<VolumeNewImageEventDetail>;

// @public (undocumented)
type VolumeNewImageEventDetail = {
    imageIndex: number;
    numberOfSlices: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
interface VolumeProps {
    // (undocumented)
    additionalDetails?: Record<string, any>;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scalarData: PixelDataTypedArray | Array<PixelDataTypedArray>;
    // (undocumented)
    scaling?: {
        PT?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
export class VolumeViewport extends BaseVolumeViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    getCurrentImageId: () => string | undefined;
    // (undocumented)
    getCurrentImageIdIndex: (volumeId?: string) => number;
    // (undocumented)
    getNumberOfSlices: () => number;
    // (undocumented)
    getSliceIndex: () => number;
    // (undocumented)
    getSlicePlaneCoordinates: () => Array<{
        sliceIndex: number;
        point: Point3;
    }>;
    // (undocumented)
    getSlicesClippingPlanes(): Array<{
        sliceIndex: number;
        planes: Array<{
            normal: Point3;
            origin: Point3;
        }>;
    }>;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean, resetRotation?: boolean): boolean;
    // (undocumented)
    resetProperties(volumeId?: string): void;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: any[], immediate?: boolean): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis | OrientationVectors, immediate?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: any[]): void;
    // (undocumented)
    setVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
}

// @public (undocumented)
export class VolumeViewport3D extends BaseVolumeViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number | undefined;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean): boolean;
    // (undocumented)
    resetProperties(volumeId?: string): void;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: string[], immediate?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: Array<string>): void;
}

// @public (undocumented)
type VolumeViewportProperties = ViewportProperties & {
    preset?: string;
    slabThickness?: number;
    orientation?: OrientationAxis;
};

// @public (undocumented)
class VoxelManager<T> {
    constructor(dimensions: any, _get: (index: number) => T, _set?: (index: number, v: T) => boolean | void);
    // (undocumented)
    static addBounds(bounds: BoundsIJK, point: Point3): void;
    // (undocumented)
    static addInstanceToImage(image: IImage): void;
    // (undocumented)
    addPoint(point: Point3 | number): void;
    // (undocumented)
    boundsIJK: BoundsIJK;
    // (undocumented)
    clear(): void;
    // (undocumented)
    static createHistoryVoxelManager<T>(sourceVoxelManager: VoxelManager<T>): VoxelManager<T>;
    // (undocumented)
    static createLazyVoxelManager<T>(dimensions: Point3, planeFactory: (width: number, height: number) => T): VoxelManager<T>;
    // (undocumented)
    static createMapVoxelManager<T>(dimension: Point3): VoxelManager<T>;
    // (undocumented)
    static createNumberVolumeVoxelManager(dimensions: Point3, scalarData: any): VoxelManager<number>;
    // (undocumented)
    static createRGBVolumeVoxelManager(dimensions: Point3, scalarData: any, numComponents: any): VoxelManager<RGB>;
    // (undocumented)
    static createRLEVoxelManager<T>(dimensions: Point3): VoxelManager<T>;
    // (undocumented)
    static createVolumeVoxelManager(dimensions: Point3, scalarData: any, numComponents?: number): VoxelManager<number> | VoxelManager<RGB>;
    // (undocumented)
    readonly dimensions: Point3;
    // (undocumented)
    forEach: (callback: any, options?: any) => void;
    // (undocumented)
    frameSize: number;
    // (undocumented)
    _get: (index: number) => T;
    // (undocumented)
    getArrayOfSlices(): number[];
    // (undocumented)
    getAtIJK: (i: any, j: any, k: any) => T;
    // (undocumented)
    getAtIJKPoint: ([i, j, k]: [any, any, any]) => T;
    // (undocumented)
    getAtIndex: (index: any) => T;
    // (undocumented)
    getBoundsIJK(): BoundsIJK;
    // (undocumented)
    getPixelData: (sliceIndex?: number, pixelData?: PixelDataTypedArray) => PixelDataTypedArray;
    // (undocumented)
    getPointIndices(): number[];
    // (undocumented)
    getPoints(): Point3[];
    // (undocumented)
    isInObject: (pointIPS: any, pointIJK: any) => boolean;
    // (undocumented)
    map: Map<number, T> | RLEVoxelMap<T>;
    // (undocumented)
    modifiedSlices: Set<number>;
    // (undocumented)
    numComps: number;
    // (undocumented)
    points: Set<number>;
    // (undocumented)
    scalarData: PixelDataTypedArray;
    // (undocumented)
    _set: (index: number, v: T) => boolean | void;
    // (undocumented)
    setAtIJK: (i: number, j: number, k: number, v: any) => void;
    // (undocumented)
    setAtIJKPoint: ([i, j, k]: Point3, v: any) => void;
    // (undocumented)
    setAtIndex: (index: any, v: any) => void;
    // (undocumented)
    sourceVoxelManager: VoxelManager<T>;
    // (undocumented)
    toIJK(index: number): Point3;
    // (undocumented)
    toIndex(ijk: Point3): number;
    // (undocumented)
    width: number;
}

declare namespace windowLevel {
    export {
        toWindowLevel,
        toLowHighRange
    }
}

// @public (undocumented)
function worldToImageCoords(imageId: string, worldCoords: Point3): Point2 | undefined;

// (No @packageDocumentation comment for this package)

```

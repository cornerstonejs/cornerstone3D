## API Report File for "@cornerstonejs/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { mat4 } from 'gl-matrix';
import { vec3 } from 'gl-matrix';
import type vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';
import type { vtkCamera } from '@kitware/vtk.js/Rendering/Core/Camera';
import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';
import type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';
import vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import type { vtkObject } from '@kitware/vtk.js/interfaces';
import vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';
import type vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';

// @public (undocumented)
type Actor = vtkActor;

// @public (undocumented)
type ActorEntry = {
    uid: string;
    actor: Actor | VolumeActor | ImageActor;
    referenceId?: string;
    slabThickness?: number;
};

// @public (undocumented)
function actorIsA(actorEntry: Types.ActorEntry, actorType: actorTypes): boolean;

// @public (undocumented)
type ActorSliceRange = {
    actor: VolumeActor;
    viewPlaneNormal: Point3;
    focalPoint: Point3;
    min: number;
    max: number;
    current: number;
};

// @public (undocumented)
function addProvider(provider: (type: string, query: any) => any, priority?: number): void;

// @public (undocumented)
export function addVolumesToViewports(renderingEngine: IRenderingEngine, volumeInputs: Array<IVolumeInput>, viewportIds: Array<string>, immediateRender?: boolean, suppressEvents?: boolean): Promise<void>;

// @public (undocumented)
function applyPreset(actor: VolumeActor, preset: ViewportPreset): void;

// @public (undocumented)
export abstract class BaseVolumeViewport extends Viewport implements IVolumeViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    flip(flipDirection: FlipDirection): void;
    // (undocumented)
    getBounds(): number[];
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(volumeId?: string): IImageData | undefined;
    // (undocumented)
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    getProperties: () => VolumeViewportProperties;
    // (undocumented)
    getSlabThickness(): number;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    hasVolumeId(volumeId: string): boolean;
    // (undocumented)
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean): boolean;
    // (undocumented)
    protected resetVolumeViewportClippingRange(): void;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: string[], immediate?: boolean): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis, immediate?: boolean): void;
    // (undocumented)
    setProperties({ voiRange, VOILUTFunction }?: VolumeViewportProperties, volumeId?: string, suppressEvents?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: string[]): void;
    // (undocumented)
    setVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
enum BlendModes {
    // (undocumented)
    AVERAGE_INTENSITY_BLEND = 3,
    // (undocumented)
    COMPOSITE = 0,
    // (undocumented)
    MAXIMUM_INTENSITY_BLEND = 1,
    // (undocumented)
    MINIMUM_INTENSITY_BLEND = 2
}

// @public (undocumented)
export const cache: Cache_2;

// @public (undocumented)
function calculateViewportsSpatialRegistration(viewport1: IStackViewport, viewport2: IStackViewport): void;

// @public (undocumented)
type CameraModifiedEvent = CustomEvent_2<CameraModifiedEventDetail>;

// @public (undocumented)
type CameraModifiedEventDetail = {
    previousCamera: ICamera;
    camera: ICamera;
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    rotation?: number;
};

// @public (undocumented)
function cancelLoadAll(): void;

// @public (undocumented)
function cancelLoadImage(imageId: string): void;

// @public (undocumented)
function cancelLoadImages(imageIds: Array<string>): void;

// @public (undocumented)
const colormapsData: CPUFallbackColormapsData;

declare namespace CONSTANTS {
    export {
        colormapsData as CPU_COLORMAPS,
        RENDERING_DEFAULTS,
        mprCameraValues as MPR_CAMERA_VALUES,
        EPSILON,
        presets as VIEWPORT_PRESETS
    }
}
export { CONSTANTS }

// @public (undocumented)
type ContourData = {
    points: Point3[];
    type: ContourType;
    color?: Point3;
};

// @public (undocumented)
type ContourSetData = {
    id: string;
    data: ContourData[];
    frameOfReferenceUID: string;
    color?: Point3;
};

// @public (undocumented)
enum ContourType {
    // (undocumented)
    CLOSED_PLANAR = "CLOSED_PLANAR",
    // (undocumented)
    OPEN_PLANAR = "OPEN_PLANAR"
}

// @public (undocumented)
interface CPUFallbackColormap {
    // (undocumented)
    addColor: (rgba: Point4) => void;
    // (undocumented)
    buildLookupTable: (lut: CPUFallbackLookupTable) => void;
    // (undocumented)
    clearColors: () => void;
    // (undocumented)
    createLookupTable: () => CPUFallbackLookupTable;
    // (undocumented)
    getColor: (index: number) => Point4;
    // (undocumented)
    getColorRepeating: (index: number) => Point4;
    // (undocumented)
    getColorSchemeName: () => string;
    // (undocumented)
    getId: () => string;
    // (undocumented)
    getNumberOfColors: () => number;
    // (undocumented)
    insertColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    isValidIndex: (index: number) => boolean;
    // (undocumented)
    removeColor: (index: number) => void;
    // (undocumented)
    setColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    setColorSchemeName: (name: string) => void;
    // (undocumented)
    setNumberOfColors: (numColors: number) => void;
}

// @public (undocumented)
type CPUFallbackColormapData = {
    name: string;
    numOfColors?: number;
    colors?: Point4[];
    segmentedData?: unknown;
    numColors?: number;
    gamma?: number;
};

// @public (undocumented)
type CPUFallbackColormapsData = {
    [key: string]: CPUFallbackColormapData;
};

// @public (undocumented)
interface CPUFallbackEnabledElement {
    // (undocumented)
    canvas?: HTMLCanvasElement;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    image?: IImage;
    // (undocumented)
    invalid?: boolean;
    // (undocumented)
    metadata?: {
        direction?: Mat3;
        dimensions?: Point3;
        spacing?: Point3;
        origin?: Point3;
        imagePlaneModule?: {
            frameOfReferenceUID: string;
            rows: number;
            columns: number;
            imageOrientationPatient: number[];
            rowCosines: Point3;
            columnCosines: Point3;
            imagePositionPatient: number[];
            sliceThickness?: number;
            sliceLocation?: number;
            pixelSpacing: Point2;
            rowPixelSpacing: number;
            columnPixelSpacing: number;
        };
        imagePixelModule?: {
            samplesPerPixel: number;
            photometricInterpretation: string;
            rows: number;
            columns: number;
            bitsAllocated: number;
            bitsStored: number;
            highBit: number;
            pixelRepresentation: number;
            planarConfiguration?: number;
            pixelAspectRatio?: number;
            smallestPixelValue?: number;
            largestPixelValue?: number;
            redPaletteColorLookupTableDescriptor?: number[];
            greenPaletteColorLookupTableDescriptor?: number[];
            bluePaletteColorLookupTableDescriptor?: number[];
            redPaletteColorLookupTableData: number[];
            greenPaletteColorLookupTableData: number[];
            bluePaletteColorLookupTableData: number[];
        };
    };
    // (undocumented)
    needsRedraw?: boolean;
    // (undocumented)
    options?: {
        [key: string]: unknown;
        colormap?: CPUFallbackColormap;
    };
    // (undocumented)
    pan?: Point2;
    // (undocumented)
    renderingTools?: CPUFallbackRenderingTools;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    transform?: CPUFallbackTransform;
    // (undocumented)
    viewport?: CPUFallbackViewport;
    // (undocumented)
    zoom?: number;
}

// @public (undocumented)
interface CPUFallbackLookupTable {
    // (undocumented)
    build: (force: boolean) => void;
    // (undocumented)
    getColor: (scalar: number) => Point4;
    // (undocumented)
    setAlphaRange: (start: number, end: number) => void;
    // (undocumented)
    setHueRange: (start: number, end: number) => void;
    // (undocumented)
    setNumberOfTableValues: (number: number) => void;
    // (undocumented)
    setRamp: (ramp: string) => void;
    // (undocumented)
    setRange: (start: number, end: number) => void;
    // (undocumented)
    setSaturationRange: (start: number, end: number) => void;
    // (undocumented)
    setTableRange: (start: number, end: number) => void;
    // (undocumented)
    setTableValue(index: number, rgba: Point4): any;
    // (undocumented)
    setValueRange: (start: number, end: number) => void;
}

// @public (undocumented)
type CPUFallbackLUT = {
    lut: number[];
};

// @public (undocumented)
type CPUFallbackRenderingTools = {
    renderCanvas?: HTMLCanvasElement;
    lastRenderedIsColor?: boolean;
    lastRenderedImageId?: string;
    lastRenderedViewport?: {
        windowWidth: number | number[];
        windowCenter: number | number[];
        invert: boolean;
        rotation: number;
        hflip: boolean;
        vflip: boolean;
        modalityLUT: CPUFallbackLUT;
        voiLUT: CPUFallbackLUT;
        colormap: unknown;
    };
    renderCanvasContext?: CanvasRenderingContext2D;
    colormapId?: string;
    colorLUT?: CPUFallbackLookupTable;
    renderCanvasData?: ImageData;
};

// @public (undocumented)
interface CPUFallbackTransform {
    // (undocumented)
    clone: () => CPUFallbackTransform;
    // (undocumented)
    getMatrix: () => TransformMatrix2D;
    // (undocumented)
    invert: () => void;
    // (undocumented)
    multiply: (matrix: TransformMatrix2D) => void;
    // (undocumented)
    reset: () => void;
    // (undocumented)
    rotate: (rad: number) => void;
    // (undocumented)
    scale: (sx: number, sy: number) => void;
    // (undocumented)
    transformPoint: (point: Point2) => Point2;
    // (undocumented)
    translate: (x: number, y: number) => void;
}

// @public (undocumented)
type CPUFallbackViewport = {
    scale?: number;
    parallelScale?: number;
    focalPoint?: number[];
    translation?: {
        x: number;
        y: number;
    };
    voi?: {
        windowWidth: number;
        windowCenter: number;
    };
    invert?: boolean;
    pixelReplication?: boolean;
    rotation?: number;
    hflip?: boolean;
    vflip?: boolean;
    modalityLUT?: CPUFallbackLUT;
    voiLUT?: CPUFallbackLUT;
    colormap?: CPUFallbackColormap;
    displayedArea?: CPUFallbackViewportDisplayedArea;
    modality?: string;
};

// @public (undocumented)
type CPUFallbackViewportDisplayedArea = {
    tlhc: {
        x: number;
        y: number;
    };
    brhc: {
        x: number;
        y: number;
    };
    rowPixelSpacing: number;
    columnPixelSpacing: number;
    presentationSizeMode: string;
};

// @public (undocumented)
type CPUIImageData = {
    dimensions: Point3;
    direction: Mat3;
    spacing: Point3;
    origin: Point3;
    imageData: CPUImageData;
    metadata: {
        Modality: string;
    };
    scalarData: number[];
    scaling: Scaling;
    hasPixelSpacing?: boolean;
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
};

// @public (undocumented)
type CPUImageData = {
    worldToIndex?: (point: Point3) => Point3;
    indexToWorld?: (point: Point3) => Point3;
    getWorldToIndex?: () => Point3;
    getIndexToWorld?: () => Point3;
    getSpacing?: () => Point3;
    getDirection?: () => Mat3;
    getScalarData?: () => number[];
    getDimensions?: () => Point3;
};

// @public (undocumented)
function createAndCacheDerivedVolume(referencedVolumeId: string, options: DerivedVolumeOptions): Promise<ImageVolume>;

// @public (undocumented)
function createAndCacheGeometry(geometryId: string, options: GeometryOptions): Promise<IGeometry>;

// @public (undocumented)
function createAndCacheVolume(volumeId: string, options: VolumeLoaderOptions): Promise<Record<string, any>>;

// @public (undocumented)
function createFloat32SharedArray(length: number): Float32Array;

// @public (undocumented)
function createLinearRGBTransferFunction(voiRange: VOIRange): vtkColorTransferFunction;

// @public (undocumented)
function createLocalVolume(options: LocalVolumeOptions, volumeId: string, preventCache?: boolean): ImageVolume;

// @public (undocumented)
function createSigmoidRGBTransferFunction(voiRange: VOIRange, approximationNodes?: number): vtkColorTransferFunction;

// @public (undocumented)
function createUint8SharedArray(length: number): Uint8Array;

// @public (undocumented)
export function createVolumeActor(props: createVolumeActorInterface, element: HTMLDivElement, viewportId: string, suppressEvents?: boolean): Promise<VolumeActor>;

// @public (undocumented)
export function createVolumeMapper(imageData: any, vtkOpenGLTexture: any): any;

// @public (undocumented)
interface CustomEvent_2<T = any> extends Event {
    // (undocumented)
    readonly detail: T;
    // (undocumented)
    initCustomEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, detailArg: T): void;
}

// @public (undocumented)
type ElementDisabledEvent = CustomEvent_2<ElementDisabledEventDetail>;

// @public (undocumented)
type ElementDisabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type ElementEnabledEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public (undocumented)
type ElementEnabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

declare namespace Enums {
    export {
        EVENTS as Events,
        BlendModes,
        InterpolationType,
        RequestType,
        ViewportType,
        OrientationAxis,
        SharedArrayBufferModes,
        GeometryType,
        ContourType,
        VOILUTFunctionType
    }
}
export { Enums }

// @public (undocumented)
const EPSILON = 0.001;

// @public (undocumented)
export enum EVENTS {
    // (undocumented)
    CACHE_SIZE_EXCEEDED = "CACHE_SIZE_EXCEEDED",
    // (undocumented)
    CAMERA_MODIFIED = "CORNERSTONE_CAMERA_MODIFIED",
    // (undocumented)
    CAMERA_RESET = "CORNERSTONE_CAMERA_RESET",
    // (undocumented)
    ELEMENT_DISABLED = "CORNERSTONE_ELEMENT_DISABLED",
    // (undocumented)
    ELEMENT_ENABLED = "CORNERSTONE_ELEMENT_ENABLED",
    // (undocumented)
    GEOMETRY_CACHE_GEOMETRY_ADDED = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED",
    // (undocumented)
    IMAGE_CACHE_IMAGE_ADDED = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED",
    // (undocumented)
    IMAGE_CACHE_IMAGE_REMOVED = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED",
    // (undocumented)
    IMAGE_LOAD_ERROR = "IMAGE_LOAD_ERROR",
    // (undocumented)
    IMAGE_LOAD_FAILED = "CORNERSTONE_IMAGE_LOAD_FAILED",
    // (undocumented)
    IMAGE_LOAD_PROGRESS = "CORNERSTONE_IMAGE_LOAD_PROGRESS",
    // (undocumented)
    IMAGE_LOADED = "CORNERSTONE_IMAGE_LOADED",
    // (undocumented)
    IMAGE_RENDERED = "CORNERSTONE_IMAGE_RENDERED",
    // (undocumented)
    IMAGE_SPACING_CALIBRATED = "CORNERSTONE_IMAGE_SPACING_CALIBRATED",
    // (undocumented)
    IMAGE_VOLUME_MODIFIED = "CORNERSTONE_IMAGE_VOLUME_MODIFIED",
    // (undocumented)
    PRE_STACK_NEW_IMAGE = "CORNERSTONE_PRE_STACK_NEW_IMAGE",
    // (undocumented)
    STACK_NEW_IMAGE = "CORNERSTONE_STACK_NEW_IMAGE",
    // (undocumented)
    STACK_VIEWPORT_NEW_STACK = "CORNERSTONE_STACK_VIEWPORT_NEW_STACK",
    // (undocumented)
    STACK_VIEWPORT_SCROLL = "CORNERSTONE_STACK_VIEWPORT_SCROLL",
    // (undocumented)
    VOI_MODIFIED = "CORNERSTONE_VOI_MODIFIED",
    // (undocumented)
    VOLUME_CACHE_VOLUME_ADDED = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED",
    // (undocumented)
    VOLUME_CACHE_VOLUME_REMOVED = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED",
    // (undocumented)
    VOLUME_LOADED = "CORNERSTONE_VOLUME_LOADED",
    // (undocumented)
    VOLUME_LOADED_FAILED = "CORNERSTONE_VOLUME_LOADED_FAILED",
    // (undocumented)
    VOLUME_NEW_IMAGE = "CORNERSTONE_VOLUME_NEW_IMAGE",
    // (undocumented)
    VOLUME_VIEWPORT_NEW_VOLUME = "CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME"
}

// @public (undocumented)
export const eventTarget: CornerstoneEventTarget;

declare namespace EventTypes {
    export {
        CameraModifiedEventDetail,
        CameraModifiedEvent,
        VoiModifiedEvent,
        VoiModifiedEventDetail,
        ElementDisabledEvent,
        ElementDisabledEventDetail,
        ElementEnabledEvent,
        ElementEnabledEventDetail,
        ImageRenderedEventDetail,
        ImageRenderedEvent,
        ImageVolumeModifiedEvent,
        ImageVolumeModifiedEventDetail,
        ImageLoadedEvent,
        ImageLoadedEventDetail,
        ImageLoadedFailedEventDetail,
        ImageLoadedFailedEvent,
        VolumeLoadedEvent,
        VolumeLoadedEventDetail,
        VolumeLoadedFailedEvent,
        VolumeLoadedFailedEventDetail,
        ImageCacheImageAddedEvent,
        ImageCacheImageAddedEventDetail,
        ImageCacheImageRemovedEvent,
        ImageCacheImageRemovedEventDetail,
        VolumeCacheVolumeAddedEvent,
        VolumeCacheVolumeAddedEventDetail,
        VolumeCacheVolumeRemovedEvent,
        VolumeCacheVolumeRemovedEventDetail,
        StackNewImageEvent,
        StackNewImageEventDetail,
        PreStackNewImageEvent,
        PreStackNewImageEventDetail,
        ImageSpacingCalibratedEvent,
        ImageSpacingCalibratedEventDetail,
        ImageLoadProgressEvent,
        ImageLoadProgressEventDetail,
        VolumeNewImageEvent,
        VolumeNewImageEventDetail,
        StackViewportNewStackEvent,
        StackViewportNewStackEventDetail,
        StackViewportScrollEvent,
        StackViewportScrollEventDetail
    }
}

// @public (undocumented)
type FlipDirection = {
    flipHorizontal?: boolean;
    flipVertical?: boolean;
};

declare namespace geometryLoader {
    export {
        createAndCacheGeometry
    }
}
export { geometryLoader }

// @public (undocumented)
enum GeometryType {
    // (undocumented)
    CONTOUR = "contour"
}

// @public (undocumented)
function getClosestImageId(imageVolume: IImageVolume, worldPos: Point3, viewPlaneNormal: Point3, viewUp: Point3): string;

// @public (undocumented)
function getClosestStackImageIndexForPoint(point: Point3, viewport: IStackViewport): number | null;

// @public (undocumented)
export function getEnabledElement(element: HTMLDivElement | undefined): IEnabledElement | undefined;

// @public (undocumented)
export function getEnabledElementByIds(viewportId: string, renderingEngineId: string): IEnabledElement;

// @public (undocumented)
export function getEnabledElements(): IEnabledElement[];

// @public (undocumented)
function getImageSliceDataForVolumeViewport(viewport: IVolumeViewport): ImageSliceData;

// @public (undocumented)
function getMetaData(type: string, query: string): any;

// @public (undocumented)
function getMinMax(storedPixelData: number[]): {
    min: number;
    max: number;
};

// @public (undocumented)
export function getOrCreateCanvas(element: HTMLDivElement): HTMLCanvasElement;

// @public (undocumented)
export function getRenderingEngine(id: string): IRenderingEngine | undefined;

// @public (undocumented)
export function getRenderingEngines(): IRenderingEngine[] | undefined;

// @public (undocumented)
function getRuntimeId(context?: unknown, separator?: string, max?: number): string;

// @public (undocumented)
export function getShouldUseCPURendering(): boolean;

// @public (undocumented)
export function getShouldUseSharedArrayBuffer(): boolean;

// @public (undocumented)
function getSliceRange(volumeActor: VolumeActor, viewPlaneNormal: Point3, focalPoint: Point3): ActorSliceRange;

// @public (undocumented)
function getSpacingInNormalDirection(imageVolume: IImageVolume, viewPlaneNormal: Point3): number;

// @public (undocumented)
function getTargetVolumeAndSpacingInNormalDir(viewport: IVolumeViewport, camera: ICamera, targetVolumeId?: string): {
    imageVolume: IImageVolume;
    spacingInNormalDirection: number;
};

// @public (undocumented)
function getViewportImageCornersInWorld(viewport: IStackViewport | IVolumeViewport): Point3[];

// @public (undocumented)
function getViewportsWithImageURI(imageURI: string, renderingEngineId?: string): Array<Viewport_2>;

// @public (undocumented)
function getViewportsWithVolumeId(volumeId: string, renderingEngineId?: string): Array<IVolumeViewport>;

// @public (undocumented)
function getVoiFromSigmoidRGBTransferFunction(cfun: vtkColorTransferFunction): [number, number];

// @public (undocumented)
function getVolumeActorCorners(volumeActor: any): Array<Point3>;

// @public (undocumented)
function getVolumeViewportsContainingSameVolumes(targetViewport: IVolumeViewport, renderingEngineId?: string): Array<IVolumeViewport>;

// @public (undocumented)
function hasNaNValues(input: number[] | number): boolean;

// @public (undocumented)
interface ICache {
    // (undocumented)
    getCacheSize: () => number;
    // (undocumented)
    getImageLoadObject: (imageId: string) => IImageLoadObject | void;
    // (undocumented)
    getMaxCacheSize: () => number;
    // (undocumented)
    getVolumeLoadObject: (volumeId: string) => IVolumeLoadObject | void;
    // (undocumented)
    purgeCache: () => void;
    // (undocumented)
    putImageLoadObject: (imageId: string, imageLoadObject: IImageLoadObject) => Promise<any>;
    // (undocumented)
    putVolumeLoadObject: (volumeId: string, volumeLoadObject: IVolumeLoadObject) => Promise<any>;
    // (undocumented)
    setMaxCacheSize: (maxCacheSize: number) => void;
}

// @public (undocumented)
interface ICachedGeometry {
    // (undocumented)
    geometry?: IGeometry;
    // (undocumented)
    geometryId: string;
    // (undocumented)
    geometryLoadObject: IGeometryLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedImage {
    // (undocumented)
    image?: IImage;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageLoadObject: IImageLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedVolume {
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
    // (undocumented)
    volume?: IImageVolume;
    // (undocumented)
    volumeId: string;
    // (undocumented)
    volumeLoadObject: IVolumeLoadObject;
}

// @public (undocumented)
interface ICamera {
    // (undocumented)
    clippingRange?: Point2;
    // (undocumented)
    flipHorizontal?: boolean;
    // (undocumented)
    flipVertical?: boolean;
    // (undocumented)
    focalPoint?: Point3;
    // (undocumented)
    parallelProjection?: boolean;
    // (undocumented)
    parallelScale?: number;
    // (undocumented)
    position?: Point3;
    // (undocumented)
    scale?: number;
    // (undocumented)
    viewAngle?: number;
    // (undocumented)
    viewPlaneNormal?: Point3;
    // (undocumented)
    viewUp?: Point3;
}

// @public (undocumented)
interface IContour {
    // (undocumented)
    color: any;
    // (undocumented)
    getColor(): Point3;
    // (undocumented)
    getFlatPointsArray(): number[];
    // (undocumented)
    getPoints(): Point3[];
    // (undocumented)
    _getSizeInBytes(): number;
    // (undocumented)
    getType(): ContourType;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    points: Point3[];
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public (undocumented)
interface IContourSet {
    // (undocumented)
    contours: IContour[];
    // (undocumented)
    _createEachContour(data: ContourData[]): void;
    // (undocumented)
    readonly frameOfReferenceUID: string;
    // (undocumented)
    getColor(): any;
    // (undocumented)
    getContours(): IContour[];
    // (undocumented)
    getFlatPointsArray(): Point3[];
    // (undocumented)
    getNumberOfContours(): number;
    // (undocumented)
    getNumberOfPointsArray(): number[];
    // (undocumented)
    getNumberOfPointsInAContour(contourIndex: number): number;
    // (undocumented)
    getPointsInContour(contourIndex: number): Point3[];
    // (undocumented)
    getSizeInBytes(): number;
    // (undocumented)
    getTotalNumberOfPoints(): number;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public (undocumented)
interface IEnabledElement {
    // (undocumented)
    FrameOfReferenceUID: string;
    // (undocumented)
    renderingEngine: IRenderingEngine;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewport: IStackViewport | IVolumeViewport;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
interface IGeometry {
    // (undocumented)
    data: ContourSet;
    // (undocumented)
    id: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    type: GeometryType;
}

// @public (undocumented)
interface IGeometryLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IGeometry>;
}

// @public (undocumented)
interface IImage {
    // (undocumented)
    cachedLut?: {
        windowWidth?: number | number[];
        windowCenter?: number | number[];
        invert?: boolean;
        lutArray?: Uint8ClampedArray;
        modalityLUT?: unknown;
        voiLUT?: CPUFallbackLUT;
    };
    // (undocumented)
    color: boolean;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    columnPixelSpacing: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    getCanvas: () => HTMLCanvasElement;
    // (undocumented)
    getPixelData: () => Array<number>;
    // (undocumented)
    height: number;
    // (undocumented)
    imageId: string;
    // (undocumented)
    intercept: number;
    // (undocumented)
    invert: boolean;
    // (undocumented)
    isPreScaled?: boolean;
    // (undocumented)
    maxPixelValue: number;
    // (undocumented)
    minPixelValue: number;
    // (undocumented)
    modalityLUT?: CPUFallbackLUT;
    // (undocumented)
    numComps: number;
    // (undocumented)
    preScale?: {
        scaled: boolean;
        scalingParameters: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    // (undocumented)
    render?: (enabledElement: CPUFallbackEnabledElement, invalidated: boolean) => unknown;
    // (undocumented)
    rgba: boolean;
    // (undocumented)
    rowPixelSpacing: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    sliceThickness?: number;
    // (undocumented)
    slope: number;
    // (undocumented)
    stats?: {
        lastStoredPixelDataToCanvasImageDataTime?: number;
        lastGetPixelDataTime?: number;
        lastPutImageDataTime?: number;
        lastLutGenerateTime?: number;
        lastRenderedViewport?: unknown;
        lastRenderTime?: number;
    };
    // (undocumented)
    voiLUT?: CPUFallbackLUT;
    // (undocumented)
    voiLUTFunction: string;
    // (undocumented)
    width: number;
    // (undocumented)
    windowCenter: number[] | number;
    // (undocumented)
    windowWidth: number[] | number;
}

// @public (undocumented)
interface IImageData {
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    hasPixelSpacing?: boolean;
    // (undocumented)
    imageData: vtkImageData;
    // (undocumented)
    metadata: {
        Modality: string;
    };
    // (undocumented)
    origin: Point3;
    // (undocumented)
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    // (undocumented)
    scalarData: Float32Array;
    // (undocumented)
    scaling?: Scaling;
    // (undocumented)
    spacing: Point3;
}

// @public (undocumented)
interface IImageLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IImage>;
}

// @public (undocumented)
interface IImageVolume {
    // (undocumented)
    cancelLoading?: () => void;
    // (undocumented)
    convertToCornerstoneImage?: (imageId: string, imageIdIndex: number) => IImageLoadObject;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    hasPixelSpacing: boolean;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    imageIds?: Array<string>;
    // (undocumented)
    isPrescaled: boolean;
    // (undocumented)
    loadStatus?: Record<string, any>;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    numVoxels: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scalarData: any;
    // (undocumented)
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    readonly volumeId: string;
    // (undocumented)
    vtkOpenGLTexture: any;
}

// @public (undocumented)
type ImageCacheImageAddedEvent = CustomEvent_2<ImageCacheImageAddedEventDetail>;

// @public (undocumented)
type ImageCacheImageAddedEventDetail = {
    image: ICachedImage;
};

// @public (undocumented)
type ImageCacheImageRemovedEvent = CustomEvent_2<ImageCacheImageRemovedEventDetail>;

// @public (undocumented)
type ImageCacheImageRemovedEventDetail = {
    imageId: string;
};

// @public (undocumented)
function imageIdToURI(imageId: string): string;

// @public (undocumented)
type ImageLoadedEvent = CustomEvent_2<ImageLoadedEventDetail>;

// @public (undocumented)
type ImageLoadedEventDetail = {
    image: IImage;
};

// @public (undocumented)
type ImageLoadedFailedEvent = CustomEvent_2<ImageLoadedFailedEventDetail>;

// @public (undocumented)
type ImageLoadedFailedEventDetail = {
    imageId: string;
    error: unknown;
};

declare namespace imageLoader {
    export {
        loadImage,
        loadAndCacheImage,
        loadAndCacheImages,
        cancelLoadImage,
        cancelLoadImages,
        cancelLoadAll,
        registerImageLoader,
        registerUnknownImageLoader,
        unregisterAllImageLoaders,
        ImageLoaderOptions
    }
}
export { imageLoader }

// @public (undocumented)
type ImageLoaderFn = (imageId: string, options?: Record<string, any>) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
interface ImageLoaderOptions {
    // (undocumented)
    additionalDetails?: Record<string, unknown>;
    // (undocumented)
    priority: number;
    // (undocumented)
    requestType: string;
}

// @public (undocumented)
const imageLoadPoolManager: RequestPoolManager;
export { imageLoadPoolManager }
export { imageLoadPoolManager as requestPoolManager }

// @public (undocumented)
type ImageLoadProgressEvent = CustomEvent_2<ImageLoadProgressEventDetail>;

// @public (undocumented)
type ImageLoadProgressEventDetail = {
    url: string;
    imageId: string;
    loaded: number;
    total: number;
    percent: number;
};

// @public (undocumented)
type ImageRenderedEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public (undocumented)
type ImageRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    suppressEvents?: boolean;
};

// @public (undocumented)
export const imageRetrievalPoolManager: RequestPoolManager;

// @public (undocumented)
type ImageSliceData = {
    numberOfSlices: number;
    imageIndex: number;
};

// @public (undocumented)
type ImageSpacingCalibratedEvent = CustomEvent_2<ImageSpacingCalibratedEventDetail>;

// @public (undocumented)
type ImageSpacingCalibratedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    imageId: string;
    rowScale: number;
    columnScale: number;
    imageData: vtkImageData;
    worldToIndex: mat4;
};

// @public (undocumented)
function imageToWorldCoords(imageId: string, imageCoords: Point2): Point3 | undefined;

// @public (undocumented)
export class ImageVolume implements IImageVolume {
    constructor(props: IVolume);
    // (undocumented)
    cancelLoading: () => void;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    hasPixelSpacing: boolean;
    // (undocumented)
    imageData?: any;
    // (undocumented)
    imageIds?: Array<string>;
    // (undocumented)
    isPrescaled: boolean;
    // (undocumented)
    loadStatus?: Record<string, any>;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    numVoxels: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scalarData: Float32Array | Uint8Array;
    // (undocumented)
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    readonly volumeId: string;
    // (undocumented)
    vtkOpenGLTexture: any;
}

// @public (undocumented)
type ImageVolumeModifiedEvent = CustomEvent_2<ImageVolumeModifiedEventDetail>;

// @public (undocumented)
type ImageVolumeModifiedEventDetail = {
    imageVolume: IImageVolume;
    FrameOfReferenceUID: string;
};

// @public (undocumented)
function indexWithinDimensions(index: Point3, dimensions: Point3): boolean;

// @public (undocumented)
export function init(defaultConfiguration?: {}): Promise<boolean>;

// @public (undocumented)
enum InterpolationType {
    // (undocumented)
    FAST_LINEAR = 2,
    // (undocumented)
    LINEAR = 1,
    // (undocumented)
    NEAREST = 0
}

// @public (undocumented)
function invertRgbTransferFunction(rgbTransferFunction: any): void;

// @public (undocumented)
interface IRegisterImageLoader {
    // (undocumented)
    registerImageLoader: (scheme: string, imageLoader: ImageLoaderFn) => void;
}

// @public (undocumented)
interface IRenderingEngine {
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(canvas: HTMLCanvasElement, backgroundColor: [number, number, number]): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getViewport(id: string): IStackViewport | IVolumeViewport;
    // (undocumented)
    getViewports(): Array<IStackViewport | IVolumeViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference(FrameOfReferenceUID: string): void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, resetPan?: boolean, resetZoom?: boolean): void;
    // (undocumented)
    setViewports(viewports: Array<PublicViewportInput>): void;
}

// @public (undocumented)
export function isCornerstoneInitialized(): boolean;

// @public (undocumented)
function isEqual(v1: number[] | Float32Array, v2: number[] | Float32Array, tolerance?: number): boolean;

// @public (undocumented)
function isImageActor(actorEntry: Types.ActorEntry): boolean;

// @public (undocumented)
function isOpposite(v1: Point3, v2: Point3, tolerance?: number): boolean;

// @public (undocumented)
interface IStackViewport extends IViewport {
    // (undocumented)
    calibrateSpacing(imageId: string): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(): IImageData | CPUIImageData;
    // (undocumented)
    getImageIds: () => string[];
    // (undocumented)
    getProperties: () => StackViewportProperties;
    // (undocumented)
    getRenderer(): any;
    // (undocumented)
    hasImageId: (imageId: string) => boolean;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    modality: string;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scaling: Scaling;
    // (undocumented)
    setCamera(cameraInterface: ICamera): void;
    // (undocumented)
    setColormap(colormap: CPUFallbackColormapData): void;
    // (undocumented)
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    // (undocumented)
    setProperties({ voiRange, invert, interpolationType, rotation }: StackViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    setStack(imageIds: Array<string>, currentImageIdIndex?: number): Promise<string>;
    // (undocumented)
    unsetColormap(): void;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
interface IStreamingImageVolume extends ImageVolume {
    // (undocumented)
    clearLoadCallbacks(): void;
    // (undocumented)
    convertToCornerstoneImage(imageId: string, imageIdIndex: number): any;
    // (undocumented)
    decache(completelyRemove: boolean): void;
}

// @public (undocumented)
interface IStreamingVolumeProperties {
    // (undocumented)
    imageIds: Array<string>;
    // (undocumented)
    loadStatus: {
        loaded: boolean;
        loading: boolean;
        cachedFrames: Array<boolean>;
        callbacks: Array<() => void>;
    };
}

// @public (undocumented)
interface IViewport {
    // (undocumented)
    _actors: Map<string, any>;
    // (undocumented)
    addActor(actorEntry: ActorEntry): void;
    // (undocumented)
    addActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    canvas: HTMLCanvasElement;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => unknown;
    // (undocumented)
    defaultOptions: any;
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    getActor(actorUID: string): ActorEntry;
    // (undocumented)
    getActorByIndex(index: number): ActorEntry;
    // (undocumented)
    getActors(): Array<ActorEntry>;
    // (undocumented)
    getActorUIDByIndex(index: number): string;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    // (undocumented)
    getDefaultActor(): ActorEntry;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getPan(): Point2;
    // (undocumented)
    getRenderer(): void;
    // (undocumented)
    getRenderingEngine(): any;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getZoom(): number;
    // (undocumented)
    id: string;
    // (undocumented)
    isDisabled: boolean;
    // (undocumented)
    options: ViewportInputOptions;
    // (undocumented)
    removeActors(actorUIDs: Array<string>): void;
    // (undocumented)
    removeAllActors(): void;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    reset(immediate: boolean): void;
    // (undocumented)
    setActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    setOptions(options: ViewportInputOptions, immediate: boolean): void;
    // (undocumented)
    setPan(pan: Point2, storeAsInitialCamera?: boolean): any;
    // (undocumented)
    setZoom(zoom: number, storeAsInitialCamera?: boolean): any;
    // (undocumented)
    sHeight: number;
    // (undocumented)
    suppressEvents: boolean;
    // (undocumented)
    sWidth: number;
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    type: ViewportType;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
interface IViewportId {
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
interface IVolume {
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scalarData: Float32Array | Uint8Array;
    // (undocumented)
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
interface IVolumeInput {
    // (undocumented)
    actorUID?: string;
    // (undocumented)
    blendMode?: BlendModes;
    // (undocumented)
    callback?: VolumeInputCallback;
    // (undocumented)
    slabThickness?: number;
    // (undocumented)
    visibility?: boolean;
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
interface IVolumeLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<ImageVolume>;
}

// @public (undocumented)
interface IVolumeViewport extends IViewport {
    // (undocumented)
    addVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    flip(flipDirection: FlipDirection): void;
    // (undocumented)
    getBounds(): any;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(volumeId?: string): IImageData | undefined;
    // (undocumented)
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    getProperties: () => VolumeViewportProperties;
    // (undocumented)
    getSlabThickness(): number;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    hasVolumeId: (volumeId: string) => boolean;
    // (undocumented)
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean): boolean;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: Array<string>, immediate?: boolean): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis): void;
    // (undocumented)
    setProperties({ voiRange }: VolumeViewportProperties, volumeId?: string, suppressEvents?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: Array<string>): void;
    // (undocumented)
    setVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
function linePlaneIntersection(p0: Point3, p1: Point3, plane: Plane): Point3;

// @public (undocumented)
function loadAndCacheImage(imageId: string, options?: ImageLoaderOptions): Promise<IImage>;

// @public (undocumented)
function loadAndCacheImages(imageIds: Array<string>, options?: ImageLoaderOptions): Promise<IImage>[];

// @public (undocumented)
function loadImage(imageId: string, options?: ImageLoaderOptions): Promise<IImage>;

// @public (undocumented)
function loadImageToCanvas(canvas: HTMLCanvasElement, imageId: string, requestType?: RequestType, priority?: number): Promise<string>;

// @public (undocumented)
function loadVolume(volumeId: string, options?: VolumeLoaderOptions): Promise<Types.IImageVolume>;

// @public (undocumented)
type Mat3 = [
number,
number,
number,
number,
number,
number,
number,
number,
number
];

// @public (undocumented)
type Metadata = {
    BitsAllocated: number;
    BitsStored: number;
    SamplesPerPixel: number;
    HighBit: number;
    PhotometricInterpretation: string;
    PixelRepresentation: number;
    Modality: string;
    SeriesInstanceUID?: string;
    ImageOrientationPatient: Array<number>;
    PixelSpacing: Array<number>;
    FrameOfReferenceUID: string;
    Columns: number;
    Rows: number;
    voiLut: Array<VOI>;
    VOILUTFunction: string;
};

declare namespace metaData {
    export {
        addProvider,
        removeProvider,
        removeAllProviders,
        getMetaData as get
    }
}
export { metaData }

// @public (undocumented)
const metadataProvider: {
    add: (imageId: string, payload: [number, number]) => void;
    get: (type: string, imageId: string) => [number, number];
};

// @public (undocumented)
const mprCameraValues: any;

// @public (undocumented)
enum OrientationAxis {
    // (undocumented)
    ACQUISITION = "acquisition",
    // (undocumented)
    AXIAL = "axial",
    // (undocumented)
    CORONAL = "coronal",
    // (undocumented)
    SAGITTAL = "sagittal"
}

// @public (undocumented)
type OrientationVectors = {
    viewPlaneNormal: Point3;
    viewUp: Point3;
};

declare namespace planar {
    export {
        linePlaneIntersection,
        planeEquation,
        threePlaneIntersection,
        planeDistanceToPoint
    }
}

// @public (undocumented)
type Plane = [number, number, number, number];

// @public (undocumented)
function planeDistanceToPoint(plane: Plane, point: Point3, signed?: boolean): number;

// @public (undocumented)
function planeEquation(normal: Point3, point: Point3 | vec3): Plane;

// @public (undocumented)
type Point2 = [number, number];

// @public (undocumented)
type Point3 = [number, number, number];

// @public (undocumented)
type Point4 = [number, number, number, number];

// @public (undocumented)
const presets: ViewportPreset[];

// @public (undocumented)
type PreStackNewImageEvent = CustomEvent_2<PreStackNewImageEventDetail>;

// @public (undocumented)
type PreStackNewImageEventDetail = {
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type PTScaling = {
    suvbwToSuvlbm?: number;
    suvbwToSuvbsa?: number;
};

// @public (undocumented)
type PublicContourSetData = ContourSetData;

// @public (undocumented)
type PublicViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions?: ViewportInputOptions;
};

// @public (undocumented)
export function registerImageLoader(scheme: string, imageLoader: ImageLoaderFn): void;

// @public (undocumented)
function registerUnknownImageLoader(imageLoader: ImageLoaderFn): ImageLoaderFn;

// @public (undocumented)
function registerUnknownVolumeLoader(volumeLoader: Types.VolumeLoaderFn): Types.VolumeLoaderFn | undefined;

// @public (undocumented)
function registerVolumeLoader(scheme: string, volumeLoader: Types.VolumeLoaderFn): void;

// @public (undocumented)
function removeAllProviders(): void;

// @public (undocumented)
function removeProvider(provider: (type: string, query: any) => {
    any: any;
}): void;

// @public (undocumented)
const RENDERING_DEFAULTS: {
    MINIMUM_SLAB_THICKNESS: number;
    MAXIMUM_RAY_DISTANCE: number;
};

// @public (undocumented)
export class RenderingEngine implements IRenderingEngine {
    constructor(id?: string);
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    _downloadOffScreenCanvas(): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(canvas: HTMLCanvasElement, backgroundColor: [number, number, number]): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getViewport(viewportId: string): IStackViewport | IVolumeViewport;
    // (undocumented)
    getViewports(): Array<IStackViewport | IVolumeViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference: (FrameOfReferenceUID: string) => void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, keepCamera?: boolean): void;
    // (undocumented)
    setViewports(publicViewportInputEntries: Array<PublicViewportInput>): void;
}

// @public (undocumented)
function renderToCanvas(canvas: HTMLCanvasElement, image: IImage, modality?: string): void;

// @public (undocumented)
enum RequestType {
    // (undocumented)
    Interaction = "interaction",
    // (undocumented)
    Prefetch = "prefetch",
    // (undocumented)
    Thumbnail = "thumbnail"
}

// @public (undocumented)
export function resetUseCPURendering(): void;

// @public (undocumented)
export function resetUseSharedArrayBuffer(): void;

// @public (undocumented)
function scaleRGBTransferFunction(rgbTransferFunction: any, scalingFactor: number): void;

// @public (undocumented)
type Scaling = {
    PET?: PTScaling;
};

// @public (undocumented)
type ScalingParameters = {
    rescaleSlope: number;
    rescaleIntercept: number;
    modality: string;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
export class Settings {
    constructor(base?: Settings);
    // (undocumented)
    static assert(subject: Settings): Settings;
    // (undocumented)
    dump(): Record<string, unknown>;
    // (undocumented)
    extend(): Settings;
    // (undocumented)
    static extendRuntimeSettings(): Settings;
    // (undocumented)
    forEach(callback: (key: string, value: unknown) => void): void;
    // (undocumented)
    get(key: string): unknown;
    // (undocumented)
    static getDefaultSettings(subfield?: any): Settings | any;
    // (undocumented)
    static getObjectSettings(subject: unknown, from?: unknown): Settings;
    // (undocumented)
    static getRuntimeSettings(): Settings;
    // (undocumented)
    import(root: Record<string, unknown>): void;
    // (undocumented)
    set(key: string, value: unknown): boolean;
    // (undocumented)
    unset(key: string): boolean;
}

// @public (undocumented)
export function setUseCPURendering(status: boolean): void;

// @public (undocumented)
export function setUseSharedArrayBuffer(mode: SharedArrayBufferModes | boolean): void;

// @public (undocumented)
export function setVolumesForViewports(renderingEngine: IRenderingEngine, volumeInputs: Array<IVolumeInput>, viewportIds: Array<string>, immediateRender?: boolean, suppressEvents?: boolean): Promise<void>;

// @public (undocumented)
enum SharedArrayBufferModes {
    // (undocumented)
    AUTO = "auto",
    // (undocumented)
    FALSE = "false",
    // (undocumented)
    TRUE = "true"
}

// @public (undocumented)
function snapFocalPointToSlice(focalPoint: Point3, position: Point3, sliceRange: ActorSliceRange, viewPlaneNormal: Point3, spacingInNormalDirection: number, deltaFrames: number): {
    newFocalPoint: Point3;
    newPosition: Point3;
};

// @public (undocumented)
const spatialRegistrationMetadataProvider: {
    add: (query: string[], payload: mat4) => void;
    get: (type: string, query: string[]) => mat4;
};

// @public (undocumented)
type StackNewImageEvent = CustomEvent_2<StackNewImageEventDetail>;

// @public (undocumented)
type StackNewImageEventDetail = {
    image: IImage;
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
export class StackViewport extends Viewport implements IStackViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addActor(actorEntry: ActorEntry): void;
    // (undocumented)
    addActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    calibrateSpacing(imageId: string): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getActor(actorUID: string): ActorEntry;
    // (undocumented)
    getActors(): Array<ActorEntry>;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getDefaultActor(): ActorEntry;
    // (undocumented)
    getFrameOfReferenceUID: () => string | undefined;
    // (undocumented)
    getImageData(): IImageData | CPUIImageData;
    // (undocumented)
    getImageIds: () => Array<string>;
    // (undocumented)
    getProperties: () => StackViewportProperties;
    // (undocumented)
    getRenderer(): any;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getTargetImageIdIndex: () => number;
    // (undocumented)
    hasImageId: (imageId: string) => boolean;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    modality: string;
    // (undocumented)
    removeAllActors(): void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scaling: Scaling;
    // (undocumented)
    scroll(delta: number, debounce?: boolean, loop?: boolean): void;
    // (undocumented)
    setActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    setColormap(colormap: CPUFallbackColormapData): void;
    // (undocumented)
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    // (undocumented)
    setProperties({ voiRange, VOILUTFunction, invert, interpolationType, rotation, }?: StackViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    setStack(imageIds: Array<string>, currentImageIdIndex?: number): Promise<string>;
    // (undocumented)
    unsetColormap(): void;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
type StackViewportNewStackEvent = CustomEvent_2<StackViewportNewStackEventDetail>;

// @public (undocumented)
type StackViewportNewStackEventDetail = {
    imageIds: string[];
    viewportId: string;
    element: HTMLDivElement;
    currentImageIdIndex: number;
};

// @public (undocumented)
type StackViewportProperties = {
    voiRange?: VOIRange;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
    interpolationType?: InterpolationType;
    rotation?: number;
    suppressEvents?: boolean;
};

// @public (undocumented)
type StackViewportScrollEvent = CustomEvent_2<StackViewportScrollEventDetail>;

// @public (undocumented)
type StackViewportScrollEventDetail = {
    newImageIdIndex: number;
    imageId: string;
    direction: number;
};

// @public (undocumented)
function threePlaneIntersection(firstPlane: Plane, secondPlane: Plane, thirdPlane: Plane): Point3;

// @public (undocumented)
function toLowHighRange(windowWidth: number, windowCenter: number): {
    lower: number;
    upper: number;
};

// @public (undocumented)
function toWindowLevel(low: number, high: number): {
    windowWidth: number;
    windowCenter: number;
};

// @public (undocumented)
type TransformMatrix2D = [number, number, number, number, number, number];

// @public (undocumented)
function transformWorldToIndex(imageData: any, worldPos: Point3): any;

// @public (undocumented)
export function triggerEvent(el: EventTarget, type: string, detail?: unknown): boolean;

declare namespace Types {
    export {
        ICamera,
        IStackViewport,
        IVolumeViewport,
        IEnabledElement,
        ICache,
        IVolume,
        IViewportId,
        IImageVolume,
        IRenderingEngine,
        ScalingParameters,
        PTScaling,
        Scaling,
        IStreamingImageVolume,
        IImage,
        IImageData,
        CPUIImageData,
        CPUImageData,
        EventTypes,
        ImageLoaderFn,
        VolumeLoaderFn,
        IRegisterImageLoader,
        IStreamingVolumeProperties,
        IViewport,
        StackViewportProperties,
        VolumeViewportProperties,
        PublicViewportInput,
        VolumeActor,
        Actor,
        ActorEntry,
        IImageLoadObject,
        IVolumeLoadObject,
        IVolumeInput,
        VolumeInputCallback,
        ViewportPreset,
        Metadata,
        OrientationVectors,
        Point2,
        Point3,
        Point4,
        Mat3,
        Plane,
        ViewportInputOptions,
        VOIRange,
        VOI,
        FlipDirection,
        ICachedImage,
        ICachedVolume,
        CPUFallbackEnabledElement,
        CPUFallbackViewport,
        CPUFallbackTransform,
        CPUFallbackColormapData,
        CPUFallbackViewportDisplayedArea,
        CPUFallbackColormapsData,
        CPUFallbackColormap,
        TransformMatrix2D,
        CPUFallbackLookupTable,
        CPUFallbackLUT,
        CPUFallbackRenderingTools,
        CustomEvent_2 as CustomEventType,
        ActorSliceRange,
        ImageSliceData,
        IGeometry,
        IGeometryLoadObject,
        ICachedGeometry,
        PublicContourSetData,
        ContourSetData,
        ContourData,
        IContourSet,
        IContour
    }
}
export { Types }

// @public (undocumented)
function unregisterAllImageLoaders(): void;

declare namespace utilities {
    export {
        invertRgbTransferFunction,
        createSigmoidRGBTransferFunction,
        getVoiFromSigmoidRGBTransferFunction,
        createLinearRGBTransferFunction,
        scaleRGBTransferFunction as scaleRgbTransferFunction,
        triggerEvent,
        imageIdToURI,
        metadataProvider as calibratedPixelSpacingMetadataProvider,
        uuidv4,
        planar,
        getMinMax,
        getRuntimeId,
        isEqual,
        isOpposite,
        createFloat32SharedArray,
        createUint8SharedArray,
        windowLevel,
        getClosestImageId,
        getSpacingInNormalDirection,
        getTargetVolumeAndSpacingInNormalDir,
        getVolumeActorCorners,
        indexWithinDimensions,
        getVolumeViewportsContainingSameVolumes,
        getViewportsWithVolumeId,
        transformWorldToIndex,
        loadImageToCanvas,
        renderToCanvas,
        worldToImageCoords,
        imageToWorldCoords,
        getSliceRange,
        snapFocalPointToSlice,
        getImageSliceDataForVolumeViewport,
        isImageActor,
        actorIsA,
        getViewportsWithImageURI,
        getClosestStackImageIndexForPoint,
        calculateViewportsSpatialRegistration,
        spatialRegistrationMetadataProvider,
        getViewportImageCornersInWorld,
        hasNaNValues,
        applyPreset
    }
}
export { utilities }

// @public (undocumented)
function uuidv4(): string;

// @public (undocumented)
export class Viewport implements IViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    _actors: Map<string, any>;
    // (undocumented)
    addActor(actorEntry: ActorEntry): void;
    // (undocumented)
    addActors(actors: Array<ActorEntry>, resetCameraPanAndZoom?: boolean): void;
    // (undocumented)
    readonly canvas: HTMLCanvasElement;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => unknown;
    // (undocumented)
    readonly defaultOptions: any;
    // (undocumented)
    readonly element: HTMLDivElement;
    // (undocumented)
    protected flip({ flipHorizontal, flipVertical }: FlipDirection): void;
    // (undocumented)
    protected flipHorizontal: boolean;
    // (undocumented)
    protected flipVertical: boolean;
    // (undocumented)
    getActor(actorUID: string): ActorEntry;
    // (undocumented)
    getActorByIndex(index: number): ActorEntry;
    // (undocumented)
    getActors(): Array<ActorEntry>;
    // (undocumented)
    getActorUIDByIndex(index: number): string;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    // (undocumented)
    getDefaultActor(): ActorEntry;
    // (undocumented)
    _getEdges(bounds: Array<number>): Array<[number[], number[]]>;
    // (undocumented)
    _getFocalPointForResetCamera(centeredFocalPoint: Point3, previousCamera: ICamera, { resetPan, resetToCenter }: {
        resetPan?: boolean;
        resetToCenter?: boolean;
    }): Point3;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getPan(): Point2;
    // (undocumented)
    getProperties: () => void;
    // (undocumented)
    getRenderer(): any;
    // (undocumented)
    getRenderingEngine(): IRenderingEngine;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    protected getVtkActiveCamera(): vtkCamera | vtkSlabCamera;
    // (undocumented)
    getZoom(): number;
    // (undocumented)
    protected hasPixelSpacing: boolean;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    protected initialCamera: ICamera;
    // (undocumented)
    isDisabled: boolean;
    // (undocumented)
    _isInBounds(point: Point3, bounds: number[]): boolean;
    // (undocumented)
    options: ViewportInputOptions;
    // (undocumented)
    _removeActor(actorUID: string): void;
    // (undocumented)
    removeActors(actorUIDs: Array<string>): void;
    // (undocumented)
    removeAllActors(): void;
    // (undocumented)
    render(): void;
    // (undocumented)
    readonly renderingEngineId: string;
    // (undocumented)
    reset(immediate?: boolean): void;
    // (undocumented)
    protected resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean, storeAsInitialCamera?: boolean): boolean;
    // (undocumented)
    protected resetCameraNoEvent(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    setActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    protected setCameraNoEvent(camera: ICamera): void;
    // (undocumented)
    protected setInitialCamera(camera: ICamera): void;
    // (undocumented)
    setOptions(options: ViewportInputOptions, immediate?: boolean): void;
    // (undocumented)
    setOrientationOfClippingPlanes(vtkPlanes: Array<vtkPlane>, slabThickness: number, viewPlaneNormal: Point3, focalPoint: Point3): void;
    // (undocumented)
    setPan(pan: Point2, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    setZoom(value: number, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    sHeight: number;
    // (undocumented)
    readonly suppressEvents: boolean;
    // (undocumented)
    sWidth: number;
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    triggerCameraModifiedEventIfNecessary(previousCamera: ICamera, updatedCamera: ICamera): void;
    // (undocumented)
    readonly type: ViewportType;
    // (undocumented)
    protected updateClippingPlanesForActors(updatedCamera: ICamera): void;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
type ViewportInputOptions = {
    background?: [number, number, number];
    orientation?: OrientationAxis | OrientationVectors;
    suppressEvents?: boolean;
    parallelProjection?: boolean;
};

// @public (undocumented)
interface ViewportPreset {
    // (undocumented)
    ambient: string;
    // (undocumented)
    colorTransfer: string;
    // (undocumented)
    diffuse: string;
    // (undocumented)
    gradientOpacity: string;
    // (undocumented)
    interpolation: string;
    // (undocumented)
    name: string;
    // (undocumented)
    scalarOpacity: string;
    // (undocumented)
    shade: string;
    // (undocumented)
    specular: string;
    // (undocumented)
    specularPower: string;
}

// @public (undocumented)
enum ViewportType {
    // (undocumented)
    ORTHOGRAPHIC = "orthographic",
    // (undocumented)
    PERSPECTIVE = "perspective",
    // (undocumented)
    STACK = "stack",
    // (undocumented)
    VOLUME_3D = "volume3d"
}

// @public (undocumented)
type VOI = {
    windowWidth: number;
    windowCenter: number;
};

// @public (undocumented)
enum VOILUTFunctionType {
    // (undocumented)
    LINEAR = "LINEAR",
    // (undocumented)
    SAMPLED_SIGMOID = "SIGMOID"
}

// @public (undocumented)
type VoiModifiedEvent = CustomEvent_2<VoiModifiedEventDetail>;

// @public (undocumented)
type VoiModifiedEventDetail = {
    viewportId: string;
    range: VOIRange;
    volumeId?: string;
    VOILUTFunction?: VOILUTFunctionType;
};

// @public (undocumented)
type VOIRange = {
    upper: number;
    lower: number;
};

// @public (undocumented)
type VolumeActor = vtkVolume;

// @public (undocumented)
type VolumeCacheVolumeAddedEvent = CustomEvent_2<VolumeCacheVolumeAddedEventDetail>;

// @public (undocumented)
type VolumeCacheVolumeAddedEventDetail = {
    volume: ICachedVolume;
};

// @public (undocumented)
type VolumeCacheVolumeRemovedEvent = CustomEvent_2<VolumeCacheVolumeRemovedEventDetail>;

// @public (undocumented)
type VolumeCacheVolumeRemovedEventDetail = {
    volumeId: string;
};

// @public (undocumented)
type VolumeInputCallback = (params: {
    volumeActor: VolumeActor;
    volumeId: string;
}) => unknown;

// @public (undocumented)
type VolumeLoadedEvent = CustomEvent_2<VolumeLoadedEventDetail>;

// @public (undocumented)
type VolumeLoadedEventDetail = {
    volume: IImageVolume;
};

// @public (undocumented)
type VolumeLoadedFailedEvent = CustomEvent_2<VolumeLoadedFailedEventDetail>;

// @public (undocumented)
type VolumeLoadedFailedEventDetail = {
    volumeId: string;
    error: unknown;
};

declare namespace volumeLoader {
    export {
        loadVolume,
        createAndCacheVolume,
        createAndCacheDerivedVolume,
        createLocalVolume,
        registerVolumeLoader,
        registerUnknownVolumeLoader
    }
}
export { volumeLoader }

// @public (undocumented)
type VolumeLoaderFn = (volumeId: string, options?: Record<string, any>) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
type VolumeNewImageEvent = CustomEvent_2<VolumeNewImageEventDetail>;

// @public (undocumented)
type VolumeNewImageEventDetail = {
    imageIndex: number;
    numberOfSlices: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
export class VolumeViewport extends BaseVolumeViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    getCurrentImageId: () => string | undefined;
    // (undocumented)
    getCurrentImageIdIndex: () => number | undefined;
    // (undocumented)
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getSlabThickness(): number;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean): boolean;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: any[], immediate?: boolean): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis, immediate?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: any[]): void;
    // (undocumented)
    setVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
}

// @public (undocumented)
type VolumeViewportProperties = {
    voiRange?: VOIRange;
    VOILUTFunction?: VOILUTFunctionType;
};

declare namespace windowLevel {
    export {
        toWindowLevel,
        toLowHighRange
    }
}

// @public (undocumented)
function worldToImageCoords(imageId: string, worldCoords: Point3): Point2 | undefined;

// (No @packageDocumentation comment for this package)

```

## API Report File for "@cornerstonejs/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { mat4 } from 'gl-matrix';
import { vec3 } from 'gl-matrix';
import type vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';
import type { vtkCamera } from '@kitware/vtk.js/Rendering/Core/Camera';
import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';
import type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';
import vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import type { vtkObject } from '@kitware/vtk.js/interfaces';
import vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';
import type vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';

// @public (undocumented)
type Actor = vtkActor;

// @public (undocumented)
type ActorEntry = {
    uid: string;
    actor: Actor | VolumeActor | ImageActor;
    referenceId?: string;
    slabThickness?: number;
};

// @public (undocumented)
function actorIsA(actorEntry: Types.ActorEntry, actorType: actorTypes): boolean;

// @public (undocumented)
type ActorSliceRange = {
    actor: VolumeActor;
    viewPlaneNormal: Point3;
    focalPoint: Point3;
    min: number;
    max: number;
    current: number;
};

// @public (undocumented)
function addProvider(provider: (type: string, query: any) => any, priority?: number): void;

// @public (undocumented)
export function addVolumesToViewports(renderingEngine: IRenderingEngine, volumeInputs: Array<IVolumeInput>, viewportIds: Array<string>, immediateRender?: boolean, suppressEvents?: boolean): Promise<void>;

// @public (undocumented)
function applyPreset(actor: VolumeActor, preset: ViewportPreset): void;

// @public (undocumented)
export abstract class BaseVolumeViewport extends Viewport implements IVolumeViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    protected applyViewOrientation(orientation: OrientationAxis | OrientationVectors): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    flip(flipDirection: FlipDirection): void;
    // (undocumented)
    getBounds(): number[];
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(volumeId?: string): IImageData | undefined;
    // (undocumented)
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    protected _getOrientationVectors(orientation: OrientationAxis | OrientationVectors): OrientationVectors;
    // (undocumented)
    getProperties: () => VolumeViewportProperties;
    // (undocumented)
    getSlabThickness(): number;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    hasVolumeId(volumeId: string): boolean;
    // (undocumented)
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean): boolean;
    // (undocumented)
    protected resetVolumeViewportClippingRange(): void;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: string[], immediate?: boolean): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis, immediate?: boolean): void;
    // (undocumented)
    setProperties({ voiRange, VOILUTFunction, invert, colormap, preset, }?: VolumeViewportProperties, volumeId?: string, suppressEvents?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: string[]): void;
    // (undocumented)
    setVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    use16BitTexture: boolean;
    // (undocumented)
    useCPURendering: boolean;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
enum BlendModes {
    // (undocumented)
    AVERAGE_INTENSITY_BLEND = 3,
    // (undocumented)
    COMPOSITE = 0,
    // (undocumented)
    MAXIMUM_INTENSITY_BLEND = 1,
    // (undocumented)
    MINIMUM_INTENSITY_BLEND = 2
}

// @public (undocumented)
export const cache: Cache_2;

// @public (undocumented)
function calculateViewportsSpatialRegistration(viewport1: IStackViewport, viewport2: IStackViewport): void;

// @public (undocumented)
type CameraModifiedEvent = CustomEvent_2<CameraModifiedEventDetail>;

// @public (undocumented)
type CameraModifiedEventDetail = {
    previousCamera: ICamera;
    camera: ICamera;
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    rotation?: number;
};

// @public (undocumented)
function cancelLoadAll(): void;

// @public (undocumented)
function cancelLoadImage(imageId: string): void;

// @public (undocumented)
function cancelLoadImages(imageIds: Array<string>): void;

declare namespace colormap {
    export {
        getColormap,
        getColormapNames,
        registerColormap
    }
}

// @public (undocumented)
type ColormapPublic = {
    name: string;
    opacityMapping?: OpacityMapping[];
};

// @public (undocumented)
type ColormapRegistration = {
    ColorSpace: string;
    Name: string;
    RGBPoints: RGB[];
};

// @public (undocumented)
const colormapsData: CPUFallbackColormapsData;

declare namespace CONSTANTS {
    export {
        colormapsData as CPU_COLORMAPS,
        RENDERING_DEFAULTS,
        mprCameraValues as MPR_CAMERA_VALUES,
        EPSILON,
        presets as VIEWPORT_PRESETS
    }
}
export { CONSTANTS }

// @public (undocumented)
type ContourData = {
    points: Point3[];
    type: ContourType;
    color: Point3;
    segmentIndex: number;
};

// @public (undocumented)
type ContourSetData = {
    id: string;
    data: ContourData[];
    frameOfReferenceUID: string;
    color?: Point3;
    segmentIndex?: number;
};

// @public (undocumented)
enum ContourType {
    // (undocumented)
    CLOSED_PLANAR = "CLOSED_PLANAR",
    // (undocumented)
    OPEN_PLANAR = "OPEN_PLANAR"
}

// @public (undocumented)
type Cornerstone3DConfig = {
    detectGPU: any;
    rendering: {
        preferSizeOverAccuracy: boolean;
        useNorm16Texture: boolean;
        useCPURendering: boolean;
        strictZSpacingForVolumeViewport: boolean;
    };
};

// @public (undocumented)
interface CPUFallbackColormap {
    // (undocumented)
    addColor: (rgba: Point4) => void;
    // (undocumented)
    buildLookupTable: (lut: CPUFallbackLookupTable) => void;
    // (undocumented)
    clearColors: () => void;
    // (undocumented)
    createLookupTable: () => CPUFallbackLookupTable;
    // (undocumented)
    getColor: (index: number) => Point4;
    // (undocumented)
    getColorRepeating: (index: number) => Point4;
    // (undocumented)
    getColorSchemeName: () => string;
    // (undocumented)
    getId: () => string;
    // (undocumented)
    getNumberOfColors: () => number;
    // (undocumented)
    insertColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    isValidIndex: (index: number) => boolean;
    // (undocumented)
    removeColor: (index: number) => void;
    // (undocumented)
    setColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    setColorSchemeName: (name: string) => void;
    // (undocumented)
    setNumberOfColors: (numColors: number) => void;
}

// @public (undocumented)
type CPUFallbackColormapData = {
    name: string;
    numOfColors?: number;
    colors?: Point4[];
    segmentedData?: unknown;
    numColors?: number;
    gamma?: number;
};

// @public (undocumented)
type CPUFallbackColormapsData = {
    [key: string]: CPUFallbackColormapData;
};

// @public (undocumented)
interface CPUFallbackEnabledElement {
    // (undocumented)
    canvas?: HTMLCanvasElement;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    image?: IImage;
    // (undocumented)
    invalid?: boolean;
    // (undocumented)
    metadata?: {
        direction?: Mat3;
        dimensions?: Point3;
        spacing?: Point3;
        origin?: Point3;
        imagePlaneModule?: ImagePlaneModule;
        imagePixelModule?: ImagePixelModule;
    };
    // (undocumented)
    needsRedraw?: boolean;
    // (undocumented)
    options?: {
        [key: string]: unknown;
        colormap?: CPUFallbackColormap;
    };
    // (undocumented)
    pan?: Point2;
    // (undocumented)
    renderingTools?: CPUFallbackRenderingTools;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    transform?: CPUFallbackTransform;
    // (undocumented)
    viewport?: CPUFallbackViewport;
    // (undocumented)
    zoom?: number;
}

// @public (undocumented)
interface CPUFallbackLookupTable {
    // (undocumented)
    build: (force: boolean) => void;
    // (undocumented)
    getColor: (scalar: number) => Point4;
    // (undocumented)
    setAlphaRange: (start: number, end: number) => void;
    // (undocumented)
    setHueRange: (start: number, end: number) => void;
    // (undocumented)
    setNumberOfTableValues: (number: number) => void;
    // (undocumented)
    setRamp: (ramp: string) => void;
    // (undocumented)
    setRange: (start: number, end: number) => void;
    // (undocumented)
    setSaturationRange: (start: number, end: number) => void;
    // (undocumented)
    setTableRange: (start: number, end: number) => void;
    // (undocumented)
    setTableValue(index: number, rgba: Point4): any;
    // (undocumented)
    setValueRange: (start: number, end: number) => void;
}

// @public (undocumented)
type CPUFallbackLUT = {
    lut: number[];
};

// @public (undocumented)
type CPUFallbackRenderingTools = {
    renderCanvas?: HTMLCanvasElement;
    lastRenderedIsColor?: boolean;
    lastRenderedImageId?: string;
    lastRenderedViewport?: {
        windowWidth: number | number[];
        windowCenter: number | number[];
        invert: boolean;
        rotation: number;
        hflip: boolean;
        vflip: boolean;
        modalityLUT: CPUFallbackLUT;
        voiLUT: CPUFallbackLUT;
        colormap: unknown;
    };
    renderCanvasContext?: CanvasRenderingContext2D;
    colormapId?: string;
    colorLUT?: CPUFallbackLookupTable;
    renderCanvasData?: ImageData;
};

// @public (undocumented)
interface CPUFallbackTransform {
    // (undocumented)
    clone: () => CPUFallbackTransform;
    // (undocumented)
    getMatrix: () => TransformMatrix2D;
    // (undocumented)
    invert: () => void;
    // (undocumented)
    multiply: (matrix: TransformMatrix2D) => void;
    // (undocumented)
    reset: () => void;
    // (undocumented)
    rotate: (rad: number) => void;
    // (undocumented)
    scale: (sx: number, sy: number) => void;
    // (undocumented)
    transformPoint: (point: Point2) => Point2;
    // (undocumented)
    translate: (x: number, y: number) => void;
}

// @public (undocumented)
type CPUFallbackViewport = {
    scale?: number;
    parallelScale?: number;
    focalPoint?: number[];
    translation?: {
        x: number;
        y: number;
    };
    voi?: {
        windowWidth: number;
        windowCenter: number;
    };
    invert?: boolean;
    pixelReplication?: boolean;
    rotation?: number;
    hflip?: boolean;
    vflip?: boolean;
    modalityLUT?: CPUFallbackLUT;
    voiLUT?: CPUFallbackLUT;
    colormap?: CPUFallbackColormap;
    displayedArea?: CPUFallbackViewportDisplayedArea;
    modality?: string;
};

// @public (undocumented)
type CPUFallbackViewportDisplayedArea = {
    tlhc: {
        x: number;
        y: number;
    };
    brhc: {
        x: number;
        y: number;
    };
    rowPixelSpacing: number;
    columnPixelSpacing: number;
    presentationSizeMode: string;
};

// @public (undocumented)
type CPUIImageData = {
    dimensions: Point3;
    direction: Mat3;
    spacing: Point3;
    origin: Point3;
    imageData: CPUImageData;
    metadata: {
        Modality: string;
    };
    scalarData: PixelDataTypedArray;
    scaling: Scaling;
    hasPixelSpacing?: boolean;
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
};

// @public (undocumented)
type CPUImageData = {
    worldToIndex?: (point: Point3) => Point3;
    indexToWorld?: (point: Point3) => Point3;
    getWorldToIndex?: () => Point3;
    getIndexToWorld?: () => Point3;
    getSpacing?: () => Point3;
    getDirection?: () => Mat3;
    getScalarData?: () => PixelDataTypedArray;
    getDimensions?: () => Point3;
};

// @public (undocumented)
function createAndCacheDerivedVolume(referencedVolumeId: string, options: DerivedVolumeOptions): Promise<ImageVolume>;

// @public (undocumented)
function createAndCacheGeometry(geometryId: string, options: GeometryOptions): Promise<IGeometry>;

// @public (undocumented)
function createAndCacheVolume(volumeId: string, options: VolumeLoaderOptions): Promise<Record<string, any>>;

// @public (undocumented)
function createFloat32SharedArray(length: number): Float32Array;

// @public (undocumented)
function createInt16SharedArray(length: number): Int16Array;

// @public (undocumented)
function createLinearRGBTransferFunction(voiRange: VOIRange): vtkColorTransferFunction;

// @public (undocumented)
function createLocalVolume(options: LocalVolumeOptions, volumeId: string, preventCache?: boolean): ImageVolume;

// @public (undocumented)
function createSigmoidRGBTransferFunction(voiRange: VOIRange, approximationNodes?: number): vtkColorTransferFunction;

// @public (undocumented)
function createUint16SharedArray(length: number): Uint16Array;

// @public (undocumented)
function createUint8SharedArray(length: number): Uint8Array;

// @public (undocumented)
export function createVolumeActor(props: createVolumeActorInterface, element: HTMLDivElement, viewportId: string, suppressEvents?: boolean, use16BitTexture?: boolean): Promise<VolumeActor>;

// @public (undocumented)
export function createVolumeMapper(imageData: any, vtkOpenGLTexture: any): any;

// @public (undocumented)
interface CustomEvent_2<T = any> extends Event {
    // (undocumented)
    readonly detail: T;
    // (undocumented)
    initCustomEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, detailArg: T): void;
}

// @public (undocumented)
const deepMerge: (target?: {}, source?: {}, optionsArgument?: any) => any;

// @public (undocumented)
type DisplayArea = {
    imageArea: [number, number];
    imageCanvasPoint: {
        imagePoint: [number, number];
        canvasPoint: [number, number];
    };
    storeAsInitialCamera: boolean;
};

// @public (undocumented)
type DisplayAreaModifiedEvent = CustomEvent_2<DisplayAreaModifiedEventDetail>;

// @public (undocumented)
type DisplayAreaModifiedEventDetail = {
    viewportId: string;
    displayArea: DisplayArea;
    volumeId?: string;
    storeAsInitialCamera?: boolean;
};

// @public (undocumented)
enum DynamicOperatorType {
    // (undocumented)
    AVERAGE = "AVERAGE",
    // (undocumented)
    SUBTRACT = "SUBTRACT",
    // (undocumented)
    SUM = "SUM"
}

// @public (undocumented)
type ElementDisabledEvent = CustomEvent_2<ElementDisabledEventDetail>;

// @public (undocumented)
type ElementDisabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type ElementEnabledEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public (undocumented)
type ElementEnabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

declare namespace Enums {
    export {
        EVENTS as Events,
        BlendModes,
        InterpolationType,
        RequestType,
        ViewportType,
        OrientationAxis,
        SharedArrayBufferModes,
        GeometryType,
        ContourType,
        VOILUTFunctionType,
        DynamicOperatorType
    }
}
export { Enums }

// @public (undocumented)
const EPSILON = 0.001;

// @public (undocumented)
export enum EVENTS {
    // (undocumented)
    CACHE_SIZE_EXCEEDED = "CACHE_SIZE_EXCEEDED",
    // (undocumented)
    CAMERA_MODIFIED = "CORNERSTONE_CAMERA_MODIFIED",
    // (undocumented)
    CAMERA_RESET = "CORNERSTONE_CAMERA_RESET",
    // (undocumented)
    DISPLAY_AREA_MODIFIED = "CORNERSTONE_DISPLAY_AREA_MODIFIED",
    // (undocumented)
    ELEMENT_DISABLED = "CORNERSTONE_ELEMENT_DISABLED",
    // (undocumented)
    ELEMENT_ENABLED = "CORNERSTONE_ELEMENT_ENABLED",
    // (undocumented)
    GEOMETRY_CACHE_GEOMETRY_ADDED = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED",
    // (undocumented)
    IMAGE_CACHE_IMAGE_ADDED = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED",
    // (undocumented)
    IMAGE_CACHE_IMAGE_REMOVED = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED",
    // (undocumented)
    IMAGE_LOAD_ERROR = "IMAGE_LOAD_ERROR",
    // (undocumented)
    IMAGE_LOAD_FAILED = "CORNERSTONE_IMAGE_LOAD_FAILED",
    // (undocumented)
    IMAGE_LOAD_PROGRESS = "CORNERSTONE_IMAGE_LOAD_PROGRESS",
    // (undocumented)
    IMAGE_LOADED = "CORNERSTONE_IMAGE_LOADED",
    // (undocumented)
    IMAGE_RENDERED = "CORNERSTONE_IMAGE_RENDERED",
    // (undocumented)
    IMAGE_SPACING_CALIBRATED = "CORNERSTONE_IMAGE_SPACING_CALIBRATED",
    // (undocumented)
    IMAGE_VOLUME_MODIFIED = "CORNERSTONE_IMAGE_VOLUME_MODIFIED",
    // (undocumented)
    PRE_STACK_NEW_IMAGE = "CORNERSTONE_PRE_STACK_NEW_IMAGE",
    // (undocumented)
    STACK_NEW_IMAGE = "CORNERSTONE_STACK_NEW_IMAGE",
    // (undocumented)
    STACK_VIEWPORT_NEW_STACK = "CORNERSTONE_STACK_VIEWPORT_NEW_STACK",
    // (undocumented)
    STACK_VIEWPORT_SCROLL = "CORNERSTONE_STACK_VIEWPORT_SCROLL",
    // (undocumented)
    VOI_MODIFIED = "CORNERSTONE_VOI_MODIFIED",
    // (undocumented)
    VOLUME_CACHE_VOLUME_ADDED = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED",
    // (undocumented)
    VOLUME_CACHE_VOLUME_REMOVED = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED",
    // (undocumented)
    VOLUME_LOADED = "CORNERSTONE_VOLUME_LOADED",
    // (undocumented)
    VOLUME_LOADED_FAILED = "CORNERSTONE_VOLUME_LOADED_FAILED",
    // (undocumented)
    VOLUME_NEW_IMAGE = "CORNERSTONE_VOLUME_NEW_IMAGE",
    // (undocumented)
    VOLUME_SCROLL_OUT_OF_BOUNDS = "CORNERSTONE_VOLUME_SCROLL_OUT_OF_BOUNDS",
    // (undocumented)
    VOLUME_VIEWPORT_NEW_VOLUME = "CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME"
}

// @public (undocumented)
export const eventTarget: CornerstoneEventTarget;

declare namespace EventTypes {
    export {
        CameraModifiedEventDetail,
        CameraModifiedEvent,
        VoiModifiedEvent,
        VoiModifiedEventDetail,
        DisplayAreaModifiedEvent,
        DisplayAreaModifiedEventDetail,
        ElementDisabledEvent,
        ElementDisabledEventDetail,
        ElementEnabledEvent,
        ElementEnabledEventDetail,
        ImageRenderedEventDetail,
        ImageRenderedEvent,
        ImageVolumeModifiedEvent,
        ImageVolumeModifiedEventDetail,
        ImageLoadedEvent,
        ImageLoadedEventDetail,
        ImageLoadedFailedEventDetail,
        ImageLoadedFailedEvent,
        VolumeLoadedEvent,
        VolumeLoadedEventDetail,
        VolumeLoadedFailedEvent,
        VolumeLoadedFailedEventDetail,
        ImageCacheImageAddedEvent,
        ImageCacheImageAddedEventDetail,
        ImageCacheImageRemovedEvent,
        ImageCacheImageRemovedEventDetail,
        VolumeCacheVolumeAddedEvent,
        VolumeCacheVolumeAddedEventDetail,
        VolumeCacheVolumeRemovedEvent,
        VolumeCacheVolumeRemovedEventDetail,
        StackNewImageEvent,
        StackNewImageEventDetail,
        PreStackNewImageEvent,
        PreStackNewImageEventDetail,
        ImageSpacingCalibratedEvent,
        ImageSpacingCalibratedEventDetail,
        ImageLoadProgressEvent,
        ImageLoadProgressEventDetail,
        VolumeNewImageEvent,
        VolumeNewImageEventDetail,
        StackViewportNewStackEvent,
        StackViewportNewStackEventDetail,
        StackViewportScrollEvent,
        StackViewportScrollEventDetail
    }
}

// @public (undocumented)
type FlipDirection = {
    flipHorizontal?: boolean;
    flipVertical?: boolean;
};

declare namespace geometryLoader {
    export {
        createAndCacheGeometry
    }
}
export { geometryLoader }

// @public (undocumented)
enum GeometryType {
    // (undocumented)
    CONTOUR = "contour"
}

// @public (undocumented)
function getClosestImageId(imageVolume: IImageVolume, worldPos: Point3, viewPlaneNormal: Point3): string;

// @public (undocumented)
function getClosestStackImageIndexForPoint(point: Point3, viewport: IStackViewport): number | null;

// @public (undocumented)
function getColormap(name: any): any;

// @public (undocumented)
function getColormapNames(): any[];

// @public (undocumented)
export function getConfiguration(): Cornerstone3DConfig;

// @public (undocumented)
export function getEnabledElement(element: HTMLDivElement | undefined): IEnabledElement | undefined;

// @public (undocumented)
export function getEnabledElementByIds(viewportId: string, renderingEngineId: string): IEnabledElement;

// @public (undocumented)
export function getEnabledElements(): IEnabledElement[];

// @public (undocumented)
function getImageLegacy(element: HTMLDivElement): Types.IImage | undefined;

// @public (undocumented)
function getImageSliceDataForVolumeViewport(viewport: IVolumeViewport): ImageSliceData;

// @public (undocumented)
function getMetaData(type: string, query: string): any;

// @public (undocumented)
function getMinMax(storedPixelData: number[]): {
    min: number;
    max: number;
};

// @public (undocumented)
export function getOrCreateCanvas(element: HTMLDivElement): HTMLCanvasElement;

// @public (undocumented)
export function getRenderingEngine(id: string): IRenderingEngine | undefined;

// @public (undocumented)
export function getRenderingEngines(): IRenderingEngine[] | undefined;

// @public (undocumented)
function getRuntimeId(context?: unknown, separator?: string, max?: number): string;

// @public (undocumented)
function getScalarDataType(scalingParameters: ScalingParameters, scalarData?: any): string;

// @public (undocumented)
function getScalingParameters(imageId: string): ScalingParameters;

// @public (undocumented)
export function getShouldUseCPURendering(): boolean;

// @public (undocumented)
export function getShouldUseSharedArrayBuffer(): boolean;

// @public (undocumented)
function getSliceRange(volumeActor: VolumeActor, viewPlaneNormal: Point3, focalPoint: Point3): ActorSliceRange;

// @public (undocumented)
function getSpacingInNormalDirection(imageVolume: IImageVolume, viewPlaneNormal: Point3): number;

// @public (undocumented)
function getTargetVolumeAndSpacingInNormalDir(viewport: IVolumeViewport, camera: ICamera, targetVolumeId?: string): {
    imageVolume: IImageVolume;
    spacingInNormalDirection: number;
    actorUID: string;
};

// @public (undocumented)
function getViewportImageCornersInWorld(viewport: IStackViewport | IVolumeViewport): Point3[];

// @public (undocumented)
function getViewportsWithImageURI(imageURI: string, renderingEngineId?: string): Array<Viewport_2>;

// @public (undocumented)
function getViewportsWithVolumeId(volumeId: string, renderingEngineId?: string): Array<IVolumeViewport>;

// @public (undocumented)
function getVoiFromSigmoidRGBTransferFunction(cfun: vtkColorTransferFunction): [number, number];

// @public (undocumented)
function getVolumeActorCorners(volumeActor: any): Array<Point3>;

// @public (undocumented)
function getVolumeLoaderSchemes(): string[];

// @public (undocumented)
function getVolumeSliceRangeInfo(viewport: IVolumeViewport, volumeId: string): {
    sliceRange: ActorSliceRange;
    spacingInNormalDirection: number;
    camera: ICamera;
};

// @public (undocumented)
function getVolumeViewportsContainingSameVolumes(targetViewport: IVolumeViewport, renderingEngineId?: string): Array<IVolumeViewport>;

// @public (undocumented)
function getVolumeViewportScrollInfo(viewport: IVolumeViewport, volumeId: string): {
    numScrollSteps: number;
    currentStepIndex: number;
    sliceRangeInfo: {
        sliceRange: ActorSliceRange;
        spacingInNormalDirection: number;
        camera: ICamera;
    };
};

// @public (undocumented)
function hasNaNValues(input: number[] | number): boolean;

// @public (undocumented)
interface ICache {
    // (undocumented)
    getCacheSize: () => number;
    // (undocumented)
    getImageLoadObject: (imageId: string) => IImageLoadObject | void;
    // (undocumented)
    getMaxCacheSize: () => number;
    // (undocumented)
    getVolumeLoadObject: (volumeId: string) => IVolumeLoadObject | void;
    // (undocumented)
    purgeCache: () => void;
    // (undocumented)
    putImageLoadObject: (imageId: string, imageLoadObject: IImageLoadObject) => Promise<any>;
    // (undocumented)
    putVolumeLoadObject: (volumeId: string, volumeLoadObject: IVolumeLoadObject) => Promise<any>;
    // (undocumented)
    setMaxCacheSize: (maxCacheSize: number) => void;
}

// @public (undocumented)
interface ICachedGeometry {
    // (undocumented)
    geometry?: IGeometry;
    // (undocumented)
    geometryId: string;
    // (undocumented)
    geometryLoadObject: IGeometryLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedImage {
    // (undocumented)
    image?: IImage;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageLoadObject: IImageLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedVolume {
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
    // (undocumented)
    volume?: IImageVolume;
    // (undocumented)
    volumeId: string;
    // (undocumented)
    volumeLoadObject: IVolumeLoadObject;
}

// @public (undocumented)
interface ICamera {
    // (undocumented)
    clippingRange?: Point2;
    // (undocumented)
    flipHorizontal?: boolean;
    // (undocumented)
    flipVertical?: boolean;
    // (undocumented)
    focalPoint?: Point3;
    // (undocumented)
    parallelProjection?: boolean;
    // (undocumented)
    parallelScale?: number;
    // (undocumented)
    position?: Point3;
    // (undocumented)
    scale?: number;
    // (undocumented)
    viewAngle?: number;
    // (undocumented)
    viewPlaneNormal?: Point3;
    // (undocumented)
    viewUp?: Point3;
}

// @public (undocumented)
interface IContour {
    // (undocumented)
    color: any;
    // (undocumented)
    getColor(): Point3;
    // (undocumented)
    getFlatPointsArray(): number[];
    // (undocumented)
    getPoints(): Point3[];
    // (undocumented)
    _getSizeInBytes(): number;
    // (undocumented)
    getType(): ContourType;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    points: Point3[];
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public (undocumented)
interface IContourSet {
    // (undocumented)
    contours: IContour[];
    // (undocumented)
    _createEachContour(data: ContourData[]): void;
    // (undocumented)
    readonly frameOfReferenceUID: string;
    // (undocumented)
    getCentroid(): Point3;
    // (undocumented)
    getColor(): any;
    // (undocumented)
    getContours(): IContour[];
    // (undocumented)
    getFlatPointsArray(): Point3[];
    // (undocumented)
    getNumberOfContours(): number;
    // (undocumented)
    getNumberOfPointsArray(): number[];
    // (undocumented)
    getNumberOfPointsInAContour(contourIndex: number): number;
    // (undocumented)
    getPointsInContour(contourIndex: number): Point3[];
    // (undocumented)
    getSegmentIndex(): number;
    // (undocumented)
    getSizeInBytes(): number;
    // (undocumented)
    getTotalNumberOfPoints(): number;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public (undocumented)
interface IDynamicImageVolume extends IImageVolume {
    // (undocumented)
    getScalarDataArrays(): VolumeScalarData[];
    // (undocumented)
    get numTimePoints(): number;
    // (undocumented)
    get timePointIndex(): number;
    set timePointIndex(newTimePointIndex: number);
}

// @public (undocumented)
interface IEnabledElement {
    // (undocumented)
    FrameOfReferenceUID: string;
    // (undocumented)
    renderingEngine: IRenderingEngine;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewport: IStackViewport | IVolumeViewport;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
interface IGeometry {
    // (undocumented)
    data: IContourSet;
    // (undocumented)
    id: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    type: GeometryType;
}

// @public (undocumented)
interface IGeometryLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IGeometry>;
}

// @public (undocumented)
interface IImage {
    // (undocumented)
    cachedLut?: {
        windowWidth?: number | number[];
        windowCenter?: number | number[];
        invert?: boolean;
        lutArray?: Uint8ClampedArray;
        modalityLUT?: unknown;
        voiLUT?: CPUFallbackLUT;
    };
    // (undocumented)
    color: boolean;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    columnPixelSpacing: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    getCanvas: () => HTMLCanvasElement;
    // (undocumented)
    getPixelData: () => PixelDataTypedArray;
    // (undocumented)
    height: number;
    // (undocumented)
    imageId: string;
    // (undocumented)
    intercept: number;
    // (undocumented)
    invert: boolean;
    // (undocumented)
    isPreScaled?: boolean;
    // (undocumented)
    maxPixelValue: number;
    // (undocumented)
    minPixelValue: number;
    // (undocumented)
    modalityLUT?: CPUFallbackLUT;
    // (undocumented)
    numComps: number;
    // (undocumented)
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    // (undocumented)
    render?: (enabledElement: CPUFallbackEnabledElement, invalidated: boolean) => unknown;
    // (undocumented)
    rgba: boolean;
    // (undocumented)
    rowPixelSpacing: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    sliceThickness?: number;
    // (undocumented)
    slope: number;
    // (undocumented)
    stats?: {
        lastStoredPixelDataToCanvasImageDataTime?: number;
        lastGetPixelDataTime?: number;
        lastPutImageDataTime?: number;
        lastLutGenerateTime?: number;
        lastRenderedViewport?: unknown;
        lastRenderTime?: number;
    };
    // (undocumented)
    voiLUT?: CPUFallbackLUT;
    // (undocumented)
    voiLUTFunction: string;
    // (undocumented)
    width: number;
    // (undocumented)
    windowCenter: number[] | number;
    // (undocumented)
    windowWidth: number[] | number;
}

// @public (undocumented)
interface IImageData {
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    hasPixelSpacing?: boolean;
    // (undocumented)
    imageData: vtkImageData;
    // (undocumented)
    metadata: {
        Modality: string;
    };
    // (undocumented)
    origin: Point3;
    // (undocumented)
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    // (undocumented)
    scalarData: Float32Array | Uint16Array | Uint8Array | Int16Array;
    // (undocumented)
    scaling?: Scaling;
    // (undocumented)
    spacing: Point3;
}

// @public (undocumented)
interface IImageLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IImage>;
}

// @public (undocumented)
interface IImageVolume {
    // (undocumented)
    cancelLoading?: () => void;
    // (undocumented)
    convertToCornerstoneImage?: (imageId: string, imageIdIndex: number) => IImageLoadObject;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    getImageIdIndex(imageId: string): number;
    // (undocumented)
    getImageURIIndex(imageURI: string): number;
    // (undocumented)
    getScalarData(): VolumeScalarData;
    // (undocumented)
    hasPixelSpacing: boolean;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    imageIds: Array<string>;
    // (undocumented)
    isDynamicVolume(): boolean;
    // (undocumented)
    isPrescaled: boolean;
    // (undocumented)
    loadStatus?: Record<string, any>;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    numVoxels: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    readonly volumeId: string;
    // (undocumented)
    vtkOpenGLTexture: any;
}

// @public (undocumented)
type ImageCacheImageAddedEvent = CustomEvent_2<ImageCacheImageAddedEventDetail>;

// @public (undocumented)
type ImageCacheImageAddedEventDetail = {
    image: ICachedImage;
};

// @public (undocumented)
type ImageCacheImageRemovedEvent = CustomEvent_2<ImageCacheImageRemovedEventDetail>;

// @public (undocumented)
type ImageCacheImageRemovedEventDetail = {
    imageId: string;
};

// @public (undocumented)
function imageIdToURI(imageId: string): string;

// @public (undocumented)
type ImageLoadedEvent = CustomEvent_2<ImageLoadedEventDetail>;

// @public (undocumented)
type ImageLoadedEventDetail = {
    image: IImage;
};

// @public (undocumented)
type ImageLoadedFailedEvent = CustomEvent_2<ImageLoadedFailedEventDetail>;

// @public (undocumented)
type ImageLoadedFailedEventDetail = {
    imageId: string;
    error: unknown;
};

declare namespace imageLoader {
    export {
        loadImage,
        loadAndCacheImage,
        loadAndCacheImages,
        cancelLoadImage,
        cancelLoadImages,
        cancelLoadAll,
        registerImageLoader,
        registerUnknownImageLoader,
        unregisterAllImageLoaders,
        ImageLoaderOptions
    }
}
export { imageLoader }

// @public (undocumented)
type ImageLoaderFn = (imageId: string, options?: Record<string, any>) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
interface ImageLoaderOptions {
    // (undocumented)
    additionalDetails?: Record<string, unknown>;
    // (undocumented)
    priority: number;
    // (undocumented)
    requestType: string;
}

// @public (undocumented)
const imageLoadPoolManager: RequestPoolManager;
export { imageLoadPoolManager }
export { imageLoadPoolManager as requestPoolManager }

// @public (undocumented)
type ImageLoadProgressEvent = CustomEvent_2<ImageLoadProgressEventDetail>;

// @public (undocumented)
type ImageLoadProgressEventDetail = {
    url: string;
    imageId: string;
    loaded: number;
    total: number;
    percent: number;
};

// @public (undocumented)
interface ImagePixelModule {
    // (undocumented)
    bitsAllocated: number;
    // (undocumented)
    bitsStored: number;
    // (undocumented)
    highBit: number;
    // (undocumented)
    modality: string;
    // (undocumented)
    photometricInterpretation: string;
    // (undocumented)
    pixelRepresentation: string;
    // (undocumented)
    samplesPerPixel: number;
    // (undocumented)
    voiLUTFunction: VOILUTFunctionType;
    // (undocumented)
    windowCenter: number | number[];
    // (undocumented)
    windowWidth: number | number[];
}

// @public (undocumented)
interface ImagePlaneModule {
    // (undocumented)
    columnCosines?: Point3;
    // (undocumented)
    columnPixelSpacing?: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    frameOfReferenceUID: string;
    // (undocumented)
    imageOrientationPatient?: Float32Array;
    // (undocumented)
    imagePositionPatient?: Point3;
    // (undocumented)
    pixelSpacing?: Point2;
    // (undocumented)
    rowCosines?: Point3;
    // (undocumented)
    rowPixelSpacing?: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    sliceLocation?: number;
    // (undocumented)
    sliceThickness?: number;
}

// @public (undocumented)
type ImageRenderedEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public (undocumented)
type ImageRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    suppressEvents?: boolean;
};

// @public (undocumented)
export const imageRetrievalPoolManager: RequestPoolManager;

// @public (undocumented)
type ImageSliceData = {
    numberOfSlices: number;
    imageIndex: number;
};

// @public (undocumented)
type ImageSpacingCalibratedEvent = CustomEvent_2<ImageSpacingCalibratedEventDetail>;

// @public (undocumented)
type ImageSpacingCalibratedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    imageId: string;
    rowScale: number;
    columnScale: number;
    imageData: vtkImageData;
    worldToIndex: mat4;
};

// @public (undocumented)
function imageToWorldCoords(imageId: string, imageCoords: Point2): Point3 | undefined;

// @public (undocumented)
export class ImageVolume implements IImageVolume {
    constructor(props: IVolume);
    // (undocumented)
    cancelLoading: () => void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    getImageIdIndex(imageId: string): number;
    // (undocumented)
    getImageURIIndex(imageURI: string): number;
    // (undocumented)
    getScalarData(): VolumeScalarData;
    // (undocumented)
    hasPixelSpacing: boolean;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    get imageIds(): Array<string>;
    set imageIds(newImageIds: Array<string>);
    // (undocumented)
    isDynamicVolume(): boolean;
    // (undocumented)
    isPrescaled: boolean;
    // (undocumented)
    loadStatus?: Record<string, any>;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    numVoxels: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    protected scalarData: VolumeScalarData | Array<VolumeScalarData>;
    // (undocumented)
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    readonly volumeId: string;
    // (undocumented)
    vtkOpenGLTexture: any;
}

// @public (undocumented)
type ImageVolumeModifiedEvent = CustomEvent_2<ImageVolumeModifiedEventDetail>;

// @public (undocumented)
type ImageVolumeModifiedEventDetail = {
    imageVolume: IImageVolume;
    FrameOfReferenceUID: string;
};

// @public (undocumented)
function indexWithinDimensions(index: Point3, dimensions: Point3): boolean;

// @public (undocumented)
export function init(configuration?: {}): Promise<boolean>;

// @public (undocumented)
enum InterpolationType {
    // (undocumented)
    FAST_LINEAR = 2,
    // (undocumented)
    LINEAR = 1,
    // (undocumented)
    NEAREST = 0
}

// @public (undocumented)
function invertRgbTransferFunction(rgbTransferFunction: any): void;

// @public (undocumented)
interface IRegisterImageLoader {
    // (undocumented)
    registerImageLoader: (scheme: string, imageLoader: ImageLoaderFn) => void;
}

// @public (undocumented)
interface IRenderingEngine {
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(canvas: HTMLCanvasElement, backgroundColor: [number, number, number]): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getViewport(id: string): IStackViewport | IVolumeViewport;
    // (undocumented)
    getViewports(): Array<IStackViewport | IVolumeViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference(FrameOfReferenceUID: string): void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, resetPan?: boolean, resetZoom?: boolean): void;
    // (undocumented)
    setViewports(viewports: Array<PublicViewportInput>): void;
}

// @public (undocumented)
export function isCornerstoneInitialized(): boolean;

// @public (undocumented)
function isEqual<ValueType>(v1: ValueType, v2: ValueType, tolerance?: number): boolean;

// @public (undocumented)
function isImageActor(actorEntry: Types.ActorEntry): boolean;

// @public (undocumented)
function isOpposite(v1: Point3, v2: Point3, tolerance?: number): boolean;

// @public (undocumented)
const isPTPrescaledWithSUV: (image: IImage) => number;

// @public (undocumented)
interface IStackViewport extends IViewport {
    // (undocumented)
    calibrateSpacing(imageId: string): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCornerstoneImage: () => IImage;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(): IImageData | CPUIImageData;
    // (undocumented)
    getImageIds: () => string[];
    // (undocumented)
    getProperties: () => StackViewportProperties;
    // (undocumented)
    getRenderer(): any;
    // (undocumented)
    hasImageId: (imageId: string) => boolean;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    modality: string;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scaling: Scaling;
    // (undocumented)
    setCamera(cameraInterface: ICamera): void;
    // (undocumented)
    setColormap(colormap: CPUFallbackColormapData | ColormapRegistration): void;
    // (undocumented)
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    // (undocumented)
    setProperties({ voiRange, invert, interpolationType, rotation }: StackViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    setStack(imageIds: Array<string>, currentImageIdIndex?: number): Promise<string>;
    // (undocumented)
    unsetColormap(): void;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
interface IStreamingImageVolume extends ImageVolume {
    // (undocumented)
    clearLoadCallbacks(): void;
    // (undocumented)
    convertToCornerstoneImage(imageId: string, imageIdIndex: number): any;
    // (undocumented)
    decache(completelyRemove: boolean): void;
}

// @public (undocumented)
interface IStreamingVolumeProperties {
    // (undocumented)
    imageIds: Array<string>;
    // (undocumented)
    loadStatus: {
        loaded: boolean;
        loading: boolean;
        cancelled: boolean;
        cachedFrames: Array<boolean>;
        callbacks: Array<() => void>;
    };
}

// @public (undocumented)
interface IViewport {
    // (undocumented)
    _actors: Map<string, any>;
    // (undocumented)
    addActor(actorEntry: ActorEntry): void;
    // (undocumented)
    addActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    canvas: HTMLCanvasElement;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => unknown;
    // (undocumented)
    defaultOptions: any;
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    getActor(actorUID: string): ActorEntry;
    // (undocumented)
    getActorByIndex(index: number): ActorEntry;
    // (undocumented)
    getActors(): Array<ActorEntry>;
    // (undocumented)
    getActorUIDByIndex(index: number): string;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    // (undocumented)
    getDefaultActor(): ActorEntry;
    // (undocumented)
    getDisplayArea(): DisplayArea | undefined;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getPan(): Point2;
    // (undocumented)
    getRenderer(): void;
    // (undocumented)
    getRenderingEngine(): any;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getZoom(): number;
    // (undocumented)
    id: string;
    // (undocumented)
    isDisabled: boolean;
    // (undocumented)
    options: ViewportInputOptions;
    // (undocumented)
    removeActors(actorUIDs: Array<string>): void;
    // (undocumented)
    removeAllActors(): void;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    reset(immediate: boolean): void;
    // (undocumented)
    setActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    setDisplayArea(displayArea: DisplayArea, callResetCamera?: boolean, suppressEvents?: boolean): any;
    // (undocumented)
    setOptions(options: ViewportInputOptions, immediate: boolean): void;
    // (undocumented)
    setPan(pan: Point2, storeAsInitialCamera?: boolean): any;
    // (undocumented)
    setZoom(zoom: number, storeAsInitialCamera?: boolean): any;
    // (undocumented)
    sHeight: number;
    // (undocumented)
    suppressEvents: boolean;
    // (undocumented)
    sWidth: number;
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    type: ViewportType;
    // (undocumented)
    updateRenderingPipeline: () => void;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
interface IViewportId {
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
interface IVolume {
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scalarData: VolumeScalarData | Array<VolumeScalarData>;
    // (undocumented)
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
interface IVolumeInput {
    // (undocumented)
    actorUID?: string;
    // (undocumented)
    blendMode?: BlendModes;
    // (undocumented)
    callback?: VolumeInputCallback;
    // (undocumented)
    slabThickness?: number;
    // (undocumented)
    visibility?: boolean;
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
interface IVolumeLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<ImageVolume>;
}

// @public (undocumented)
interface IVolumeViewport extends IViewport {
    // (undocumented)
    addVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    flip(flipDirection: FlipDirection): void;
    // (undocumented)
    getBounds(): any;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(volumeId?: string): IImageData | undefined;
    // (undocumented)
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    getProperties: () => VolumeViewportProperties;
    // (undocumented)
    getSlabThickness(): number;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    hasVolumeId: (volumeId: string) => boolean;
    // (undocumented)
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean): boolean;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: Array<string>, immediate?: boolean): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis): void;
    // (undocumented)
    setProperties({ voiRange }: VolumeViewportProperties, volumeId?: string, suppressEvents?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: Array<string>): void;
    // (undocumented)
    setVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
function linePlaneIntersection(p0: Point3, p1: Point3, plane: Plane): Point3;

// @public (undocumented)
function loadAndCacheImage(imageId: string, options?: ImageLoaderOptions): Promise<IImage>;

// @public (undocumented)
function loadAndCacheImages(imageIds: Array<string>, options?: ImageLoaderOptions): Promise<IImage>[];

// @public (undocumented)
function loadImage(imageId: string, options?: ImageLoaderOptions): Promise<IImage>;

// @public (undocumented)
function loadImageToCanvas(options: LoadImageOptions): Promise<string>;

// @public (undocumented)
function loadVolume(volumeId: string, options?: VolumeLoaderOptions): Promise<Types.IImageVolume>;

// @public (undocumented)
type Mat3 = [
number,
number,
number,
number,
number,
number,
number,
number,
number
];

// @public (undocumented)
type Metadata = {
    BitsAllocated: number;
    BitsStored: number;
    SamplesPerPixel: number;
    HighBit: number;
    PhotometricInterpretation: string;
    PixelRepresentation: number;
    Modality: string;
    SeriesInstanceUID?: string;
    ImageOrientationPatient: Array<number>;
    PixelSpacing: Array<number>;
    FrameOfReferenceUID: string;
    Columns: number;
    Rows: number;
    voiLut: Array<VOI>;
    VOILUTFunction: string;
};

declare namespace metaData {
    export {
        addProvider,
        removeProvider,
        removeAllProviders,
        getMetaData as get
    }
}
export { metaData }

// @public (undocumented)
const metadataProvider: {
    add: (imageId: string, payload: CalibratedPixelValue) => void;
    get: (type: string, imageId: string) => CalibratedPixelValue;
};

// @public (undocumented)
const mprCameraValues: any;

// @public (undocumented)
enum OrientationAxis {
    // (undocumented)
    ACQUISITION = "acquisition",
    // (undocumented)
    AXIAL = "axial",
    // (undocumented)
    CORONAL = "coronal",
    // (undocumented)
    SAGITTAL = "sagittal"
}

// @public (undocumented)
type OrientationVectors = {
    viewPlaneNormal: Point3;
    viewUp: Point3;
};

// @public (undocumented)
type PixelDataTypedArray = Float32Array | Int16Array | Uint16Array | Uint8Array | Int8Array | Uint8ClampedArray;

declare namespace planar {
    export {
        linePlaneIntersection,
        planeEquation,
        threePlaneIntersection,
        planeDistanceToPoint
    }
}

// @public (undocumented)
type Plane = [number, number, number, number];

// @public (undocumented)
function planeDistanceToPoint(plane: Plane, point: Point3, signed?: boolean): number;

// @public (undocumented)
function planeEquation(normal: Point3, point: Point3 | vec3): Plane;

// @public (undocumented)
type Point2 = [number, number];

// @public (undocumented)
type Point3 = [number, number, number];

// @public (undocumented)
type Point4 = [number, number, number, number];

// @public (undocumented)
const presets: ViewportPreset[];

// @public (undocumented)
type PreStackNewImageEvent = CustomEvent_2<PreStackNewImageEventDetail>;

// @public (undocumented)
type PreStackNewImageEventDetail = {
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type PTScaling = {
    suvbwToSuvlbm?: number;
    suvbwToSuvbsa?: number;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
type PublicContourSetData = ContourSetData;

// @public (undocumented)
type PublicViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions?: ViewportInputOptions;
};

// @public (undocumented)
function registerColormap(colormap: ColormapRegistration): void;

// @public (undocumented)
export function registerImageLoader(scheme: string, imageLoader: ImageLoaderFn): void;

// @public (undocumented)
function registerUnknownImageLoader(imageLoader: ImageLoaderFn): ImageLoaderFn;

// @public (undocumented)
function registerUnknownVolumeLoader(volumeLoader: Types.VolumeLoaderFn): Types.VolumeLoaderFn | undefined;

// @public (undocumented)
function registerVolumeLoader(scheme: string, volumeLoader: Types.VolumeLoaderFn): void;

// @public (undocumented)
function removeAllProviders(): void;

// @public (undocumented)
function removeProvider(provider: (type: string, query: any) => {
    any: any;
}): void;

// @public (undocumented)
const RENDERING_DEFAULTS: {
    MINIMUM_SLAB_THICKNESS: number;
    MAXIMUM_RAY_DISTANCE: number;
};

// @public (undocumented)
export class RenderingEngine implements IRenderingEngine {
    constructor(id?: string);
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    _downloadOffScreenCanvas(): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(canvas: HTMLCanvasElement, backgroundColor: [number, number, number]): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getViewport(viewportId: string): IStackViewport | IVolumeViewport;
    // (undocumented)
    getViewports(): Array<IStackViewport | IVolumeViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference: (FrameOfReferenceUID: string) => void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, keepCamera?: boolean): void;
    // (undocumented)
    setViewports(publicViewportInputEntries: Array<PublicViewportInput>): void;
}

// @public (undocumented)
function renderToCanvasCPU(canvas: HTMLCanvasElement, image: IImage, modality?: string, renderingEngineId?: string): Promise<string>;

// @public (undocumented)
function renderToCanvasGPU(canvas: HTMLCanvasElement, image: IImage, modality?: any, renderingEngineId?: string): Promise<string>;

// @public (undocumented)
enum RequestType {
    // (undocumented)
    Interaction = "interaction",
    // (undocumented)
    Prefetch = "prefetch",
    // (undocumented)
    Thumbnail = "thumbnail"
}

// @public (undocumented)
export function resetUseCPURendering(): void;

// @public (undocumented)
export function resetUseSharedArrayBuffer(): void;

// @public (undocumented)
type RGB = [number, number, number];

// @public (undocumented)
function scaleRGBTransferFunction(rgbTransferFunction: any, scalingFactor: number): void;

// @public (undocumented)
type Scaling = {
    PET?: PTScaling;
};

// @public (undocumented)
type ScalingParameters = {
    rescaleSlope: number;
    rescaleIntercept: number;
    modality: string;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
export function setConfiguration(c: Cornerstone3DConfig): void;

// @public (undocumented)
export function setPreferSizeOverAccuracy(status: boolean): void;

// @public (undocumented)
export class Settings {
    constructor(base?: Settings);
    // (undocumented)
    static assert(subject: Settings): Settings;
    // (undocumented)
    dump(): Record<string, unknown>;
    // (undocumented)
    extend(): Settings;
    // (undocumented)
    static extendRuntimeSettings(): Settings;
    // (undocumented)
    forEach(callback: (key: string, value: unknown) => void): void;
    // (undocumented)
    get(key: string): unknown;
    // (undocumented)
    static getDefaultSettings(subfield?: any): Settings | any;
    // (undocumented)
    static getObjectSettings(subject: unknown, from?: unknown): Settings;
    // (undocumented)
    static getRuntimeSettings(): Settings;
    // (undocumented)
    import(root: Record<string, unknown>): void;
    // (undocumented)
    set(key: string, value: unknown): boolean;
    // (undocumented)
    unset(key: string): boolean;
}

// @public (undocumented)
export function setUseCPURendering(status: boolean): void;

// @public (undocumented)
export function setUseSharedArrayBuffer(mode: SharedArrayBufferModes | boolean): void;

// @public (undocumented)
export function setVolumesForViewports(renderingEngine: IRenderingEngine, volumeInputs: Array<IVolumeInput>, viewportIds: Array<string>, immediateRender?: boolean, suppressEvents?: boolean): Promise<void>;

// @public (undocumented)
enum SharedArrayBufferModes {
    // (undocumented)
    AUTO = "auto",
    // (undocumented)
    FALSE = "false",
    // (undocumented)
    TRUE = "true"
}

// @public (undocumented)
function snapFocalPointToSlice(focalPoint: Point3, position: Point3, sliceRange: ActorSliceRange, viewPlaneNormal: Point3, spacingInNormalDirection: number, deltaFrames: number): {
    newFocalPoint: Point3;
    newPosition: Point3;
};

// @public (undocumented)
const spatialRegistrationMetadataProvider: {
    add: (query: string[], payload: mat4) => void;
    get: (type: string, query: string[]) => mat4;
};

// @public (undocumented)
type StackNewImageEvent = CustomEvent_2<StackNewImageEventDetail>;

// @public (undocumented)
type StackNewImageEventDetail = {
    image: IImage;
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
export class StackViewport extends Viewport implements IStackViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addActor: (actorEntry: ActorEntry) => void;
    // (undocumented)
    addActors: (actors: Array<ActorEntry>) => void;
    // (undocumented)
    calibrateSpacing(imageId: string): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getActor: (actorUID: string) => ActorEntry;
    // (undocumented)
    getActors: () => Array<ActorEntry>;
    // (undocumented)
    getCamera: () => ICamera;
    // (undocumented)
    getCornerstoneImage: () => IImage;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getDefaultActor: () => ActorEntry;
    // (undocumented)
    getFrameOfReferenceUID: () => string | undefined;
    // (undocumented)
    getImageData: () => IImageData | CPUIImageData;
    // (undocumented)
    getImageIds: () => Array<string>;
    // (undocumented)
    getProperties: () => StackViewportProperties;
    // (undocumented)
    getRenderer: () => any;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getTargetImageIdIndex: () => number;
    // (undocumented)
    hasImageId: (imageId: string) => boolean;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    modality: string;
    // (undocumented)
    removeAllActors: () => void;
    // (undocumented)
    renderImageObject: (image: any) => void;
    // (undocumented)
    resetCamera: (resetPan?: boolean, resetZoom?: boolean) => boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scaling: Scaling;
    // (undocumented)
    scroll(delta: number, debounce?: boolean, loop?: boolean): void;
    // (undocumented)
    setActors: (actors: Array<ActorEntry>) => void;
    // (undocumented)
    setCamera: (cameraInterface: ICamera, storeAsInitialCamera?: boolean) => void;
    // (undocumented)
    setColormap: (colormap: CPUFallbackColormapData | ColormapRegistration) => void;
    // (undocumented)
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    // (undocumented)
    setProperties({ voiRange, VOILUTFunction, invert, interpolationType, rotation, }?: StackViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    setStack(imageIds: Array<string>, currentImageIdIndex?: number): Promise<string>;
    // (undocumented)
    setUseCPURendering(value: boolean): void;
    // (undocumented)
    unsetColormap: () => void;
    // (undocumented)
    updateRenderingPipeline: () => void;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
type StackViewportNewStackEvent = CustomEvent_2<StackViewportNewStackEventDetail>;

// @public (undocumented)
type StackViewportNewStackEventDetail = {
    imageIds: string[];
    viewportId: string;
    element: HTMLDivElement;
    currentImageIdIndex: number;
};

// @public (undocumented)
type StackViewportProperties = ViewportProperties & {
    interpolationType?: InterpolationType;
    rotation?: number;
    suppressEvents?: boolean;
    isComputedVOI?: boolean;
};

// @public (undocumented)
type StackViewportScrollEvent = CustomEvent_2<StackViewportScrollEventDetail>;

// @public (undocumented)
type StackViewportScrollEventDetail = {
    newImageIdIndex: number;
    imageId: string;
    direction: number;
};

// @public (undocumented)
function threePlaneIntersection(firstPlane: Plane, secondPlane: Plane, thirdPlane: Plane): Point3;

// @public (undocumented)
function toLowHighRange(windowWidth: number, windowCenter: number): {
    lower: number;
    upper: number;
};

// @public (undocumented)
function toWindowLevel(low: number, high: number): {
    windowWidth: number;
    windowCenter: number;
};

// @public (undocumented)
type TransformMatrix2D = [number, number, number, number, number, number];

// @public (undocumented)
function transformWorldToIndex(imageData: any, worldPos: Point3): any;

// @public (undocumented)
export function triggerEvent(el: EventTarget, type: string, detail?: unknown): boolean;

declare namespace Types {
    export {
        Cornerstone3DConfig,
        ICamera,
        IStackViewport,
        IVolumeViewport,
        IEnabledElement,
        ICache,
        IVolume,
        VolumeScalarData,
        IViewportId,
        IImageVolume,
        IDynamicImageVolume,
        IRenderingEngine,
        ScalingParameters,
        PTScaling,
        Scaling,
        IStreamingImageVolume,
        IImage,
        IImageData,
        CPUIImageData,
        CPUImageData,
        EventTypes,
        ImageLoaderFn,
        VolumeLoaderFn,
        IRegisterImageLoader,
        IStreamingVolumeProperties,
        IViewport,
        StackViewportProperties,
        VolumeViewportProperties,
        ViewportProperties,
        PublicViewportInput,
        VolumeActor,
        Actor,
        ActorEntry,
        IImageLoadObject,
        IVolumeLoadObject,
        IVolumeInput,
        VolumeInputCallback,
        ViewportPreset,
        Metadata,
        OrientationVectors,
        Point2,
        Point3,
        Point4,
        Mat3,
        Plane,
        ViewportInputOptions,
        VOIRange,
        VOI,
        DisplayArea,
        FlipDirection,
        ICachedImage,
        ICachedVolume,
        CPUFallbackEnabledElement,
        CPUFallbackViewport,
        CPUFallbackTransform,
        CPUFallbackColormapData,
        CPUFallbackViewportDisplayedArea,
        CPUFallbackColormapsData,
        CPUFallbackColormap,
        TransformMatrix2D,
        CPUFallbackLookupTable,
        CPUFallbackLUT,
        CPUFallbackRenderingTools,
        CustomEvent_2 as CustomEventType,
        ActorSliceRange,
        ImageSliceData,
        IGeometry,
        IGeometryLoadObject,
        ICachedGeometry,
        PublicContourSetData,
        ContourSetData,
        ContourData,
        IContourSet,
        IContour,
        RGB,
        ColormapPublic,
        ColormapRegistration,
        PixelDataTypedArray,
        ImagePixelModule,
        ImagePlaneModule
    }
}
export { Types }

// @public (undocumented)
function unregisterAllImageLoaders(): void;

declare namespace utilities {
    export {
        invertRgbTransferFunction,
        createSigmoidRGBTransferFunction,
        getVoiFromSigmoidRGBTransferFunction,
        createLinearRGBTransferFunction,
        scaleRGBTransferFunction as scaleRgbTransferFunction,
        triggerEvent,
        imageIdToURI,
        metadataProvider as calibratedPixelSpacingMetadataProvider,
        uuidv4,
        planar,
        getMinMax,
        getRuntimeId,
        isEqual,
        isOpposite,
        createFloat32SharedArray,
        createUint8SharedArray,
        createUint16SharedArray,
        createInt16SharedArray,
        windowLevel,
        getClosestImageId,
        getSpacingInNormalDirection,
        getTargetVolumeAndSpacingInNormalDir,
        getVolumeActorCorners,
        indexWithinDimensions,
        getVolumeViewportsContainingSameVolumes,
        getViewportsWithVolumeId,
        transformWorldToIndex,
        loadImageToCanvas,
        renderToCanvasCPU,
        renderToCanvasGPU,
        worldToImageCoords,
        imageToWorldCoords,
        getVolumeSliceRangeInfo,
        getVolumeViewportScrollInfo,
        getSliceRange,
        snapFocalPointToSlice,
        getImageSliceDataForVolumeViewport,
        isImageActor,
        isPTPrescaledWithSUV,
        actorIsA,
        getViewportsWithImageURI,
        getClosestStackImageIndexForPoint,
        calculateViewportsSpatialRegistration,
        spatialRegistrationMetadataProvider,
        getViewportImageCornersInWorld,
        hasNaNValues,
        applyPreset,
        deepMerge,
        getScalingParameters,
        getScalarDataType,
        colormap,
        getImageLegacy
    }
}
export { utilities }

// @public (undocumented)
function uuidv4(): string;

// @public (undocumented)
export class Viewport implements IViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    _actors: Map<string, any>;
    // (undocumented)
    addActor(actorEntry: ActorEntry): void;
    // (undocumented)
    addActors(actors: Array<ActorEntry>, resetCameraPanAndZoom?: boolean): void;
    // (undocumented)
    readonly canvas: HTMLCanvasElement;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => unknown;
    // (undocumented)
    readonly defaultOptions: any;
    // (undocumented)
    readonly element: HTMLDivElement;
    // (undocumented)
    protected flip({ flipHorizontal, flipVertical }: FlipDirection): void;
    // (undocumented)
    protected flipHorizontal: boolean;
    // (undocumented)
    protected flipVertical: boolean;
    // (undocumented)
    getActor(actorUID: string): ActorEntry;
    // (undocumented)
    getActorByIndex(index: number): ActorEntry;
    // (undocumented)
    getActors(): Array<ActorEntry>;
    // (undocumented)
    getActorUIDByIndex(index: number): string;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    // (undocumented)
    getDefaultActor(): ActorEntry;
    // (undocumented)
    getDisplayArea(): DisplayArea | undefined;
    // (undocumented)
    _getEdges(bounds: Array<number>): Array<[number[], number[]]>;
    // (undocumented)
    _getFocalPointForResetCamera(centeredFocalPoint: Point3, previousCamera: ICamera, { resetPan, resetToCenter }: {
        resetPan?: boolean;
        resetToCenter?: boolean;
    }): Point3;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getPan(): Point2;
    // (undocumented)
    getProperties: () => void;
    // (undocumented)
    getRenderer(): any;
    // (undocumented)
    getRenderingEngine(): IRenderingEngine;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    protected getVtkActiveCamera(): vtkCamera | vtkSlabCamera;
    // (undocumented)
    getZoom(): number;
    // (undocumented)
    protected hasPixelSpacing: boolean;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    protected initialCamera: ICamera;
    // (undocumented)
    isDisabled: boolean;
    // (undocumented)
    _isInBounds(point: Point3, bounds: number[]): boolean;
    // (undocumented)
    options: ViewportInputOptions;
    // (undocumented)
    _removeActor(actorUID: string): void;
    // (undocumented)
    removeActors(actorUIDs: Array<string>): void;
    // (undocumented)
    removeAllActors(): void;
    // (undocumented)
    render(): void;
    // (undocumented)
    readonly renderingEngineId: string;
    // (undocumented)
    reset(immediate?: boolean): void;
    // (undocumented)
    protected resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean, storeAsInitialCamera?: boolean): boolean;
    // (undocumented)
    protected resetCameraNoEvent(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    setActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    protected setCameraNoEvent(camera: ICamera): void;
    // (undocumented)
    setDisplayArea(displayArea: DisplayArea, suppressEvents?: boolean): void;
    // (undocumented)
    protected setFitToCanvasCamera(camera: ICamera): void;
    // (undocumented)
    protected setInitialCamera(camera: ICamera): void;
    // (undocumented)
    setOptions(options: ViewportInputOptions, immediate?: boolean): void;
    // (undocumented)
    setOrientationOfClippingPlanes(vtkPlanes: Array<vtkPlane>, slabThickness: number, viewPlaneNormal: Point3, focalPoint: Point3): void;
    // (undocumented)
    setPan(pan: Point2, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    setZoom(value: number, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    sHeight: number;
    // (undocumented)
    protected _shouldUseNativeDataType(): boolean;
    // (undocumented)
    readonly suppressEvents: boolean;
    // (undocumented)
    sWidth: number;
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    triggerCameraModifiedEventIfNecessary(previousCamera: ICamera, updatedCamera: ICamera): void;
    // (undocumented)
    readonly type: ViewportType;
    // (undocumented)
    protected updateClippingPlanesForActors(updatedCamera: ICamera): void;
    // (undocumented)
    updateRenderingPipeline: () => void;
    // (undocumented)
    static get useCustomRenderingPipeline(): boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
type ViewportInputOptions = {
    background?: RGB;
    orientation?: OrientationAxis | OrientationVectors;
    displayArea?: DisplayArea;
    suppressEvents?: boolean;
    parallelProjection?: boolean;
};

// @public (undocumented)
interface ViewportPreset {
    // (undocumented)
    ambient: string;
    // (undocumented)
    colorTransfer: string;
    // (undocumented)
    diffuse: string;
    // (undocumented)
    gradientOpacity: string;
    // (undocumented)
    interpolation: string;
    // (undocumented)
    name: string;
    // (undocumented)
    scalarOpacity: string;
    // (undocumented)
    shade: string;
    // (undocumented)
    specular: string;
    // (undocumented)
    specularPower: string;
}

// @public (undocumented)
type ViewportProperties = {
    voiRange?: VOIRange;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
};

// @public (undocumented)
enum ViewportType {
    // (undocumented)
    ORTHOGRAPHIC = "orthographic",
    // (undocumented)
    PERSPECTIVE = "perspective",
    // (undocumented)
    STACK = "stack",
    // (undocumented)
    VOLUME_3D = "volume3d"
}

// @public (undocumented)
type VOI = {
    windowWidth: number;
    windowCenter: number;
};

// @public (undocumented)
enum VOILUTFunctionType {
    // (undocumented)
    LINEAR = "LINEAR",
    // (undocumented)
    SAMPLED_SIGMOID = "SIGMOID"
}

// @public (undocumented)
type VoiModifiedEvent = CustomEvent_2<VoiModifiedEventDetail>;

// @public (undocumented)
type VoiModifiedEventDetail = {
    viewportId: string;
    range: VOIRange;
    volumeId?: string;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
};

// @public (undocumented)
type VOIRange = {
    upper: number;
    lower: number;
};

// @public (undocumented)
type VolumeActor = vtkVolume;

// @public (undocumented)
type VolumeCacheVolumeAddedEvent = CustomEvent_2<VolumeCacheVolumeAddedEventDetail>;

// @public (undocumented)
type VolumeCacheVolumeAddedEventDetail = {
    volume: ICachedVolume;
};

// @public (undocumented)
type VolumeCacheVolumeRemovedEvent = CustomEvent_2<VolumeCacheVolumeRemovedEventDetail>;

// @public (undocumented)
type VolumeCacheVolumeRemovedEventDetail = {
    volumeId: string;
};

// @public (undocumented)
type VolumeInputCallback = (params: {
    volumeActor: VolumeActor;
    volumeId: string;
}) => unknown;

// @public (undocumented)
type VolumeLoadedEvent = CustomEvent_2<VolumeLoadedEventDetail>;

// @public (undocumented)
type VolumeLoadedEventDetail = {
    volume: IImageVolume;
};

// @public (undocumented)
type VolumeLoadedFailedEvent = CustomEvent_2<VolumeLoadedFailedEventDetail>;

// @public (undocumented)
type VolumeLoadedFailedEventDetail = {
    volumeId: string;
    error: unknown;
};

declare namespace volumeLoader {
    export {
        loadVolume,
        createAndCacheVolume,
        createAndCacheDerivedVolume,
        createLocalVolume,
        registerVolumeLoader,
        getVolumeLoaderSchemes,
        registerUnknownVolumeLoader
    }
}
export { volumeLoader }

// @public (undocumented)
type VolumeLoaderFn = (volumeId: string, options?: Record<string, any>) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
type VolumeNewImageEvent = CustomEvent_2<VolumeNewImageEventDetail>;

// @public (undocumented)
type VolumeNewImageEventDetail = {
    imageIndex: number;
    numberOfSlices: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type VolumeScalarData = Float32Array | Uint8Array | Uint16Array | Int16Array;

// @public (undocumented)
export class VolumeViewport extends BaseVolumeViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    addVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    getCurrentImageId: () => string | undefined;
    // (undocumented)
    getCurrentImageIdIndex: () => number | undefined;
    // (undocumented)
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getSlabThickness(): number;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean): boolean;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: any[], immediate?: boolean): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis, immediate?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: any[]): void;
    // (undocumented)
    setVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
}

// @public (undocumented)
export class VolumeViewport3D extends BaseVolumeViewport {
    constructor(props: ViewportInput);
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number | undefined;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean): boolean;
}

// @public (undocumented)
type VolumeViewportProperties = ViewportProperties & {
    colormap?: ColormapPublic;
    preset?: string;
};

declare namespace windowLevel {
    export {
        toWindowLevel,
        toLowHighRange
    }
}

// @public (undocumented)
function worldToImageCoords(imageId: string, worldCoords: Point3): Point2 | undefined;

// (No @packageDocumentation comment for this package)

```

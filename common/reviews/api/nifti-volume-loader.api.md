## API Report File for "@cornerstonejs/nifti-volume-loader"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { GetGPUTier } from 'detect-gpu';
import type { mat4 } from 'gl-matrix';
import type { TierResult } from 'detect-gpu';
import type vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';
import type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';
import vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import type vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';

// @public (undocumented)
export function cornerstoneNiftiImageVolumeLoader(volumeId: string): IVolumeLoader;

declare namespace Enums {
    export {
        Events
    }
}
export { Enums }

// @public (undocumented)
enum Events {
    // (undocumented)
    NIFTI_VOLUME_LOADED = "CORNERSTONE_NIFTI_VOLUME_LOADED",
    // (undocumented)
    NIFTI_VOLUME_PROGRESS = "CORNERSTONE_NIFTI_VOLUME_PROGRESS"
}

// @public (undocumented)
function fetchAndAllocateNiftiVolume(volumeId: string): Promise<NiftiImageVolume>;

declare namespace helpers {
    export {
        modalityScaleNifti,
        makeVolumeMetadata,
        fetchAndAllocateNiftiVolume
    }
}
export { helpers }

// @public (undocumented)
<<<<<<< HEAD
interface ICache {
    getCacheSize: () => number;
    getImageLoadObject: (imageId: string) => IImageLoadObject | void;
    getMaxCacheSize: () => number;
    getVolumeLoadObject: (volumeId: string) => IVolumeLoadObject | void;
    purgeCache: () => void;
    putImageLoadObject: (
    imageId: string,
    imageLoadObject: IImageLoadObject
    ) => Promise<any>;
    putVolumeLoadObject: (
    volumeId: string,
    volumeLoadObject: IVolumeLoadObject
    ) => Promise<any>;
    setMaxCacheSize: (maxCacheSize: number) => void;
}

// @public (undocumented)
interface ICachedGeometry {
    // (undocumented)
    geometry?: IGeometry;
    // (undocumented)
    geometryId: string;
    // (undocumented)
    geometryLoadObject: IGeometryLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedImage {
    // (undocumented)
    image?: IImage;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageLoadObject: IImageLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedVolume {
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
    // (undocumented)
    volume?: IImageVolume;
    // (undocumented)
    volumeId: string;
    // (undocumented)
    volumeLoadObject: IVolumeLoadObject;
}

// @public
interface ICamera {
    clippingRange?: Point2;
    flipHorizontal?: boolean;
    flipVertical?: boolean;
    focalPoint?: Point3;
    parallelProjection?: boolean;
    parallelScale?: number;
    position?: Point3;
    scale?: number;
    viewAngle?: number;
    viewPlaneNormal?: Point3;
    viewUp?: Point3;
}

// @public (undocumented)
interface IContour {
    // (undocumented)
    color: any;
    // (undocumented)
    getColor(): Point3;
    // (undocumented)
    getFlatPointsArray(): number[];
    getPoints(): Point3[];
    // (undocumented)
    _getSizeInBytes(): number;
    // (undocumented)
    getType(): ContourType;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    points: Point3[];
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public
interface IContourSet {
    // (undocumented)
    contours: IContour[];
    // (undocumented)
    _createEachContour(data: ContourData[]): void;
    // (undocumented)
    readonly frameOfReferenceUID: string;
    // (undocumented)
    getCentroid(): Point3;
    // (undocumented)
    getColor(): any;
    getContours(): IContour[];
    getFlatPointsArray(): Point3[];
    getNumberOfContours(): number;
    getNumberOfPointsArray(): number[];
    getNumberOfPointsInAContour(contourIndex: number): number;
    getPointsInContour(contourIndex: number): Point3[];
    // (undocumented)
    getSegmentIndex(): number;
    // (undocumented)
    getSizeInBytes(): number;
    getTotalNumberOfPoints(): number;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public
interface IDynamicImageVolume extends IImageVolume {
    getScalarDataArrays(): VolumeScalarData[];
    get numTimePoints(): number;
    get timePointIndex(): number;
    set timePointIndex(newTimePointIndex: number);
}

// @public
interface IEnabledElement {
    FrameOfReferenceUID: string;
    renderingEngine: IRenderingEngine;
    renderingEngineId: string;
    viewport: IStackViewport | IVolumeViewport;
    viewportId: string;
}

// @public (undocumented)
interface IGeometry {
    // (undocumented)
    data: IContourSet | Surface;
    // (undocumented)
    id: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    type: GeometryType;
}

// @public (undocumented)
interface IGeometryLoadObject {
    cancelFn?: () => void;
    decache?: () => void;
    promise: Promise<IGeometry>;
}

// @public
interface IImage {
    cachedLut?: {
        windowWidth?: number | number[];
        windowCenter?: number | number[];
        invert?: boolean;
        lutArray?: Uint8ClampedArray;
        modalityLUT?: unknown;
        voiLUT?: CPUFallbackLUT;
    };
    color: boolean;
    colormap?: CPUFallbackColormap;
    columnPixelSpacing: number;
    columns: number;
    // (undocumented)
    decodeTimeInMS?: number;
    // (undocumented)
    getCanvas: () => HTMLCanvasElement;
    getPixelData: () => PixelDataTypedArray;
    height: number;
    imageId: string;
    intercept: number;
    invert: boolean;
    isPreScaled?: boolean;
    // (undocumented)
    loadTimeInMS?: number;
    // (undocumented)
    maxPixelValue: number;
    minPixelValue: number;
    modalityLUT?: CPUFallbackLUT;
    numComps: number;
    photometricInterpretation?: string;
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    render?: (
    enabledElement: CPUFallbackEnabledElement,
    invalidated: boolean
    ) => unknown;
    rgba: boolean;
    rowPixelSpacing: number;
    rows: number;
    scaling?: {
        PT?: {
            // @TODO: Do these values exist?
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            // accessed in ProbeTool
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sharedCacheKey?: string;
    sizeInBytes: number;
    sliceThickness?: number;
    slope: number;
    stats?: {
        lastStoredPixelDataToCanvasImageDataTime?: number;
        lastGetPixelDataTime?: number;
        lastPutImageDataTime?: number;
        lastLutGenerateTime?: number;
        lastRenderedViewport?: unknown;
        lastRenderTime?: number;
    };
    voiLUT?: CPUFallbackLUT;
    voiLUTFunction: string;
    width: number;
    windowCenter: number[] | number;
    windowWidth: number[] | number;
}

// @public
interface IImageCalibration {
    aspect?: number;
    // (undocumented)
    columnPixelSpacing?: number;
    rowPixelSpacing?: number;
    scale?: number;
    sequenceOfUltrasoundRegions?: Record<string, unknown>[];
    tooltip?: string;
    type: CalibrationTypes;
}

// @public
interface IImageData {
    // (undocumented)
    calibration?: IImageCalibration;
    dimensions: Point3;
    direction: Mat3;
    hasPixelSpacing?: boolean;
    imageData: vtkImageData;
    metadata: { Modality: string };
    origin: Point3;
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    scalarData: Float32Array | Uint16Array | Uint8Array | Int16Array;
    scaling?: Scaling;
    spacing: Point3;
}

// @public
interface IImageLoadObject {
    cancelFn?: () => void;
    decache?: () => void;
    promise: Promise<IImage>;
}

// @public
interface IImageVolume {
    // (undocumented)
    cancelLoading?: () => void;
    convertToCornerstoneImage?: (
    imageId: string,
    imageIdIndex: number
    ) => IImageLoadObject;
    destroy(): void;
    dimensions: Point3;
    direction: Mat3;
    getImageIdIndex(imageId: string): number;
    getImageURIIndex(imageURI: string): number;
    getScalarData(): VolumeScalarData;
    hasPixelSpacing: boolean;
    imageData?: vtkImageData;
    imageIds: Array<string>;
    isDynamicVolume(): boolean;
    isPreScaled: boolean;
    loadStatus?: Record<string, any>;
    metadata: Metadata;
    numVoxels: number;
    origin: Point3;
    referencedVolumeId?: string;
    scaling?: {
        PT?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    sizeInBytes?: number;
    spacing: Point3;
    readonly volumeId: string;
    vtkOpenGLTexture: any;
}

// @public (undocumented)
type ImageActor = vtkImageSlice;

// @public
type ImageCacheImageAddedEvent =
CustomEvent_2<ImageCacheImageAddedEventDetail>;

// @public
type ImageCacheImageAddedEventDetail = {
    image: ICachedImage;
};

// @public
type ImageCacheImageRemovedEvent =
CustomEvent_2<ImageCacheImageRemovedEventDetail>;

// @public
type ImageCacheImageRemovedEventDetail = {
    imageId: string;
};

// @public
type ImageLoadedEvent = CustomEvent_2<ImageLoadedEventDetail>;

// @public
type ImageLoadedEventDetail = {
    image: IImage;
};

// @public
type ImageLoadedFailedEvent = CustomEvent_2<ImageLoadedFailedEventDetail>;

// @public
type ImageLoadedFailedEventDetail = {
    imageId: string;
    error: unknown;
};

// @public
type ImageLoaderFn = (
imageId: string,
options?: Record<string, any>
) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public
type ImageLoadProgressEvent = CustomEvent_2<ImageLoadProgressEventDetail>;

// @public
type ImageLoadProgressEventDetail = {
    url: string;
    imageId: string;
    loaded: number;
    total: number;
    percent: number;
};

// @public (undocumented)
interface ImagePixelModule {
    // (undocumented)
    bitsAllocated: number;
    // (undocumented)
    bitsStored: number;
    // (undocumented)
    highBit: number;
    // (undocumented)
    modality: string;
    // (undocumented)
    photometricInterpretation: string;
    // (undocumented)
    pixelRepresentation: string;
    // (undocumented)
    samplesPerPixel: number;
    // (undocumented)
    voiLUTFunction: VOILUTFunctionType;
    // (undocumented)
    windowCenter: number | number[];
    // (undocumented)
    windowWidth: number | number[];
}

// @public (undocumented)
interface ImagePlaneModule {
    // (undocumented)
    columnCosines?: Point3;
    // (undocumented)
    columnPixelSpacing?: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    frameOfReferenceUID: string;
    // (undocumented)
    imageOrientationPatient?: Float32Array;
    // (undocumented)
    imagePositionPatient?: Point3;
    // (undocumented)
    pixelSpacing?: Point2;
    // (undocumented)
    rowCosines?: Point3;
    // (undocumented)
    rowPixelSpacing?: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    sliceLocation?: number;
    // (undocumented)
    sliceThickness?: number;
}

// @public
type ImageRenderedEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public
type ImageRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    suppressEvents?: boolean;
    viewportStatus: ViewportStatus;
};

// @public (undocumented)
type ImageSliceData = {
    numberOfSlices: number;
    imageIndex: number;
};

// @public
type ImageSpacingCalibratedEvent =
CustomEvent_2<ImageSpacingCalibratedEventDetail>;

// @public
type ImageSpacingCalibratedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    imageId: string;
    calibration: IImageCalibration;
    imageData: vtkImageData;
    worldToIndex: mat4;
};

// @public
type ImageVolumeLoadingCompletedEvent =
CustomEvent_2<ImageVolumeLoadingCompletedEventDetail>;

// @public
type ImageVolumeLoadingCompletedEventDetail = {
    volumeId: string;
    FrameOfReferenceUID: string;
};

// @public
type ImageVolumeModifiedEvent = CustomEvent_2<ImageVolumeModifiedEventDetail>;

// @public
type ImageVolumeModifiedEventDetail = {
    imageVolume: IImageVolume;
    FrameOfReferenceUID: string;
};

// @public (undocumented)
type InternalVideoCamera = {
    panWorld?: Point2;
    parallelScale?: number;
};

// @public
interface IRegisterImageLoader {
    // (undocumented)
    registerImageLoader: (scheme: string, imageLoader: ImageLoaderFn) => void;
}

// @public (undocumented)
interface IRenderingEngine {
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(
    canvas: HTMLCanvasElement,
    backgroundColor: [number, number, number]
    ): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getVideoViewports(): Array<IVideoViewport>;
    // (undocumented)
    getViewport(id: string): IViewport;
    // (undocumented)
    getViewports(): Array<IViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference(FrameOfReferenceUID: string): void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, keepCamera?: boolean): void;
    // (undocumented)
    setViewports(viewports: Array<PublicViewportInput>): void;
}

// @public
interface IStackViewport extends IViewport {
    calibrateSpacing(imageId: string): void;
    canvasToWorld: (canvasPos: Point2) => Point3;
    clearDefaultProperties(imageId?: string): void;
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
    };
    getCamera(): ICamera;
    getCornerstoneImage: () => IImage;
    getCurrentImageId: () => string;
    getCurrentImageIdIndex: () => number;
    getDefaultProperties: (imageId?: string) => StackViewportProperties;
    getFrameOfReferenceUID: () => string;
    getImageData(): IImageData | CPUIImageData;
    getImageIds: () => string[];
    getProperties: () => StackViewportProperties;
    getRenderer(): any;
    hasImageId: (imageId: string) => boolean;
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    modality: string;
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    resetProperties(): void;
    resetToDefaultProperties(): void;
    resize: () => void;
    scaling: Scaling;
    setCamera(cameraInterface: ICamera): void;
    setDefaultProperties(
    ViewportProperties: StackViewportProperties,
    imageId?: string
    ): void;
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    setProperties(
        {
        voiRange,
        invert,
        interpolationType,
        rotation,
        colormap,
    }: StackViewportProperties,
    suppressEvents?: boolean
    ): void;
    setStack(
    imageIds: Array<string>,
    currentImageIdIndex?: number
    ): Promise<string>;
    unsetColormap(): void;
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public
interface IStreamingImageVolume extends ImageVolume {
    clearLoadCallbacks(): void;
    convertToCornerstoneImage(imageId: string, imageIdIndex: number): any;
    decache(completelyRemove: boolean): void;
}

// @public (undocumented)
interface IStreamingVolumeProperties {
    imageIds: Array<string>;

    loadStatus: {
        loaded: boolean;
        loading: boolean;
        cancelled: boolean;
        cachedFrames: Array<boolean>;
        callbacks: Array<() => void>;
    };
}

// @public
interface IVideoViewport extends IViewport {
    getProperties: () => VideoViewportProperties;
    // (undocumented)
    pause: () => void;
    // (undocumented)
    play: () => void;
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    resetProperties(): void;
    resize: () => void;
    setProperties(props: VideoViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    setVideoURL: (url: string) => void;
}

// @public
interface IViewport {
    _actors: Map<string, any>;
    addActor(actorEntry: ActorEntry): void;
    addActors(actors: Array<ActorEntry>): void;
    canvas: HTMLCanvasElement;
    canvasToWorld: (canvasPos: Point2) => Point3;
    customRenderViewportToCanvas: () => unknown;
    defaultOptions: any;
    element: HTMLDivElement;
    getActor(actorUID: string): ActorEntry;
    getActorByIndex(index: number): ActorEntry;
    getActors(): Array<ActorEntry>;
    getActorUIDByIndex(index: number): string;
    getCamera(): ICamera;
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    getDefaultActor(): ActorEntry;
    getDisplayArea(): DisplayArea | undefined;
    getFrameOfReferenceUID: () => string;
    getPan(): Point2;
    getRenderer(): void;
    getRenderingEngine(): any;
    getRotation: (camera? : ICamera) => number;
    getZoom(): number;
    id: string;
    isDisabled: boolean;
    options: ViewportInputOptions;
    removeActors(actorUIDs: Array<string>): void;
    removeAllActors(): void;
    render(): void;
    renderingEngineId: string;
    reset(immediate: boolean): void;
    setActors(actors: Array<ActorEntry>): void;
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    setDisplayArea(
    displayArea: DisplayArea,
    callResetCamera?: boolean,
    suppressEvents?: boolean
    );
    setOptions(options: ViewportInputOptions, immediate: boolean): void;
    setPan(pan: Point2, storeAsInitialCamera?: boolean);
    setRendered(): void;
    setZoom(zoom: number, storeAsInitialCamera?: boolean);
    sHeight: number;
    suppressEvents: boolean;
    sWidth: number;
    sx: number;
    sy: number;
    type: ViewportType;
    // (undocumented)
    updateRenderingPipeline: () => void;
    viewportStatus: ViewportStatus;
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public
interface IViewportId {
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public
interface IVolume {
    dimensions: Point3;
    direction: Mat3;
    imageData?: vtkImageData;
    metadata: Metadata;
    origin: Point3;
    referencedVolumeId?: string;
    scalarData: VolumeScalarData | Array<VolumeScalarData>;
    scaling?: {
        PT?: {
            // @TODO: Do these values exist?
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            // accessed in ProbeTool
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    sizeInBytes?: number;
    spacing: Point3;
    volumeId: string;
}

// @public
interface IVolumeInput {
    // (undocumented)
    actorUID?: string;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    blendMode?: BlendModes;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    callback?: VolumeInputCallback;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    slabThickness?: number;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    visibility?: boolean;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    volumeId: string;
}

// @public
interface IVolumeLoadObject {
    cancelFn?: () => void;
    decache?: () => void;
    promise: Promise<ImageVolume>;
}

// @public
interface IVolumeViewport extends IViewport {
    addVolumes(
    volumeInputArray: Array<IVolumeInput>,
    immediate?: boolean,
    suppressEvents?: boolean
    ): Promise<void>;
    canvasToWorld: (canvasPos: Point2) => Point3;
    clearDefaultProperties(volumeId?: string): void;
    flip(flipDirection: FlipDirection): void;
    getBounds(): any;
    getCurrentImageId: () => string;
    getCurrentImageIdIndex: () => number;
    getDefaultProperties: (volumeId?: string) => VolumeViewportProperties;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    getImageData(volumeId?: string): IImageData | undefined;
    getImageIds: (volumeId?: string) => string[];
    getIntensityFromWorld(point: Point3): number;
    getProperties: (volumeId?: string) => VolumeViewportProperties;
    getSlabThickness(): number;
    hasImageURI: (imageURI: string) => boolean;
    hasVolumeId: (volumeId: string) => boolean;
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    resetCamera(
    resetPan?: boolean,
    resetZoom?: boolean,
    resetToCenter?: boolean
    ): boolean;
    resetProperties(volumeId: string): void;
    setBlendMode(
    blendMode: BlendModes,
    filterActorUIDs?: Array<string>,
    immediate?: boolean
    ): void;
    setDefaultProperties(
    ViewportProperties: VolumeViewportProperties,
    volumeId?: string
    ): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis): void;
    setProperties(
        { voiRange }: VolumeViewportProperties,
    volumeId?: string,
    suppressEvents?: boolean
    ): void;
    setSlabThickness(
    slabThickness: number,
    filterActorUIDs?: Array<string>
    ): void;
    setVolumes(
    volumeInputArray: Array<IVolumeInput>,
    immediate?: boolean,
    suppressEvents?: boolean
    ): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
=======
>>>>>>> 8c78a01f328ad05b05c4664fce746281ed381829
function makeVolumeMetadata(niftiHeader: any, orientation: any, scalarData: any): Types.Metadata;

// @public (undocumented)
function modalityScaleNifti(array: Float32Array | Int16Array | Uint8Array, niftiHeader: any): void;

// @public (undocumented)
export class NiftiImageVolume extends ImageVolume {
    constructor(imageVolumeProperties: Types.IVolume, streamingProperties: NiftiImageProperties);
    // (undocumented)
    cancelLoading: () => void;
    // (undocumented)
    clearLoadCallbacks(): void;
    // (undocumented)
    controller: AbortController;
    // (undocumented)
    decache(): void;
    // (undocumented)
    load: (callback: (...args: unknown[]) => void, priority?: number) => void;
    // (undocumented)
    loadStatus: LoadStatus;
}

<<<<<<< HEAD
// @public
type OrientationVectors = {
    viewPlaneNormal: Point3;
    viewUp: Point3;
};

// @public (undocumented)
type PixelDataTypedArray =
| Float32Array
| Int16Array
| Uint16Array
| Uint8Array
| Int8Array
| Uint8ClampedArray;

// @public
type Plane = [number, number, number, number];

// @public
type Point2 = [number, number];

// @public
type Point3 = [number, number, number];

// @public
type Point4 = [number, number, number, number];

// @public
type PreStackNewImageEvent = CustomEvent_2<PreStackNewImageEventDetail>;

// @public
type PreStackNewImageEventDetail = {
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type PTScaling = {
    suvbwToSuvlbm?: number;
    suvbwToSuvbsa?: number;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
type PublicContourSetData = ContourSetData;

// @public (undocumented)
type PublicSurfaceData = {
    id: string;
    data: SurfaceData;
    frameOfReferenceUID: string;
    color?: Point3;
};

// @public
type PublicViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions?: ViewportInputOptions;
};

// @public
type RGB = [number, number, number];

// @public (undocumented)
type Scaling = {
    PT?: PTScaling;
};

// @public (undocumented)
type ScalingParameters = {
    rescaleSlope: number;
    rescaleIntercept: number;
    modality: string;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public
type StackNewImageEvent = CustomEvent_2<StackNewImageEventDetail>;

// @public
type StackNewImageEventDetail = {
    image: IImage;
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public
type StackViewportNewStackEvent =
CustomEvent_2<StackViewportNewStackEventDetail>;

// @public
type StackViewportNewStackEventDetail = {
    imageIds: string[];
    viewportId: string;
    element: HTMLDivElement;
    currentImageIdIndex: number;
};

// @public
type StackViewportProperties = ViewportProperties & {
    interpolationType?: InterpolationType;
    rotation?: number;
    suppressEvents?: boolean;
    isComputedVOI?: boolean;
};

// @public (undocumented)
type StackViewportScrollEvent = CustomEvent_2<StackViewportScrollEventDetail>;

// @public
type StackViewportScrollEventDetail = {
    newImageIdIndex: number;
    imageId: string;
    direction: number;
};

// @public (undocumented)
type SurfaceData = {
    points: number[];
    polys: number[];
};

// @public
type TransformMatrix2D = [number, number, number, number, number, number];

// @public (undocumented)
type VideoViewportInput = {
    id: string;
    renderingEngineId: string;
    type: ViewportType;
    element: HTMLDivElement;
    sx: number;
    sy: number;
    sWidth: number;
    sHeight: number;
    defaultOptions: any;
    canvas: HTMLCanvasElement;
};

// @public
type VideoViewportProperties = ViewportProperties & {
    loop?: boolean;
    muted?: boolean;
    pan?: Point2;
    playbackRate?: number;
    // The zoom factor, naming consistent with vtk cameras for now,
    // but this isn't necessarily necessary.
    parallelScale?: number;
};

// @public
type ViewportInputOptions = {
    background?: RGB;
    orientation?: OrientationAxis | OrientationVectors;
    displayArea?: DisplayArea;
    suppressEvents?: boolean;
    parallelProjection?: boolean;
};

// @public (undocumented)
interface ViewportPreset {
    // (undocumented)
    ambient: string;
    // (undocumented)
    colorTransfer: string;
    // (undocumented)
    diffuse: string;
    // (undocumented)
    gradientOpacity: string;
    // (undocumented)
    interpolation: string;
    // (undocumented)
    name: string;
    // (undocumented)
    scalarOpacity: string;
    // (undocumented)
    shade: string;
    // (undocumented)
    specular: string;
    // (undocumented)
    specularPower: string;
}

// @public
type ViewportProperties = {
    voiRange?: VOIRange;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
    colormap?: ColormapPublic;
    interpolationType?: InterpolationType;
    rotation?: number;
};

// @public (undocumented)
type VOI = {
    windowWidth: number;
    windowCenter: number;
};

// @public
type VoiModifiedEvent = CustomEvent_2<VoiModifiedEventDetail>;

// @public
type VoiModifiedEventDetail = {
    viewportId: string;
    range: VOIRange;
    volumeId?: string;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
    invertStateChanged?: boolean;
};

// @public (undocumented)
type VOIRange = {
    upper: number;
    lower: number;
};

// @public (undocumented)
type VolumeActor = vtkVolume;

// @public
type VolumeCacheVolumeAddedEvent =
CustomEvent_2<VolumeCacheVolumeAddedEventDetail>;

// @public
type VolumeCacheVolumeAddedEventDetail = {
    volume: ICachedVolume;
};

// @public
type VolumeCacheVolumeRemovedEvent =
CustomEvent_2<VolumeCacheVolumeRemovedEventDetail>;

// @public
type VolumeCacheVolumeRemovedEventDetail = {
    volumeId: string;
};

// @public
type VolumeInputCallback = (params: {
    volumeActor: VolumeActor;
    volumeId: string;
}) => unknown;

// @public
type VolumeLoadedEvent = CustomEvent_2<VolumeLoadedEventDetail>;

// @public
type VolumeLoadedEventDetail = {
    volume: IImageVolume;
};

// @public
type VolumeLoadedFailedEvent = CustomEvent_2<VolumeLoadedFailedEventDetail>;

// @public
type VolumeLoadedFailedEventDetail = {
    volumeId: string;
    error: unknown;
};

// @public
type VolumeLoaderFn = (
volumeId: string,
options?: Record<string, any>
) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public
type VolumeNewImageEvent = CustomEvent_2<VolumeNewImageEventDetail>;

// @public
type VolumeNewImageEventDetail = {
    imageIndex: number;
    numberOfSlices: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type VolumeScalarData = Float32Array | Uint8Array | Uint16Array | Int16Array;

// @public
type VolumeViewportProperties = ViewportProperties & {
    preset?: string;

    slabThickness?: number;

    orientation?: OrientationAxis;
};

=======
>>>>>>> 8c78a01f328ad05b05c4664fce746281ed381829
// (No @packageDocumentation comment for this package)

```

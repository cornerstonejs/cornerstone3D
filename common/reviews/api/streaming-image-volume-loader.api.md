## API Report File for "@cornerstonejs/streaming-image-volume-loader"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { default as default_2 } from 'packages/core/dist/esm/enums/RequestType';
import type { mat4 } from 'gl-matrix';
import type vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';
import type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';
import vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import type vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';

// @public (undocumented)
type Actor = vtkActor;

// @public
type ActorEntry = {
    uid: string;
    actor: Actor | VolumeActor | ImageActor;
    referenceId?: string;
    slabThickness?: number;
};

// @public
type ActorSliceRange = {
    actor: VolumeActor;
    viewPlaneNormal: Point3;
    focalPoint: Point3;
    min: number;
    max: number;
    current: number;
};

// @public
enum BlendModes {
    AVERAGE_INTENSITY_BLEND = BlendMode.AVERAGE_INTENSITY_BLEND,
    COMPOSITE = BlendMode.COMPOSITE_BLEND,
    MAXIMUM_INTENSITY_BLEND = BlendMode.MAXIMUM_INTENSITY_BLEND,
    MINIMUM_INTENSITY_BLEND = BlendMode.MINIMUM_INTENSITY_BLEND,
}

// @public
type CameraModifiedEvent = CustomEvent_2<CameraModifiedEventDetail>;

// @public
type CameraModifiedEventDetail = {
    previousCamera: ICamera;
    camera: ICamera;
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    rotation?: number;
};

// @public (undocumented)
type ColormapPublic = {
    name: string;
    opacityMapping?: OpacityMapping[];
};

// @public (undocumented)
type ColormapRegistration = {
    ColorSpace: string;
    Name: string;
    RGBPoints: RGB[];
};

// @public (undocumented)
type ContourData = {
    points: Point3[];
    type: ContourType;
    color: Point3;
    segmentIndex: number;
};

// @public (undocumented)
type ContourSetData = {
    id: string;
    data: ContourData[];
    frameOfReferenceUID: string;
    color?: Point3;
    segmentIndex?: number;
};

// @public (undocumented)
enum ContourType {
    // (undocumented)
    CLOSED_PLANAR = 'CLOSED_PLANAR',
    // (undocumented)
    OPEN_PLANAR = 'OPEN_PLANAR',
}

// @public (undocumented)
type Cornerstone3DConfig = {
    detectGPU: any;
    rendering: {
        // vtk.js supports 8bit integer textures and 32bit float textures.
        // However, if the client has norm16 textures (it can be seen by visiting
        // the webGl report at https://webglreport.com/?v=2), vtk will be default
        // to use it to improve memory usage. However, if the client don't have
        // it still another level of optimization can happen by setting the
        // preferSizeOverAccuracy since it will reduce the size of the texture to half
        // float at the cost of accuracy in rendering. This is a tradeoff that the
        // client can decide.
        //
        // Read more in the following Pull Request:
        // 1. HalfFloat: https://github.com/Kitware/vtk-js/pull/2046
        // 2. Norm16: https://github.com/Kitware/vtk-js/pull/2058
        preferSizeOverAccuracy: boolean;
        // Whether the EXT_texture_norm16 extension is supported by the browser.
        // WebGL 2 report (link: https://webglreport.com/?v=2) can be used to check
        // if the browser supports this extension.
        // In case the browser supports this extension, instead of using 32bit float
        // textures, 16bit float textures will be used to reduce the memory usage where
        // possible.
        // Norm16 may not work currently due to the two active bugs in chrome + safari
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1408247
        // https://bugs.webkit.org/show_bug.cgi?id=252039
        useNorm16Texture: boolean;
        useCPURendering: boolean;
        strictZSpacingForVolumeViewport: boolean;
    };
};

// @public (undocumented)
export function cornerstoneStreamingDynamicImageVolumeLoader(volumeId: string, options: {
    imageIds: string[];
}): IVolumeLoader_2;

// @public (undocumented)
export function cornerstoneStreamingImageVolumeLoader(volumeId: string, options: {
    imageIds: string[];
}): IVolumeLoader;

// @public (undocumented)
interface CPUFallbackColormap {
    // (undocumented)
    addColor: (rgba: Point4) => void;
    // (undocumented)
    buildLookupTable: (lut: CPUFallbackLookupTable) => void;
    // (undocumented)
    clearColors: () => void;
    // (undocumented)
    createLookupTable: () => CPUFallbackLookupTable;
    // (undocumented)
    getColor: (index: number) => Point4;
    // (undocumented)
    getColorRepeating: (index: number) => Point4;
    // (undocumented)
    getColorSchemeName: () => string;
    getId: () => string;
    // (undocumented)
    getNumberOfColors: () => number;
    // (undocumented)
    insertColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    isValidIndex: (index: number) => boolean;
    // (undocumented)
    removeColor: (index: number) => void;
    // (undocumented)
    setColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    setColorSchemeName: (name: string) => void;
    // (undocumented)
    setNumberOfColors: (numColors: number) => void;
}

// @public (undocumented)
type CPUFallbackColormapData = {
    name: string;
    numOfColors?: number;
    colors?: Point4[];
    segmentedData?: unknown;
    numColors?: number;
    gamma?: number;
};

// @public (undocumented)
type CPUFallbackColormapsData = {
    [key: string]: CPUFallbackColormapData;
};

// @public (undocumented)
interface CPUFallbackEnabledElement {
    // (undocumented)
    canvas?: HTMLCanvasElement;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    image?: IImage;
    // (undocumented)
    invalid?: boolean;
    // (undocumented)
    metadata?: {
        direction?: Mat3;
        dimensions?: Point3;
        spacing?: Point3;
        origin?: Point3;
        imagePlaneModule?: ImagePlaneModule;
        imagePixelModule?: ImagePixelModule;
    };
    // (undocumented)
    needsRedraw?: boolean;
    // (undocumented)
    options?: {
        [key: string]: unknown;
        colormap?: CPUFallbackColormap;
    };
    // (undocumented)
    pan?: Point2;
    // (undocumented)
    renderingTools?: CPUFallbackRenderingTools;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    transform?: CPUFallbackTransform;
    // (undocumented)
    viewport?: CPUFallbackViewport;
    // (undocumented)
    zoom?: number;
}

// @public (undocumented)
interface CPUFallbackLookupTable {
    // (undocumented)
    build: (force: boolean) => void;
    // (undocumented)
    getColor: (scalar: number) => Point4;
    // (undocumented)
    setAlphaRange: (start: number, end: number) => void;
    // (undocumented)
    setHueRange: (start: number, end: number) => void;
    // (undocumented)
    setNumberOfTableValues: (number: number) => void;
    // (undocumented)
    setRamp: (ramp: string) => void;
    // (undocumented)
    setRange: (start: number, end: number) => void;
    // (undocumented)
    setSaturationRange: (start: number, end: number) => void;
    // (undocumented)
    setTableRange: (start: number, end: number) => void;
    // (undocumented)
    setTableValue(index: number, rgba: Point4);
    // (undocumented)
    setValueRange: (start: number, end: number) => void;
}

// @public (undocumented)
type CPUFallbackLUT = {
    lut: number[];
};

// @public (undocumented)
type CPUFallbackRenderingTools = {
    renderCanvas?: HTMLCanvasElement;
    lastRenderedIsColor?: boolean;
    lastRenderedImageId?: string;
    lastRenderedViewport?: {
        windowWidth: number | number[];
        windowCenter: number | number[];
        invert: boolean;
        rotation: number;
        hflip: boolean;
        vflip: boolean;
        modalityLUT: CPUFallbackLUT;
        voiLUT: CPUFallbackLUT;
        colormap: unknown;
    };
    renderCanvasContext?: CanvasRenderingContext2D;
    colormapId?: string;
    colorLUT?: CPUFallbackLookupTable;
    renderCanvasData?: ImageData;
};

// @public (undocumented)
interface CPUFallbackTransform {
    // (undocumented)
    clone: () => CPUFallbackTransform;
    // (undocumented)
    getMatrix: () => TransformMatrix2D;
    // (undocumented)
    invert: () => void;
    // (undocumented)
    multiply: (matrix: TransformMatrix2D) => void;
    // (undocumented)
    reset: () => void;
    // (undocumented)
    rotate: (rad: number) => void;
    // (undocumented)
    scale: (sx: number, sy: number) => void;
    // (undocumented)
    transformPoint: (point: Point2) => Point2;
    // (undocumented)
    translate: (x: number, y: number) => void;
}

// @public (undocumented)
type CPUFallbackViewport = {
    scale?: number;
    parallelScale?: number;
    focalPoint?: number[];
    translation?: {
        x: number;
        y: number;
    };
    voi?: {
        windowWidth: number;
        windowCenter: number;
    };
    invert?: boolean;
    pixelReplication?: boolean;
    rotation?: number;
    hflip?: boolean;
    vflip?: boolean;
    modalityLUT?: CPUFallbackLUT;
    voiLUT?: CPUFallbackLUT;
    colormap?: CPUFallbackColormap;
    displayedArea?: CPUFallbackViewportDisplayedArea;
    modality?: string;
};

// @public (undocumented)
type CPUFallbackViewportDisplayedArea = {
    tlhc: {
        x: number;
        y: number;
    };
    brhc: {
        x: number;
        y: number;
    };
    rowPixelSpacing: number;
    columnPixelSpacing: number;
    presentationSizeMode: string;
};

// @public (undocumented)
type CPUIImageData = {
    dimensions: Point3;
    direction: Mat3;
    spacing: Point3;
    origin: Point3;
    imageData: CPUImageData;
    metadata: { Modality: string };
    scalarData: PixelDataTypedArray;
    scaling: Scaling;
    hasPixelSpacing?: boolean;
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
};

// @public (undocumented)
type CPUImageData = {
    worldToIndex?: (point: Point3) => Point3;
    indexToWorld?: (point: Point3) => Point3;
    getWorldToIndex?: () => Point3;
    getIndexToWorld?: () => Point3;
    getSpacing?: () => Point3;
    getDirection?: () => Mat3;
    getScalarData?: () => PixelDataTypedArray;
    getDimensions?: () => Point3;
};

// @public (undocumented)
interface CustomEvent_2<T = any> extends Event {
    readonly detail: T;
    // (undocumented)
    initCustomEvent(
    typeArg: string,
    canBubbleArg: boolean,
    cancelableArg: boolean,
    detailArg: T
    ): void;
}

// @public (undocumented)
type DisplayArea = {
    imageArea: [number, number]; // areaX, areaY
    imageCanvasPoint: {
        imagePoint: [number, number]; // imageX, imageY
        canvasPoint: [number, number]; // canvasX, canvasY
    };
    storeAsInitialCamera: boolean;
};

// @public
type DisplayAreaModifiedEvent = CustomEvent_2<DisplayAreaModifiedEventDetail>;

// @public
type DisplayAreaModifiedEventDetail = {
    viewportId: string;
    displayArea: DisplayArea;
    volumeId?: string;
    storeAsInitialCamera?: boolean;
};

// @public
enum DynamicOperatorType {
    AVERAGE = 'AVERAGE',
    SUBTRACT = 'SUBTRACT',
    SUM = 'SUM',
}

// @public
type ElementDisabledEvent = CustomEvent_2<ElementDisabledEventDetail>;

// @public
type ElementDisabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public
type ElementEnabledEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public
type ElementEnabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public
enum Events {
    CACHE_SIZE_EXCEEDED = 'CACHE_SIZE_EXCEEDED',
    CAMERA_MODIFIED = 'CORNERSTONE_CAMERA_MODIFIED',

    CAMERA_RESET = 'CORNERSTONE_CAMERA_RESET',
    DISPLAY_AREA_MODIFIED = 'CORNERSTONE_DISPLAY_AREA_MODIFIED',
    ELEMENT_DISABLED = 'CORNERSTONE_ELEMENT_DISABLED',
    ELEMENT_ENABLED = 'CORNERSTONE_ELEMENT_ENABLED',
    GEOMETRY_CACHE_GEOMETRY_ADDED = 'CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED',
    IMAGE_CACHE_IMAGE_ADDED = 'CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED',
    IMAGE_CACHE_IMAGE_REMOVED = 'CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED',
    IMAGE_LOAD_ERROR = 'IMAGE_LOAD_ERROR',
    IMAGE_LOAD_FAILED = 'CORNERSTONE_IMAGE_LOAD_FAILED',
    IMAGE_LOAD_PROGRESS = 'CORNERSTONE_IMAGE_LOAD_PROGRESS',
    IMAGE_LOADED = 'CORNERSTONE_IMAGE_LOADED',

    IMAGE_RENDERED = 'CORNERSTONE_IMAGE_RENDERED',
    IMAGE_SPACING_CALIBRATED = 'CORNERSTONE_IMAGE_SPACING_CALIBRATED',
    IMAGE_VOLUME_MODIFIED = 'CORNERSTONE_IMAGE_VOLUME_MODIFIED',
    PRE_STACK_NEW_IMAGE = 'CORNERSTONE_PRE_STACK_NEW_IMAGE',
    STACK_NEW_IMAGE = 'CORNERSTONE_STACK_NEW_IMAGE',
    STACK_VIEWPORT_NEW_STACK = 'CORNERSTONE_STACK_VIEWPORT_NEW_STACK',
    STACK_VIEWPORT_SCROLL = 'CORNERSTONE_STACK_VIEWPORT_SCROLL',

    VOI_MODIFIED = 'CORNERSTONE_VOI_MODIFIED',

    VOLUME_CACHE_VOLUME_ADDED = 'CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED',
    VOLUME_CACHE_VOLUME_REMOVED = 'CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED',
    VOLUME_LOADED = 'CORNERSTONE_VOLUME_LOADED',

    VOLUME_LOADED_FAILED = 'CORNERSTONE_VOLUME_LOADED_FAILED',

    VOLUME_NEW_IMAGE = 'CORNERSTONE_VOLUME_NEW_IMAGE',

    VOLUME_SCROLL_OUT_OF_BOUNDS = 'CORNERSTONE_VOLUME_SCROLL_OUT_OF_BOUNDS',

    VOLUME_VIEWPORT_NEW_VOLUME = 'CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME',
    // IMAGE_CACHE_FULL = 'CORNERSTONE_IMAGE_CACHE_FULL',
    // PRE_RENDER = 'CORNERSTONE_PRE_RENDER',
    // ELEMENT_RESIZED = 'CORNERSTONE_ELEMENT_RESIZED',
}

declare namespace EventTypes {
    export {
        CameraModifiedEventDetail,
        CameraModifiedEvent,
        VoiModifiedEvent,
        VoiModifiedEventDetail,
        DisplayAreaModifiedEvent,
        DisplayAreaModifiedEventDetail,
        ElementDisabledEvent,
        ElementDisabledEventDetail,
        ElementEnabledEvent,
        ElementEnabledEventDetail,
        ImageRenderedEventDetail,
        ImageRenderedEvent,
        ImageVolumeModifiedEvent,
        ImageVolumeModifiedEventDetail,
        ImageLoadedEvent,
        ImageLoadedEventDetail,
        ImageLoadedFailedEventDetail,
        ImageLoadedFailedEvent,
        VolumeLoadedEvent,
        VolumeLoadedEventDetail,
        VolumeLoadedFailedEvent,
        VolumeLoadedFailedEventDetail,
        ImageCacheImageAddedEvent,
        ImageCacheImageAddedEventDetail,
        ImageCacheImageRemovedEvent,
        ImageCacheImageRemovedEventDetail,
        VolumeCacheVolumeAddedEvent,
        VolumeCacheVolumeAddedEventDetail,
        VolumeCacheVolumeRemovedEvent,
        VolumeCacheVolumeRemovedEventDetail,
        StackNewImageEvent,
        StackNewImageEventDetail,
        PreStackNewImageEvent,
        PreStackNewImageEventDetail,
        ImageSpacingCalibratedEvent,
        ImageSpacingCalibratedEventDetail,
        ImageLoadProgressEvent,
        ImageLoadProgressEventDetail,
        VolumeNewImageEvent,
        VolumeNewImageEventDetail,
        StackViewportNewStackEvent,
        StackViewportNewStackEventDetail,
        StackViewportScrollEvent,
        StackViewportScrollEventDetail
    }
}

// @public
type FlipDirection = {
    flipHorizontal?: boolean;
    flipVertical?: boolean;
};

// @public (undocumented)
enum GeometryType {
    // (undocumented)
    CONTOUR = 'contour',
}

// @public (undocumented)
export const helpers: {
    getDynamicVolumeInfo: typeof getDynamicVolumeInfo;
};

// @public (undocumented)
interface ICache {
    getCacheSize: () => number;
    getImageLoadObject: (imageId: string) => IImageLoadObject | void;
    getMaxCacheSize: () => number;
    getVolumeLoadObject: (volumeId: string) => IVolumeLoadObject | void;
    purgeCache: () => void;
    putImageLoadObject: (
    imageId: string,
    imageLoadObject: IImageLoadObject
    ) => Promise<any>;
    putVolumeLoadObject: (
    volumeId: string,
    volumeLoadObject: IVolumeLoadObject
    ) => Promise<any>;
    setMaxCacheSize: (maxCacheSize: number) => void;
}

// @public (undocumented)
interface ICachedGeometry {
    // (undocumented)
    geometry?: IGeometry;
    // (undocumented)
    geometryId: string;
    // (undocumented)
    geometryLoadObject: IGeometryLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedImage {
    // (undocumented)
    image?: IImage;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageLoadObject: IImageLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedVolume {
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
    // (undocumented)
    volume?: IImageVolume;
    // (undocumented)
    volumeId: string;
    // (undocumented)
    volumeLoadObject: IVolumeLoadObject;
}

// @public
interface ICamera {
    clippingRange?: Point2;
    flipHorizontal?: boolean;
    flipVertical?: boolean;
    focalPoint?: Point3;
    parallelProjection?: boolean;
    parallelScale?: number;
    position?: Point3;
    scale?: number;
    viewAngle?: number;
    viewPlaneNormal?: Point3;
    viewUp?: Point3;
}

// @public (undocumented)
interface IContour {
    // (undocumented)
    color: any;
    // (undocumented)
    getColor(): Point3;
    // (undocumented)
    getFlatPointsArray(): number[];
    getPoints(): Point3[];
    // (undocumented)
    _getSizeInBytes(): number;
    // (undocumented)
    getType(): ContourType;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    points: Point3[];
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public
interface IContourSet {
    // (undocumented)
    contours: IContour[];
    // (undocumented)
    _createEachContour(data: ContourData[]): void;
    // (undocumented)
    readonly frameOfReferenceUID: string;
    // (undocumented)
    getCentroid(): Point3;
    // (undocumented)
    getColor(): any;
    getContours(): IContour[];
    getFlatPointsArray(): Point3[];
    getNumberOfContours(): number;
    getNumberOfPointsArray(): number[];
    getNumberOfPointsInAContour(contourIndex: number): number;
    getPointsInContour(contourIndex: number): Point3[];
    // (undocumented)
    getSegmentIndex(): number;
    // (undocumented)
    getSizeInBytes(): number;
    getTotalNumberOfPoints(): number;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public
interface IDynamicImageVolume extends IImageVolume {
    getScalarDataArrays(): VolumeScalarData[];
    get numTimePoints(): number;
    get timePointIndex(): number;
    set timePointIndex(newTimePointIndex: number);
}

// @public
interface IEnabledElement {
    FrameOfReferenceUID: string;
    renderingEngine: IRenderingEngine;
    renderingEngineId: string;
    viewport: IStackViewport | IVolumeViewport;
    viewportId: string;
}

// @public (undocumented)
interface IGeometry {
    // (undocumented)
    data: IContourSet;
    // (undocumented)
    id: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    type: GeometryType;
}

// @public (undocumented)
interface IGeometryLoadObject {
    cancelFn?: () => void;
    decache?: () => void;
    promise: Promise<IGeometry>;
}

// @public
interface IImage {
    cachedLut?: {
        windowWidth?: number | number[];
        windowCenter?: number | number[];
        invert?: boolean;
        lutArray?: Uint8ClampedArray;
        modalityLUT?: unknown;
        voiLUT?: CPUFallbackLUT;
    };
    color: boolean;
    colormap?: CPUFallbackColormap;
    columnPixelSpacing: number;
    columns: number;
    // (undocumented)
    getCanvas: () => HTMLCanvasElement;
    getPixelData: () => PixelDataTypedArray;
    height: number;
    imageId: string;
    intercept: number;
    invert: boolean;
    isPreScaled?: boolean;
    // (undocumented)
    maxPixelValue: number;
    minPixelValue: number;
    modalityLUT?: CPUFallbackLUT;
    numComps: number;
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    render?: (
    enabledElement: CPUFallbackEnabledElement,
    invalidated: boolean
    ) => unknown;
    rgba: boolean;
    rowPixelSpacing: number;
    rows: number;
    scaling?: {
        PET?: {
            // @TODO: Do these values exist?
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            // accessed in ProbeTool
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sharedCacheKey?: string;
    sizeInBytes: number;
    sliceThickness?: number;
    slope: number;
    stats?: {
        lastStoredPixelDataToCanvasImageDataTime?: number;
        lastGetPixelDataTime?: number;
        lastPutImageDataTime?: number;
        lastLutGenerateTime?: number;
        lastRenderedViewport?: unknown;
        lastRenderTime?: number;
    };
    voiLUT?: CPUFallbackLUT;
    voiLUTFunction: string;
    width: number;
    windowCenter: number[] | number;
    windowWidth: number[] | number;
}

// @public
interface IImageData {
    dimensions: Point3;
    direction: Mat3;
    hasPixelSpacing?: boolean;
    imageData: vtkImageData;
    metadata: { Modality: string };
    origin: Point3;
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    scalarData: Float32Array | Uint16Array | Uint8Array | Int16Array;
    scaling?: Scaling;
    spacing: Point3;
}

// @public
interface IImageLoadObject {
    cancelFn?: () => void;
    decache?: () => void;
    promise: Promise<IImage>;
}

// @public
interface IImageVolume {
    // (undocumented)
    cancelLoading?: () => void;
    convertToCornerstoneImage?: (
    imageId: string,
    imageIdIndex: number
    ) => IImageLoadObject;
    destroy(): void;
    dimensions: Point3;
    direction: Mat3;
    getImageIdIndex(imageId: string): number;
    getImageURIIndex(imageURI: string): number;
    getScalarData(): VolumeScalarData;
    hasPixelSpacing: boolean;
    imageData?: vtkImageData;
    imageIds: Array<string>;
    isDynamicVolume(): boolean;
    isPrescaled: boolean;
    loadStatus?: Record<string, any>;
    metadata: Metadata;
    numVoxels: number;
    origin: Point3;
    referencedVolumeId?: string;
    scaling?: {
        PET?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    sizeInBytes?: number;
    spacing: Point3;
    readonly volumeId: string;
    vtkOpenGLTexture: any;
}

// @public
type ImageCacheImageAddedEvent =
CustomEvent_2<ImageCacheImageAddedEventDetail>;

// @public
type ImageCacheImageAddedEventDetail = {
    image: ICachedImage;
};

// @public
type ImageCacheImageRemovedEvent =
CustomEvent_2<ImageCacheImageRemovedEventDetail>;

// @public
type ImageCacheImageRemovedEventDetail = {
    imageId: string;
};

// @public
type ImageLoadedEvent = CustomEvent_2<ImageLoadedEventDetail>;

// @public
type ImageLoadedEventDetail = {
    image: IImage;
};

// @public
type ImageLoadedFailedEvent = CustomEvent_2<ImageLoadedFailedEventDetail>;

// @public
type ImageLoadedFailedEventDetail = {
    imageId: string;
    error: unknown;
};

// @public
type ImageLoaderFn = (
imageId: string,
options?: Record<string, any>
) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public
type ImageLoadProgressEvent = CustomEvent_2<ImageLoadProgressEventDetail>;

// @public
type ImageLoadProgressEventDetail = {
    url: string;
    imageId: string;
    loaded: number;
    total: number;
    percent: number;
};

// @public (undocumented)
interface ImagePixelModule {
    // (undocumented)
    bitsAllocated: number;
    // (undocumented)
    bitsStored: number;
    // (undocumented)
    highBit: number;
    // (undocumented)
    modality: string;
    // (undocumented)
    photometricInterpretation: string;
    // (undocumented)
    pixelRepresentation: string;
    // (undocumented)
    samplesPerPixel: number;
    // (undocumented)
    voiLUTFunction: VOILUTFunctionType;
    // (undocumented)
    windowCenter: number | number[];
    // (undocumented)
    windowWidth: number | number[];
}

// @public (undocumented)
interface ImagePlaneModule {
    // (undocumented)
    columnCosines?: Point3;
    // (undocumented)
    columnPixelSpacing?: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    frameOfReferenceUID: string;
    // (undocumented)
    imageOrientationPatient?: Float32Array;
    // (undocumented)
    imagePositionPatient?: Point3;
    // (undocumented)
    pixelSpacing?: Point2;
    // (undocumented)
    rowCosines?: Point3;
    // (undocumented)
    rowPixelSpacing?: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    sliceLocation?: number;
    // (undocumented)
    sliceThickness?: number;
}

// @public
type ImageRenderedEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public
type ImageRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    suppressEvents?: boolean;
};

// @public (undocumented)
type ImageSliceData = {
    numberOfSlices: number;
    imageIndex: number;
};

// @public
type ImageSpacingCalibratedEvent =
CustomEvent_2<ImageSpacingCalibratedEventDetail>;

// @public
type ImageSpacingCalibratedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    imageId: string;
    rowScale: number;
    columnScale: number;
    imageData: vtkImageData;
    worldToIndex: mat4;
};

// @public
type ImageVolumeModifiedEvent = CustomEvent_2<ImageVolumeModifiedEventDetail>;

// @public
type ImageVolumeModifiedEventDetail = {
    imageVolume: IImageVolume;
    FrameOfReferenceUID: string;
};

// @public
enum InterpolationType {
    // (undocumented)
    FAST_LINEAR,
    LINEAR,
    NEAREST,
}

// @public
interface IRegisterImageLoader {
    // (undocumented)
    registerImageLoader: (scheme: string, imageLoader: ImageLoaderFn) => void;
}

// @public (undocumented)
interface IRenderingEngine {
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(
    canvas: HTMLCanvasElement,
    backgroundColor: [number, number, number]
    ): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getViewport(id: string): IStackViewport | IVolumeViewport;
    // (undocumented)
    getViewports(): Array<IStackViewport | IVolumeViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference(FrameOfReferenceUID: string): void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, resetPan?: boolean, resetZoom?: boolean): void;
    // (undocumented)
    setViewports(viewports: Array<PublicViewportInput>): void;
}

// @public
interface IStackViewport extends IViewport {
    calibrateSpacing(imageId: string): void;
    canvasToWorld: (canvasPos: Point2) => Point3;
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
    };
    getCamera(): ICamera;
    getCornerstoneImage: () => IImage;
    getCurrentImageId: () => string;
    getCurrentImageIdIndex: () => number;
    getFrameOfReferenceUID: () => string;
    getImageData(): IImageData | CPUIImageData;
    getImageIds: () => string[];
    getProperties: () => StackViewportProperties;
    getRenderer(): any;
    hasImageId: (imageId: string) => boolean;
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    modality: string;
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    resetProperties(): void;
    resize: () => void;
    scaling: Scaling;
    setCamera(cameraInterface: ICamera): void;
    setColormap(colormap: CPUFallbackColormapData | ColormapRegistration): void;
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    setProperties(
        { voiRange, invert, interpolationType, rotation }: StackViewportProperties,
    suppressEvents?: boolean
    ): void;
    setStack(
    imageIds: Array<string>,
    currentImageIdIndex?: number
    ): Promise<string>;
    unsetColormap(): void;
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public
interface IStreamingImageVolume extends ImageVolume {
    clearLoadCallbacks(): void;
    convertToCornerstoneImage(imageId: string, imageIdIndex: number): any;
    decache(completelyRemove: boolean): void;
}

// @public (undocumented)
interface IStreamingVolumeProperties {
    imageIds: Array<string>;

    loadStatus: {
        loaded: boolean;
        loading: boolean;
        cancelled: boolean;
        cachedFrames: Array<boolean>;
        callbacks: Array<() => void>;
    };
}

// @public
interface IViewport {
    _actors: Map<string, any>;
    addActor(actorEntry: ActorEntry): void;
    addActors(actors: Array<ActorEntry>): void;
    canvas: HTMLCanvasElement;
    canvasToWorld: (canvasPos: Point2) => Point3;
    customRenderViewportToCanvas: () => unknown;
    defaultOptions: any;
    element: HTMLDivElement;
    getActor(actorUID: string): ActorEntry;
    getActorByIndex(index: number): ActorEntry;
    getActors(): Array<ActorEntry>;
    getActorUIDByIndex(index: number): string;
    getCamera(): ICamera;
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    getDefaultActor(): ActorEntry;
    getDisplayArea(): DisplayArea | undefined;
    getFrameOfReferenceUID: () => string;
    getPan(): Point2;
    getRenderer(): void;
    getRenderingEngine(): any;
    getRotation: () => number;
    getZoom(): number;
    id: string;
    isDisabled: boolean;
    options: ViewportInputOptions;
    removeActors(actorUIDs: Array<string>): void;
    removeAllActors(): void;
    render(): void;
    renderingEngineId: string;
    reset(immediate: boolean): void;
    setActors(actors: Array<ActorEntry>): void;
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    setDisplayArea(
    displayArea: DisplayArea,
    callResetCamera?: boolean,
    suppressEvents?: boolean
    );
    setOptions(options: ViewportInputOptions, immediate: boolean): void;
    setPan(pan: Point2, storeAsInitialCamera?: boolean);
    setZoom(zoom: number, storeAsInitialCamera?: boolean);
    sHeight: number;
    suppressEvents: boolean;
    sWidth: number;
    sx: number;
    sy: number;
    type: ViewportType;
    // (undocumented)
    updateRenderingPipeline: () => void;
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public
interface IViewportId {
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public
interface IVolume {
    dimensions: Point3;
    direction: Mat3;
    imageData?: vtkImageData;
    metadata: Metadata;
    origin: Point3;
    referencedVolumeId?: string;
    scalarData: VolumeScalarData | Array<VolumeScalarData>;
    scaling?: {
        PET?: {
            // @TODO: Do these values exist?
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            // accessed in ProbeTool
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    sizeInBytes?: number;
    spacing: Point3;
    volumeId: string;
}

// @public
interface IVolumeInput {
    // (undocumented)
    actorUID?: string;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    blendMode?: BlendModes;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    callback?: VolumeInputCallback;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    slabThickness?: number;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    visibility?: boolean;
    // actorUID for segmentations, since two segmentations with the same volumeId
    // can have different representations
    volumeId: string;
}

// @public
interface IVolumeLoadObject {
    cancelFn?: () => void;
    decache?: () => void;
    promise: Promise<ImageVolume>;
}

// @public
interface IVolumeViewport extends IViewport {
    addVolumes(
    volumeInputArray: Array<IVolumeInput>,
    immediate?: boolean,
    suppressEvents?: boolean
    ): Promise<void>;
    canvasToWorld: (canvasPos: Point2) => Point3;
    flip(flipDirection: FlipDirection): void;
    getBounds(): any;
    getCurrentImageId: () => string;
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    getImageData(volumeId?: string): IImageData | undefined;
    getIntensityFromWorld(point: Point3): number;
    getProperties: () => VolumeViewportProperties;
    getSlabThickness(): number;
    hasImageURI: (imageURI: string) => boolean;
    hasVolumeId: (volumeId: string) => boolean;
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    resetCamera(
    resetPan?: boolean,
    resetZoom?: boolean,
    resetToCenter?: boolean
    ): boolean;
    setBlendMode(
    blendMode: BlendModes,
    filterActorUIDs?: Array<string>,
    immediate?: boolean
    ): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis): void;
    setProperties(
        { voiRange }: VolumeViewportProperties,
    volumeId?: string,
    suppressEvents?: boolean
    ): void;
    setSlabThickness(
    slabThickness: number,
    filterActorUIDs?: Array<string>
    ): void;
    setVolumes(
    volumeInputArray: Array<IVolumeInput>,
    immediate?: boolean,
    suppressEvents?: boolean
    ): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public
type Mat3 = [
number,
number,
number,
number,
number,
number,
number,
number,
number
];

// @public
type Metadata = {
    BitsAllocated: number;
    BitsStored: number;
    SamplesPerPixel: number;
    HighBit: number;
    PhotometricInterpretation: string;
    PixelRepresentation: number;
    Modality: string;
    SeriesInstanceUID?: string;
    ImageOrientationPatient: Array<number>;
    PixelSpacing: Array<number>;
    FrameOfReferenceUID: string;
    Columns: number;
    Rows: number;
    voiLut: Array<VOI>;
    VOILUTFunction: string;
};

// @public (undocumented)
enum OrientationAxis {
    // (undocumented)
    ACQUISITION = 'acquisition',
    // (undocumented)
    AXIAL = 'axial',
    // (undocumented)
    CORONAL = 'coronal',
    // (undocumented)
    SAGITTAL = 'sagittal',
}

// @public
type OrientationVectors = {
    viewPlaneNormal: Point3;
    viewUp: Point3;
};

// @public (undocumented)
type PixelDataTypedArray =
| Float32Array
| Int16Array
| Uint16Array
| Uint8Array
| Int8Array
| Uint8ClampedArray;

// @public
type Plane = [number, number, number, number];

// @public
type Point2 = [number, number];

// @public
type Point3 = [number, number, number];

// @public
type Point4 = [number, number, number, number];

// @public
type PreStackNewImageEvent = CustomEvent_2<PreStackNewImageEventDetail>;

// @public
type PreStackNewImageEventDetail = {
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type PTScaling = {
    suvbwToSuvlbm?: number;
    suvbwToSuvbsa?: number;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
type PublicContourSetData = ContourSetData;

// @public
type PublicViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions?: ViewportInputOptions;
};

// @public
enum RequestType {
    Interaction = 'interaction',
    Prefetch = 'prefetch',
    Thumbnail = 'thumbnail',
}

// @public
type RGB = [number, number, number];

// @public (undocumented)
type Scaling = {
    PET?: PTScaling;
};

// @public (undocumented)
type ScalingParameters = {
    rescaleSlope: number;
    rescaleIntercept: number;
    modality: string;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public
enum SharedArrayBufferModes {
    AUTO = 'auto',
    // (undocumented)
    FALSE = 'false',
    // (undocumented)
    TRUE = 'true',
}

// @public
type StackNewImageEvent = CustomEvent_2<StackNewImageEventDetail>;

// @public
type StackNewImageEventDetail = {
    image: IImage;
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public
type StackViewportNewStackEvent =
CustomEvent_2<StackViewportNewStackEventDetail>;

// @public
type StackViewportNewStackEventDetail = {
    imageIds: string[];
    viewportId: string;
    element: HTMLDivElement;
    currentImageIdIndex: number;
};

// @public
type StackViewportProperties = ViewportProperties & {
    interpolationType?: InterpolationType;
    rotation?: number;
    suppressEvents?: boolean;
    isComputedVOI?: boolean;
};

// @public (undocumented)
type StackViewportScrollEvent = CustomEvent_2<StackViewportScrollEventDetail>;

// @public
type StackViewportScrollEventDetail = {
    newImageIdIndex: number;
    imageId: string;
    direction: number;
};

// @public (undocumented)
export class StreamingDynamicImageVolume extends BaseStreamingImageVolume implements Types.IDynamicImageVolume {
    constructor(imageVolumeProperties: Types.IVolume, streamingProperties: Types.IStreamingVolumeProperties);
    // (undocumented)
    getImageLoadRequests: (priority: number) => any[];
    // (undocumented)
    getScalarData(): Types.VolumeScalarData;
    // (undocumented)
    isDynamicVolume(): boolean;
    // (undocumented)
    get numTimePoints(): number;
    // (undocumented)
    get timePointIndex(): number;
    set timePointIndex(newTimePointIndex: number);
}

// @public (undocumented)
export class StreamingImageVolume extends BaseStreamingImageVolume {
    constructor(imageVolumeProperties: Types.IVolume, streamingProperties: Types.IStreamingVolumeProperties);
    // (undocumented)
    getImageLoadRequests: (priority: number) => {
        callLoadImage: (imageId: any, imageIdIndex: any, options: any) => Promise<void>;
        imageId: string;
        imageIdIndex: number;
        options: {
            targetBuffer: {
                arrayBuffer: SharedArrayBuffer;
                offset: number;
                length: number;
                type: any;
            };
            skipCreateImage: boolean;
            preScale: {
                enabled: boolean;
                scalingParameters: Types.ScalingParameters;
            };
        };
        priority: number;
        requestType: default_2;
        additionalDetails: {
            volumeId: string;
        };
    }[];
    // (undocumented)
    getScalarData(): Types.VolumeScalarData;
}

// @public
type TransformMatrix2D = [number, number, number, number, number, number];

// @public
type ViewportInputOptions = {
    background?: RGB;
    orientation?: OrientationAxis | OrientationVectors;
    displayArea?: DisplayArea;
    suppressEvents?: boolean;
    parallelProjection?: boolean;
};

// @public (undocumented)
interface ViewportPreset {
    // (undocumented)
    ambient: string;
    // (undocumented)
    colorTransfer: string;
    // (undocumented)
    diffuse: string;
    // (undocumented)
    gradientOpacity: string;
    // (undocumented)
    interpolation: string;
    // (undocumented)
    name: string;
    // (undocumented)
    scalarOpacity: string;
    // (undocumented)
    shade: string;
    // (undocumented)
    specular: string;
    // (undocumented)
    specularPower: string;
}

// @public
type ViewportProperties = {
    voiRange?: VOIRange;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
};

// @public
enum ViewportType {
    ORTHOGRAPHIC = 'orthographic',
    PERSPECTIVE = 'perspective',
    STACK = 'stack',
    // (undocumented)
    VOLUME_3D = 'volume3d',
}

// @public (undocumented)
type VOI = {
    windowWidth: number;
    windowCenter: number;
};

// @public
enum VOILUTFunctionType {
    // (undocumented)
    LINEAR = 'LINEAR',
    // (undocumented)
    SAMPLED_SIGMOID = 'SIGMOID', // SIGMOID is sampled in 1024 even steps so we call it SAMPLED_SIGMOID
    // EXACT_LINEAR = 'EXACT_LINEAR', TODO: Add EXACT_LINEAR option from DICOM NEMA
}

// @public
type VoiModifiedEvent = CustomEvent_2<VoiModifiedEventDetail>;

// @public
type VoiModifiedEventDetail = {
    viewportId: string;
    range: VOIRange;
    volumeId?: string;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
};

// @public (undocumented)
type VOIRange = {
    upper: number;
    lower: number;
};

// @public (undocumented)
type VolumeActor = vtkVolume;

// @public
type VolumeCacheVolumeAddedEvent =
CustomEvent_2<VolumeCacheVolumeAddedEventDetail>;

// @public
type VolumeCacheVolumeAddedEventDetail = {
    volume: ICachedVolume;
};

// @public
type VolumeCacheVolumeRemovedEvent =
CustomEvent_2<VolumeCacheVolumeRemovedEventDetail>;

// @public
type VolumeCacheVolumeRemovedEventDetail = {
    volumeId: string;
};

// @public
type VolumeInputCallback = (params: {
    volumeActor: VolumeActor;
    volumeId: string;
}) => unknown;

// @public
type VolumeLoadedEvent = CustomEvent_2<VolumeLoadedEventDetail>;

// @public
type VolumeLoadedEventDetail = {
    volume: IImageVolume;
};

// @public
type VolumeLoadedFailedEvent = CustomEvent_2<VolumeLoadedFailedEventDetail>;

// @public
type VolumeLoadedFailedEventDetail = {
    volumeId: string;
    error: unknown;
};

// @public
type VolumeLoaderFn = (
volumeId: string,
options?: Record<string, any>
) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public
type VolumeNewImageEvent = CustomEvent_2<VolumeNewImageEventDetail>;

// @public
type VolumeNewImageEventDetail = {
    imageIndex: number;
    numberOfSlices: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type VolumeScalarData = Float32Array | Uint8Array | Uint16Array | Int16Array;

// @public
type VolumeViewportProperties = ViewportProperties & {
    colormap?: ColormapPublic;
    preset?: string;
};

// (No @packageDocumentation comment for this package)

```

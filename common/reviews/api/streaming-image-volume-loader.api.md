## API Report File for "@cornerstonejs/streaming-image-volume-loader"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { GetGPUTier } from 'detect-gpu';
import type { mat4 } from 'gl-matrix';
import type { TierResult } from 'detect-gpu';
import type vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';
import type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';
import vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import type vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';

// @public (undocumented)
type Actor = vtkActor;

// @public (undocumented)
type ActorEntry = {
    uid: string;
    actor: Actor | VolumeActor | ImageActor;
    referenceId?: string;
    slabThickness?: number;
    clippingFilter?: any;
};

// @public (undocumented)
type ActorSliceRange = {
    actor: VolumeActor;
    viewPlaneNormal: Point3;
    focalPoint: Point3;
    min: number;
    max: number;
    current: number;
};

// @public (undocumented)
type AffineMatrix = [
[
number,
number,
number,
number
],
[
number,
number,
number,
number
],
[
number,
number,
number,
number
],
[
number,
number,
number,
number
]
];

// @public (undocumented)
enum BlendModes {
    // (undocumented)
    AVERAGE_INTENSITY_BLEND = 3,
    // (undocumented)
    COMPOSITE = 0,
    // (undocumented)
    MAXIMUM_INTENSITY_BLEND = 1,
    // (undocumented)
    MINIMUM_INTENSITY_BLEND = 2
}

// @public (undocumented)
enum CalibrationTypes {
    // (undocumented)
    ERMF = "ERMF",
    // (undocumented)
    ERROR = "Error",
    // (undocumented)
    NOT_APPLICABLE = "",
    // (undocumented)
    PROJECTION = "Proj",
    // (undocumented)
    REGION = "Region",
    // (undocumented)
    UNCALIBRATED = "Uncalibrated",
    // (undocumented)
    USER = "User"
}

// @public (undocumented)
type CameraModifiedEvent = CustomEvent_2<CameraModifiedEventDetail>;

// @public (undocumented)
type CameraModifiedEventDetail = {
    previousCamera: ICamera;
    camera: ICamera;
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    rotation?: number;
};

// @public (undocumented)
function cancelLoadAll(): void;

// @public (undocumented)
function cancelLoadImage(imageId: string): void;

// @public (undocumented)
function cancelLoadImages(imageIds: Array<string>): void;

// @public (undocumented)
type ColormapPublic = {
    name?: string;
    opacity?: OpacityMapping[] | number;
};

// @public (undocumented)
type ColormapRegistration = {
    ColorSpace: string;
    Name: string;
    RGBPoints: RGB[];
};

// @public (undocumented)
type ContourData = {
    points: Point3[];
    type: ContourType;
    color: Point3;
    segmentIndex: number;
};

// @public (undocumented)
type ContourSetData = {
    id: string;
    data: ContourData[];
    frameOfReferenceUID: string;
    color?: Point3;
    segmentIndex?: number;
};

// @public (undocumented)
enum ContourType {
    // (undocumented)
    CLOSED_PLANAR = "CLOSED_PLANAR",
    // (undocumented)
    OPEN_PLANAR = "OPEN_PLANAR"
}

// @public (undocumented)
type Cornerstone3DConfig = {
    gpuTier?: TierResult;
    detectGPUConfig: GetGPUTier;
    rendering: {
        preferSizeOverAccuracy: boolean;
        useNorm16Texture: boolean;
        useCPURendering: boolean;
        strictZSpacingForVolumeViewport: boolean;
    };
};

// @public (undocumented)
export function cornerstoneStreamingDynamicImageVolumeLoader(volumeId: string, options: {
    imageIds: string[];
}): IVolumeLoader_2;

// @public (undocumented)
export function cornerstoneStreamingImageVolumeLoader(volumeId: string, options: {
    imageIds: string[];
    progressiveRendering?: boolean | Types.IRetrieveConfiguration;
}): IVolumeLoader;

// @public (undocumented)
interface CPUFallbackColormap {
    // (undocumented)
    addColor: (rgba: Point4) => void;
    // (undocumented)
    buildLookupTable: (lut: CPUFallbackLookupTable) => void;
    // (undocumented)
    clearColors: () => void;
    // (undocumented)
    createLookupTable: () => CPUFallbackLookupTable;
    // (undocumented)
    getColor: (index: number) => Point4;
    // (undocumented)
    getColorRepeating: (index: number) => Point4;
    // (undocumented)
    getColorSchemeName: () => string;
    // (undocumented)
    getId: () => string;
    // (undocumented)
    getNumberOfColors: () => number;
    // (undocumented)
    insertColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    isValidIndex: (index: number) => boolean;
    // (undocumented)
    removeColor: (index: number) => void;
    // (undocumented)
    setColor: (index: number, rgba: Point4) => void;
    // (undocumented)
    setColorSchemeName: (name: string) => void;
    // (undocumented)
    setNumberOfColors: (numColors: number) => void;
}

// @public (undocumented)
type CPUFallbackColormapData = {
    name: string;
    numOfColors?: number;
    colors?: Point4[];
    segmentedData?: unknown;
    numColors?: number;
    gamma?: number;
};

// @public (undocumented)
type CPUFallbackColormapsData = {
    [key: string]: CPUFallbackColormapData;
};

// @public (undocumented)
interface CPUFallbackEnabledElement {
    // (undocumented)
    canvas?: HTMLCanvasElement;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    image?: IImage;
    // (undocumented)
    invalid?: boolean;
    // (undocumented)
    metadata?: {
        direction?: Mat3;
        dimensions?: Point3;
        spacing?: Point3;
        origin?: Point3;
        imagePlaneModule?: ImagePlaneModule;
        imagePixelModule?: ImagePixelModule;
    };
    // (undocumented)
    needsRedraw?: boolean;
    // (undocumented)
    options?: {
        [key: string]: unknown;
        colormap?: CPUFallbackColormap;
    };
    // (undocumented)
    pan?: Point2;
    // (undocumented)
    renderingTools?: CPUFallbackRenderingTools;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    transform?: CPUFallbackTransform;
    // (undocumented)
    viewport?: CPUFallbackViewport;
    // (undocumented)
    zoom?: number;
}

// @public (undocumented)
interface CPUFallbackLookupTable {
    // (undocumented)
    build: (force: boolean) => void;
    // (undocumented)
    getColor: (scalar: number) => Point4;
    // (undocumented)
    setAlphaRange: (start: number, end: number) => void;
    // (undocumented)
    setHueRange: (start: number, end: number) => void;
    // (undocumented)
    setNumberOfTableValues: (number: number) => void;
    // (undocumented)
    setRamp: (ramp: string) => void;
    // (undocumented)
    setRange: (start: number, end: number) => void;
    // (undocumented)
    setSaturationRange: (start: number, end: number) => void;
    // (undocumented)
    setTableRange: (start: number, end: number) => void;
    // (undocumented)
    setTableValue(index: number, rgba: Point4): any;
    // (undocumented)
    setValueRange: (start: number, end: number) => void;
}

// @public (undocumented)
type CPUFallbackLUT = {
    lut: number[];
};

// @public (undocumented)
type CPUFallbackRenderingTools = {
    renderCanvas?: HTMLCanvasElement;
    lastRenderedIsColor?: boolean;
    lastRenderedImageId?: string;
    lastRenderedViewport?: {
        windowWidth: number | number[];
        windowCenter: number | number[];
        invert: boolean;
        rotation: number;
        hflip: boolean;
        vflip: boolean;
        modalityLUT: CPUFallbackLUT;
        voiLUT: CPUFallbackLUT;
        colormap: unknown;
    };
    renderCanvasContext?: CanvasRenderingContext2D;
    colormapId?: string;
    colorLUT?: CPUFallbackLookupTable;
    renderCanvasData?: ImageData;
};

// @public (undocumented)
interface CPUFallbackTransform {
    // (undocumented)
    clone: () => CPUFallbackTransform;
    // (undocumented)
    getMatrix: () => TransformMatrix2D;
    // (undocumented)
    invert: () => void;
    // (undocumented)
    multiply: (matrix: TransformMatrix2D) => void;
    // (undocumented)
    reset: () => void;
    // (undocumented)
    rotate: (rad: number) => void;
    // (undocumented)
    scale: (sx: number, sy: number) => void;
    // (undocumented)
    transformPoint: (point: Point2) => Point2;
    // (undocumented)
    translate: (x: number, y: number) => void;
}

// @public (undocumented)
type CPUFallbackViewport = {
    scale?: number;
    parallelScale?: number;
    focalPoint?: number[];
    translation?: {
        x: number;
        y: number;
    };
    voi?: {
        windowWidth: number;
        windowCenter: number;
    };
    invert?: boolean;
    pixelReplication?: boolean;
    rotation?: number;
    hflip?: boolean;
    vflip?: boolean;
    modalityLUT?: CPUFallbackLUT;
    voiLUT?: CPUFallbackLUT;
    colormap?: CPUFallbackColormap;
    displayedArea?: CPUFallbackViewportDisplayedArea;
    modality?: string;
};

// @public (undocumented)
type CPUFallbackViewportDisplayedArea = {
    tlhc: {
        x: number;
        y: number;
    };
    brhc: {
        x: number;
        y: number;
    };
    rowPixelSpacing: number;
    columnPixelSpacing: number;
    presentationSizeMode: string;
};

// @public (undocumented)
type CPUIImageData = {
    dimensions: Point3;
    direction: Mat3;
    spacing: Point3;
    origin: Point3;
    imageData: CPUImageData;
    metadata: {
        Modality: string;
    };
    scalarData: PixelDataTypedArray;
    scaling: Scaling;
    hasPixelSpacing?: boolean;
    calibration?: IImageCalibration;
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
};

// @public (undocumented)
type CPUImageData = {
    worldToIndex?: (point: Point3) => Point3;
    indexToWorld?: (point: Point3) => Point3;
    getWorldToIndex?: () => Point3;
    getIndexToWorld?: () => Point3;
    getSpacing?: () => Point3;
    getDirection?: () => Mat3;
    getScalarData?: () => PixelDataTypedArray;
    getDimensions?: () => Point3;
};

// @public (undocumented)
function createAndCacheDerivedImage(imageId: string, options: DerivedImageOptions): Promise<IImage>;

// @public (undocumented)
function createAndCacheDerivedImages(imageIds: Array<string>, getDerivedImageId: (imageId: string, index?: number) => string): DerivedImages;

// @public (undocumented)
interface CustomEvent_2<T = any> extends Event {
    // (undocumented)
    readonly detail: T;
    // (undocumented)
    initCustomEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, detailArg: T): void;
}

// @public (undocumented)
type DisplayArea = {
    imageArea: [number, number];
    imageCanvasPoint: {
        imagePoint: [number, number];
        canvasPoint: [number, number];
    };
    storeAsInitialCamera: boolean;
};

// @public (undocumented)
type DisplayAreaModifiedEvent = CustomEvent_2<DisplayAreaModifiedEventDetail>;

// @public (undocumented)
type DisplayAreaModifiedEventDetail = {
    viewportId: string;
    displayArea: DisplayArea;
    volumeId?: string;
    storeAsInitialCamera?: boolean;
};

// @public (undocumented)
enum DynamicOperatorType {
    // (undocumented)
    AVERAGE = "AVERAGE",
    // (undocumented)
    SUBTRACT = "SUBTRACT",
    // (undocumented)
    SUM = "SUM"
}

// @public (undocumented)
type ElementDisabledEvent = CustomEvent_2<ElementDisabledEventDetail>;

// @public (undocumented)
type ElementDisabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type ElementEnabledEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public (undocumented)
type ElementEnabledEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
};

declare namespace Enums {
    export {
        Events_2 as Events
    }
}
export { Enums }

// @public (undocumented)
enum Events {
    // (undocumented)
    CACHE_SIZE_EXCEEDED = "CACHE_SIZE_EXCEEDED",
    // (undocumented)
    CAMERA_MODIFIED = "CORNERSTONE_CAMERA_MODIFIED",
    // (undocumented)
    CAMERA_RESET = "CORNERSTONE_CAMERA_RESET",
    // (undocumented)
    CLIPPING_PLANES_UPDATED = "CORNERSTONE_CLIPPING_PLANES_UPDATED",
    // (undocumented)
    DISPLAY_AREA_MODIFIED = "CORNERSTONE_DISPLAY_AREA_MODIFIED",
    // (undocumented)
    ELEMENT_DISABLED = "CORNERSTONE_ELEMENT_DISABLED",
    // (undocumented)
    ELEMENT_ENABLED = "CORNERSTONE_ELEMENT_ENABLED",
    // (undocumented)
    GEOMETRY_CACHE_GEOMETRY_ADDED = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED",
    // (undocumented)
    IMAGE_CACHE_IMAGE_ADDED = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED",
    // (undocumented)
    IMAGE_CACHE_IMAGE_REMOVED = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED",
    // (undocumented)
    IMAGE_LOAD_ERROR = "IMAGE_LOAD_ERROR",
    // (undocumented)
    IMAGE_LOAD_FAILED = "CORNERSTONE_IMAGE_LOAD_FAILED",
    // (undocumented)
    IMAGE_LOADED = "CORNERSTONE_IMAGE_LOADED",
    // (undocumented)
    IMAGE_RENDERED = "CORNERSTONE_IMAGE_RENDERED",
    // (undocumented)
    IMAGE_RETRIEVAL_STAGE = "CORNERSTONE_IMAGE_RETRIEVAL_STAGE",
    // (undocumented)
    IMAGE_SPACING_CALIBRATED = "CORNERSTONE_IMAGE_SPACING_CALIBRATED",
    // (undocumented)
    IMAGE_VOLUME_LOADING_COMPLETED = "CORNERSTONE_IMAGE_VOLUME_LOADING_COMPLETED",
    // (undocumented)
    IMAGE_VOLUME_MODIFIED = "CORNERSTONE_IMAGE_VOLUME_MODIFIED",
    // (undocumented)
    PRE_STACK_NEW_IMAGE = "CORNERSTONE_PRE_STACK_NEW_IMAGE",
    // (undocumented)
    STACK_NEW_IMAGE = "CORNERSTONE_STACK_NEW_IMAGE",
    // (undocumented)
    STACK_VIEWPORT_NEW_STACK = "CORNERSTONE_STACK_VIEWPORT_NEW_STACK",
    // (undocumented)
    STACK_VIEWPORT_SCROLL = "CORNERSTONE_STACK_VIEWPORT_SCROLL",
    // (undocumented)
    VOI_MODIFIED = "CORNERSTONE_VOI_MODIFIED",
    // (undocumented)
    VOLUME_CACHE_VOLUME_ADDED = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED",
    // (undocumented)
    VOLUME_CACHE_VOLUME_REMOVED = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED",
    // (undocumented)
    VOLUME_LOADED = "CORNERSTONE_VOLUME_LOADED",
    // (undocumented)
    VOLUME_LOADED_FAILED = "CORNERSTONE_VOLUME_LOADED_FAILED",
    // (undocumented)
    VOLUME_NEW_IMAGE = "CORNERSTONE_VOLUME_NEW_IMAGE",
    // (undocumented)
    VOLUME_SCROLL_OUT_OF_BOUNDS = "CORNERSTONE_VOLUME_SCROLL_OUT_OF_BOUNDS",
    // (undocumented)
    VOLUME_VIEWPORT_NEW_VOLUME = "CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME"
}

// @public (undocumented)
enum Events_2 {
    // (undocumented)
    DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED = "DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED"
}

declare namespace EventTypes {
    export {
        ImageLoadStageEventDetail,
        CameraModifiedEventDetail,
        CameraModifiedEvent,
        VoiModifiedEvent,
        VoiModifiedEventDetail,
        DisplayAreaModifiedEvent,
        DisplayAreaModifiedEventDetail,
        ElementDisabledEvent,
        ElementDisabledEventDetail,
        ElementEnabledEvent,
        ElementEnabledEventDetail,
        ImageRenderedEventDetail,
        ImageRenderedEvent,
        ImageVolumeModifiedEvent,
        ImageVolumeModifiedEventDetail,
        ImageVolumeLoadingCompletedEvent,
        ImageVolumeLoadingCompletedEventDetail,
        ImageLoadedEvent,
        ImageLoadedEventDetail,
        ImageLoadedFailedEventDetail,
        ImageLoadedFailedEvent,
        VolumeLoadedEvent,
        VolumeLoadedEventDetail,
        VolumeLoadedFailedEvent,
        VolumeLoadedFailedEventDetail,
        ImageCacheImageAddedEvent,
        ImageCacheImageAddedEventDetail,
        ImageCacheImageRemovedEvent,
        ImageCacheImageRemovedEventDetail,
        VolumeCacheVolumeAddedEvent,
        VolumeCacheVolumeAddedEventDetail,
        VolumeCacheVolumeRemovedEvent,
        VolumeCacheVolumeRemovedEventDetail,
        StackNewImageEvent,
        StackNewImageEventDetail,
        PreStackNewImageEvent,
        PreStackNewImageEventDetail,
        ImageSpacingCalibratedEvent,
        ImageSpacingCalibratedEventDetail,
        VolumeNewImageEvent,
        VolumeNewImageEventDetail,
        StackViewportNewStackEvent,
        StackViewportNewStackEventDetail,
        StackViewportScrollEvent,
        StackViewportScrollEventDetail
    }
}

// @public (undocumented)
type FlipDirection = {
    flipHorizontal?: boolean;
    flipVertical?: boolean;
};

// @public (undocumented)
enum GeometryType {
    // (undocumented)
    CONTOUR = "contour",
    // (undocumented)
    SURFACE = "Surface"
}

// @public (undocumented)
export const helpers: {
    getDynamicVolumeInfo: typeof getDynamicVolumeInfo;
};

// @public (undocumented)
interface ICache {
    // (undocumented)
    getCacheSize: () => number;
    // (undocumented)
    getImageLoadObject: (imageId: string) => IImageLoadObject | void;
    // (undocumented)
    getMaxCacheSize: () => number;
    // (undocumented)
    getVolumeLoadObject: (volumeId: string) => IVolumeLoadObject | void;
    // (undocumented)
    purgeCache: () => void;
    // (undocumented)
    putImageLoadObject: (imageId: string, imageLoadObject: IImageLoadObject, updateCache?: boolean) => Promise<any>;
    // (undocumented)
    putVolumeLoadObject: (volumeId: string, volumeLoadObject: IVolumeLoadObject) => Promise<any>;
    // (undocumented)
    setMaxCacheSize: (maxCacheSize: number) => void;
}

// @public (undocumented)
interface ICachedGeometry {
    // (undocumented)
    geometry?: IGeometry;
    // (undocumented)
    geometryId: string;
    // (undocumented)
    geometryLoadObject: IGeometryLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedImage {
    // (undocumented)
    image?: IImage;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageLoadObject: IImageLoadObject;
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
}

// @public (undocumented)
interface ICachedVolume {
    // (undocumented)
    loaded: boolean;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    timeStamp: number;
    // (undocumented)
    volume?: IImageVolume;
    // (undocumented)
    volumeId: string;
    // (undocumented)
    volumeLoadObject: IVolumeLoadObject;
}

// @public (undocumented)
interface ICamera {
    // (undocumented)
    clippingRange?: Point2;
    // (undocumented)
    flipHorizontal?: boolean;
    // (undocumented)
    flipVertical?: boolean;
    // (undocumented)
    focalPoint?: Point3;
    // (undocumented)
    parallelProjection?: boolean;
    // (undocumented)
    parallelScale?: number;
    // (undocumented)
    position?: Point3;
    // (undocumented)
    scale?: number;
    // (undocumented)
    viewAngle?: number;
    // (undocumented)
    viewPlaneNormal?: Point3;
    // (undocumented)
    viewUp?: Point3;
}

// @public (undocumented)
interface IContour {
    // (undocumented)
    color: any;
    // (undocumented)
    getColor(): Point3;
    // (undocumented)
    getFlatPointsArray(): number[];
    // (undocumented)
    getPoints(): Point3[];
    // (undocumented)
    _getSizeInBytes(): number;
    // (undocumented)
    getType(): ContourType;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    points: Point3[];
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public (undocumented)
interface IContourSet {
    // (undocumented)
    contours: IContour[];
    // (undocumented)
    _createEachContour(data: ContourData[]): void;
    // (undocumented)
    readonly frameOfReferenceUID: string;
    // (undocumented)
    getCentroid(): Point3;
    // (undocumented)
    getColor(): any;
    // (undocumented)
    getContours(): IContour[];
    // (undocumented)
    getFlatPointsArray(): Point3[];
    // (undocumented)
    getNumberOfContours(): number;
    // (undocumented)
    getNumberOfPointsArray(): number[];
    // (undocumented)
    getNumberOfPointsInAContour(contourIndex: number): number;
    // (undocumented)
    getPointsInContour(contourIndex: number): Point3[];
    // (undocumented)
    getSegmentIndex(): number;
    // (undocumented)
    getSizeInBytes(): number;
    // (undocumented)
    getTotalNumberOfPoints(): number;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly sizeInBytes: number;
}

// @public (undocumented)
interface IDynamicImageVolume extends IImageVolume {
    // (undocumented)
    getScalarDataArrays(): VolumeScalarData[];
    // (undocumented)
    get numTimePoints(): number;
    // (undocumented)
    get timePointIndex(): number;
    set timePointIndex(newTimePointIndex: number);
}

// @public (undocumented)
interface IEnabledElement {
    // (undocumented)
    FrameOfReferenceUID: string;
    // (undocumented)
    renderingEngine: IRenderingEngine;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewport: IStackViewport | IVolumeViewport;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
interface IGeometry {
    // (undocumented)
    data: IContourSet | Surface;
    // (undocumented)
    id: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    type: GeometryType;
}

// @public (undocumented)
interface IGeometryLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IGeometry>;
}

// @public (undocumented)
interface IImage {
    // (undocumented)
    cachedLut?: {
        windowWidth?: number | number[];
        windowCenter?: number | number[];
        invert?: boolean;
        lutArray?: Uint8ClampedArray;
        modalityLUT?: unknown;
        voiLUT?: CPUFallbackLUT;
    };
    // (undocumented)
    color: boolean;
    // (undocumented)
    colormap?: CPUFallbackColormap;
    // (undocumented)
    columnPixelSpacing: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    decodeTimeInMS?: number;
    // (undocumented)
    getCanvas: () => HTMLCanvasElement;
    // (undocumented)
    getPixelData: () => PixelDataTypedArray;
    // (undocumented)
    height: number;
    // (undocumented)
    imageId: string;
    // (undocumented)
    imageQualityStatus?: ImageQualityStatus;
    // (undocumented)
    intercept: number;
    // (undocumented)
    invert: boolean;
    // (undocumented)
    isPreScaled?: boolean;
    // (undocumented)
    loadTimeInMS?: number;
    // (undocumented)
    maxPixelValue: number;
    // (undocumented)
    minPixelValue: number;
    // (undocumented)
    modalityLUT?: CPUFallbackLUT;
    // (undocumented)
    numComps: number;
    // (undocumented)
    photometricInterpretation?: string;
    // (undocumented)
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    // (undocumented)
    referencedImageId?: string;
    // (undocumented)
    render?: (enabledElement: CPUFallbackEnabledElement, invalidated: boolean) => unknown;
    // (undocumented)
    rgba: boolean;
    // (undocumented)
    rowPixelSpacing: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    scaling?: {
        PT?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sharedCacheKey?: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    sliceThickness?: number;
    // (undocumented)
    slope: number;
    // (undocumented)
    stats?: {
        lastStoredPixelDataToCanvasImageDataTime?: number;
        lastGetPixelDataTime?: number;
        lastPutImageDataTime?: number;
        lastLutGenerateTime?: number;
        lastRenderedViewport?: unknown;
        lastRenderTime?: number;
    };
    // (undocumented)
    voiLUT?: CPUFallbackLUT;
    // (undocumented)
    voiLUTFunction: string;
    // (undocumented)
    width: number;
    // (undocumented)
    windowCenter: number[] | number;
    // (undocumented)
    windowWidth: number[] | number;
}

// @public (undocumented)
interface IImageCalibration {
    // (undocumented)
    aspect?: number;
    // (undocumented)
    columnPixelSpacing?: number;
    // (undocumented)
    rowPixelSpacing?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    sequenceOfUltrasoundRegions?: Record<string, unknown>[];
    // (undocumented)
    tooltip?: string;
    // (undocumented)
    type: CalibrationTypes;
}

// @public (undocumented)
interface IImageData {
    // (undocumented)
    calibration?: IImageCalibration;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    hasPixelSpacing?: boolean;
    // (undocumented)
    imageData: vtkImageData;
    // (undocumented)
    metadata: {
        Modality: string;
    };
    // (undocumented)
    origin: Point3;
    // (undocumented)
    preScale?: {
        scaled?: boolean;
        scalingParameters?: {
            modality?: string;
            rescaleSlope?: number;
            rescaleIntercept?: number;
            suvbw?: number;
        };
    };
    // (undocumented)
    scalarData: Float32Array | Uint16Array | Uint8Array | Int16Array;
    // (undocumented)
    scaling?: Scaling;
    // (undocumented)
    spacing: Point3;
}

// @public (undocumented)
interface IImageLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<IImage>;
}

// @public (undocumented)
interface IImagesLoader {
    // (undocumented)
    loadImages: (imageIds: string[], listener: ImageLoadListener) => Promise<unknown>;
}

// @public (undocumented)
interface IImageVolume {
    // (undocumented)
    cancelLoading?: () => void;
    // (undocumented)
    convertToCornerstoneImage?: (imageId: string, imageIdIndex: number) => IImageLoadObject;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    getImageIdIndex(imageId: string): number;
    // (undocumented)
    getImageURIIndex(imageURI: string): number;
    // (undocumented)
    getScalarData(): VolumeScalarData;
    // (undocumented)
    hasPixelSpacing: boolean;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    imageIds: Array<string>;
    // (undocumented)
    isDynamicVolume(): boolean;
    // (undocumented)
    isPreScaled: boolean;
    // (undocumented)
    loadStatus?: Record<string, any>;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    numVoxels: number;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scaling?: {
        PT?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    readonly volumeId: string;
    // (undocumented)
    vtkOpenGLTexture: any;
}

// @public (undocumented)
type ImageActor = vtkImageSlice;

// @public (undocumented)
type ImageCacheImageAddedEvent = CustomEvent_2<ImageCacheImageAddedEventDetail>;

// @public (undocumented)
type ImageCacheImageAddedEventDetail = {
    image: ICachedImage;
};

// @public (undocumented)
type ImageCacheImageRemovedEvent = CustomEvent_2<ImageCacheImageRemovedEventDetail>;

// @public (undocumented)
type ImageCacheImageRemovedEventDetail = {
    imageId: string;
};

// @public (undocumented)
type ImageLoadedEvent = CustomEvent_2<ImageLoadedEventDetail>;

// @public (undocumented)
type ImageLoadedEventDetail = {
    image: IImage;
};

// @public (undocumented)
type ImageLoadedFailedEvent = CustomEvent_2<ImageLoadedFailedEventDetail>;

// @public (undocumented)
type ImageLoadedFailedEventDetail = {
    imageId: string;
    error: unknown;
};

// @public (undocumented)
type ImageLoaderFn = (imageId: string, options?: Record<string, any>) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
interface ImageLoaderOptions {
    // (undocumented)
    additionalDetails?: Record<string, unknown>;
    // (undocumented)
    priority: number;
    // (undocumented)
    requestType: string;
}

// @public (undocumented)
type ImageLoadListener = {
    successCallback: (imageId: any, image: any) => void;
    errorCallback: (imageId: any, permanent: any, reason: any) => void;
    getLoaderImageOptions?: (imageId: any) => Record<string, unknown>;
};

// @public (undocumented)
type ImageLoadStageEventDetail = {
    stageId: string;
    numberOfImages: number;
    numberOfFailures: number;
    stageDurationInMS: number;
    startDurationInMS: number;
};

// @public (undocumented)
interface ImagePixelModule {
    // (undocumented)
    bitsAllocated: number;
    // (undocumented)
    bitsStored: number;
    // (undocumented)
    highBit: number;
    // (undocumented)
    modality: string;
    // (undocumented)
    photometricInterpretation: string;
    // (undocumented)
    pixelRepresentation: string;
    // (undocumented)
    samplesPerPixel: number;
    // (undocumented)
    voiLUTFunction: VOILUTFunctionType;
    // (undocumented)
    windowCenter: number | number[];
    // (undocumented)
    windowWidth: number | number[];
}

// @public (undocumented)
interface ImagePlaneModule {
    // (undocumented)
    columnCosines?: Point3;
    // (undocumented)
    columnPixelSpacing?: number;
    // (undocumented)
    columns: number;
    // (undocumented)
    frameOfReferenceUID: string;
    // (undocumented)
    imageOrientationPatient?: Float32Array;
    // (undocumented)
    imagePositionPatient?: Point3;
    // (undocumented)
    pixelSpacing?: Point2;
    // (undocumented)
    rowCosines?: Point3;
    // (undocumented)
    rowPixelSpacing?: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    sliceLocation?: number;
    // (undocumented)
    sliceThickness?: number;
}

// @public (undocumented)
enum ImageQualityStatus {
    // (undocumented)
    ADJACENT_REPLICATE = 3,
    // (undocumented)
    FAR_REPLICATE = 1,
    // (undocumented)
    FULL_RESOLUTION = 8,
    // (undocumented)
    LOSSY = 7,
    // (undocumented)
    SUBRESOLUTION = 6
}

// @public (undocumented)
type ImageRenderedEvent = CustomEvent_2<ElementEnabledEventDetail>;

// @public (undocumented)
type ImageRenderedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    suppressEvents?: boolean;
    viewportStatus: ViewportStatus;
};

// @public (undocumented)
type ImageSliceData = {
    numberOfSlices: number;
    imageIndex: number;
};

// @public (undocumented)
type ImageSpacingCalibratedEvent = CustomEvent_2<ImageSpacingCalibratedEventDetail>;

// @public (undocumented)
type ImageSpacingCalibratedEventDetail = {
    element: HTMLDivElement;
    viewportId: string;
    renderingEngineId: string;
    imageId: string;
    calibration: IImageCalibration;
    imageData: vtkImageData;
    worldToIndex: mat4;
};

// @public (undocumented)
type ImageVolumeLoadingCompletedEvent = CustomEvent_2<ImageVolumeLoadingCompletedEventDetail>;

// @public (undocumented)
type ImageVolumeLoadingCompletedEventDetail = {
    volumeId: string;
    FrameOfReferenceUID: string;
};

// @public (undocumented)
type ImageVolumeModifiedEvent = CustomEvent_2<ImageVolumeModifiedEventDetail>;

// @public (undocumented)
type ImageVolumeModifiedEventDetail = {
    imageVolume: IImageVolume;
    FrameOfReferenceUID: string;
};

// @public (undocumented)
type InternalVideoCamera = {
    panWorld?: Point2;
    parallelScale?: number;
};

// @public (undocumented)
enum InterpolationType {
    // (undocumented)
    FAST_LINEAR = 2,
    // (undocumented)
    LINEAR = 1,
    // (undocumented)
    NEAREST = 0
}

// @public (undocumented)
interface IRegisterImageLoader {
    // (undocumented)
    registerImageLoader: (scheme: string, imageLoader: ImageLoaderFn) => void;
}

// @public (undocumented)
interface IRenderingEngine {
    // (undocumented)
    _debugRender(): void;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    disableElement(viewportId: string): void;
    // (undocumented)
    enableElement(viewportInputEntry: PublicViewportInput): void;
    // (undocumented)
    fillCanvasWithBackgroundColor(canvas: HTMLCanvasElement, backgroundColor: [number, number, number]): void;
    // (undocumented)
    getStackViewports(): Array<IStackViewport>;
    // (undocumented)
    getVideoViewports(): Array<IVideoViewport>;
    // (undocumented)
    getViewport(id: string): IViewport;
    // (undocumented)
    getViewports(): Array<IViewport>;
    // (undocumented)
    getVolumeViewports(): Array<IVolumeViewport>;
    // (undocumented)
    hasBeenDestroyed: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    offScreenCanvasContainer: any;
    // (undocumented)
    offscreenMultiRenderWindow: any;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderFrameOfReference(FrameOfReferenceUID: string): void;
    // (undocumented)
    renderViewport(viewportId: string): void;
    // (undocumented)
    renderViewports(viewportIds: Array<string>): void;
    // (undocumented)
    resize(immediate?: boolean, keepCamera?: boolean): void;
    // (undocumented)
    setViewports(viewports: Array<PublicViewportInput>): void;
}

// @public (undocumented)
interface IRetrieveConfiguration {
    // (undocumented)
    create?: (IRetrieveConfiguration: any) => IImagesLoader;
    // (undocumented)
    retrieveOptions?: Record<string, RetrieveOptions>;
    // (undocumented)
    stages?: RetrieveStage[];
}

// @public (undocumented)
interface IStackInput {
    // (undocumented)
    actorUID?: string;
    // (undocumented)
    callback?: StackInputCallback;
    // (undocumented)
    imageId: string;
    // (undocumented)
    visibility?: boolean;
}

// @public (undocumented)
interface IStackViewport extends IViewport {
    // (undocumented)
    addImages(stackInputs: Array<IStackInput>, immediateRender: boolean, suppressEvents: boolean): any;
    // (undocumented)
    calibrateSpacing(imageId: string): void;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    clearDefaultProperties(imageId?: string): void;
    // (undocumented)
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
    };
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCornerstoneImage: () => IImage;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getDefaultProperties: (imageId?: string) => StackViewportProperties;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(): IImageData | CPUIImageData;
    // (undocumented)
    getImageDataMetadata(image: IImage): any;
    // (undocumented)
    getImageIds: () => string[];
    // (undocumented)
    getProperties: () => StackViewportProperties;
    // (undocumented)
    getRenderer(): any;
    // (undocumented)
    hasImageId: (imageId: string) => boolean;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    modality: string;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resetToDefaultProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    scaling: Scaling;
    // (undocumented)
    setCamera(cameraInterface: ICamera): void;
    // (undocumented)
    setDefaultProperties(ViewportProperties: StackViewportProperties, imageId?: string): void;
    // (undocumented)
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    // (undocumented)
    setProperties({ voiRange, invert, interpolationType, rotation, colormap, }: StackViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    setStack(imageIds: Array<string>, currentImageIdIndex?: number): Promise<string>;
    // (undocumented)
    unsetColormap(): void;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
interface IStreamingImageVolume extends ImageVolume {
    // (undocumented)
    clearLoadCallbacks(): void;
    // (undocumented)
    convertToCornerstoneImage(imageId: string, imageIdIndex: number): any;
    // (undocumented)
    decache(completelyRemove: boolean): void;
}

// @public (undocumented)
interface IStreamingVolumeProperties {
    // (undocumented)
    imageIds: Array<string>;
    // (undocumented)
    loadStatus: {
        loaded: boolean;
        loading: boolean;
        cancelled: boolean;
        cachedFrames: Array<ImageQualityStatus>;
        callbacks: Array<() => void>;
    };
}

// @public (undocumented)
interface IVideoViewport extends IViewport {
    // (undocumented)
    getProperties: () => VideoViewportProperties;
    // (undocumented)
    pause: () => void;
    // (undocumented)
    play: () => void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean): boolean;
    // (undocumented)
    resetProperties(): void;
    // (undocumented)
    resize: () => void;
    // (undocumented)
    setProperties(props: VideoViewportProperties, suppressEvents?: boolean): void;
    // (undocumented)
    setVideo: (imageIds: string | string[], imageIdIndex?: number) => Promise<unknown>;
    // (undocumented)
    setVideoURL: (url: string) => void;
}

// @public (undocumented)
interface IViewport {
    // (undocumented)
    _actors: Map<string, any>;
    // (undocumented)
    addActor(actorEntry: ActorEntry): void;
    // (undocumented)
    addActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    canvas: HTMLCanvasElement;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    customRenderViewportToCanvas: () => unknown;
    // (undocumented)
    defaultOptions: any;
    // (undocumented)
    element: HTMLDivElement;
    // (undocumented)
    getActor(actorUID: string): ActorEntry;
    // (undocumented)
    getActorByIndex(index: number): ActorEntry;
    // (undocumented)
    getActors(): Array<ActorEntry>;
    // (undocumented)
    getActorUIDByIndex(index: number): string;
    // (undocumented)
    getCamera(): ICamera;
    // (undocumented)
    getCanvas(): HTMLCanvasElement;
    // (undocumented)
    _getCorners(bounds: Array<number>): Array<number>[];
    // (undocumented)
    getDefaultActor(): ActorEntry;
    // (undocumented)
    getDisplayArea(): DisplayArea | undefined;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getNumberOfSlices(): number;
    // (undocumented)
    getPan(): Point2;
    // (undocumented)
    getRenderer(): void;
    // (undocumented)
    getRenderingEngine(): any;
    // (undocumented)
    getRotation: () => number;
    // (undocumented)
    getZoom(): number;
    // (undocumented)
    id: string;
    // (undocumented)
    isDisabled: boolean;
    // (undocumented)
    options: ViewportInputOptions;
    // (undocumented)
    removeActors(actorUIDs: Array<string>): void;
    // (undocumented)
    removeAllActors(): void;
    // (undocumented)
    render(): void;
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    reset(immediate: boolean): void;
    // (undocumented)
    setActors(actors: Array<ActorEntry>): void;
    // (undocumented)
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    // (undocumented)
    setDisplayArea(displayArea: DisplayArea, callResetCamera?: boolean, suppressEvents?: boolean): any;
    // (undocumented)
    setOptions(options: ViewportInputOptions, immediate: boolean): void;
    // (undocumented)
    setPan(pan: Point2, storeAsInitialCamera?: boolean): any;
    // (undocumented)
    setRendered(): void;
    // (undocumented)
    setZoom(zoom: number, storeAsInitialCamera?: boolean): any;
    // (undocumented)
    sHeight: number;
    // (undocumented)
    suppressEvents: boolean;
    // (undocumented)
    sWidth: number;
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    type: ViewportType;
    // (undocumented)
    updateRenderingPipeline: () => void;
    // (undocumented)
    viewportStatus: ViewportStatus;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
interface IViewportId {
    // (undocumented)
    renderingEngineId: string;
    // (undocumented)
    viewportId: string;
}

// @public (undocumented)
interface IVolume {
    // (undocumented)
    dimensions: Point3;
    // (undocumented)
    direction: Mat3;
    // (undocumented)
    imageData?: vtkImageData;
    // (undocumented)
    metadata: Metadata;
    // (undocumented)
    origin: Point3;
    // (undocumented)
    referencedVolumeId?: string;
    // (undocumented)
    scalarData: VolumeScalarData | Array<VolumeScalarData>;
    // (undocumented)
    scaling?: {
        PT?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    // (undocumented)
    sizeInBytes?: number;
    // (undocumented)
    spacing: Point3;
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
interface IVolumeInput {
    // (undocumented)
    actorUID?: string;
    // (undocumented)
    blendMode?: BlendModes;
    // (undocumented)
    callback?: VolumeInputCallback;
    // (undocumented)
    slabThickness?: number;
    // (undocumented)
    visibility?: boolean;
    // (undocumented)
    volumeId: string;
}

// @public (undocumented)
interface IVolumeLoadObject {
    // (undocumented)
    cancelFn?: () => void;
    // (undocumented)
    decache?: () => void;
    // (undocumented)
    promise: Promise<ImageVolume>;
}

// @public (undocumented)
interface IVolumeViewport extends IViewport {
    // (undocumented)
    addVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    canvasToWorld: (canvasPos: Point2) => Point3;
    // (undocumented)
    clearDefaultProperties(volumeId?: string): void;
    // (undocumented)
    flip(flipDirection: FlipDirection): void;
    // (undocumented)
    getBounds(): any;
    // (undocumented)
    getCurrentImageId: () => string;
    // (undocumented)
    getCurrentImageIdIndex: () => number;
    // (undocumented)
    getDefaultProperties: (volumeId?: string) => VolumeViewportProperties;
    // (undocumented)
    getFrameOfReferenceUID: () => string;
    // (undocumented)
    getImageData(volumeId?: string): IImageData | undefined;
    // (undocumented)
    getImageIds: (volumeId?: string) => string[];
    // (undocumented)
    getIntensityFromWorld(point: Point3): number;
    // (undocumented)
    getProperties: (volumeId?: string) => VolumeViewportProperties;
    // (undocumented)
    getSlabThickness(): number;
    // (undocumented)
    hasImageURI: (imageURI: string) => boolean;
    // (undocumented)
    hasVolumeId: (volumeId: string) => boolean;
    // (undocumented)
    removeVolumeActors(actorUIDs: Array<string>, immediate?: boolean): void;
    // (undocumented)
    resetCamera(resetPan?: boolean, resetZoom?: boolean, resetToCenter?: boolean): boolean;
    // (undocumented)
    resetProperties(volumeId: string): void;
    // (undocumented)
    setBlendMode(blendMode: BlendModes, filterActorUIDs?: Array<string>, immediate?: boolean): void;
    // (undocumented)
    setDefaultProperties(ViewportProperties: VolumeViewportProperties, volumeId?: string): void;
    // (undocumented)
    setOrientation(orientation: OrientationAxis): void;
    // (undocumented)
    setProperties({ voiRange }: VolumeViewportProperties, volumeId?: string, suppressEvents?: boolean): void;
    // (undocumented)
    setSlabThickness(slabThickness: number, filterActorUIDs?: Array<string>): void;
    // (undocumented)
    setVolumes(volumeInputArray: Array<IVolumeInput>, immediate?: boolean, suppressEvents?: boolean): Promise<void>;
    // (undocumented)
    useCPURendering: boolean;
    // (undocumented)
    worldToCanvas: (worldPos: Point3) => Point2;
}

// @public (undocumented)
function loadAndCacheImage(imageId: string, options?: ImageLoaderOptions): Promise<IImage>;

// @public (undocumented)
function loadAndCacheImages(imageIds: Array<string>, options?: ImageLoaderOptions): Promise<IImage>[];

// @public (undocumented)
function loadImage(imageId: string, options?: ImageLoaderOptions): Promise<IImage>;

// @public (undocumented)
type Mat3 = [number, number, number, number, number, number, number, number, number] | Float32Array;

// @public (undocumented)
type Metadata = {
    BitsAllocated: number;
    BitsStored: number;
    SamplesPerPixel: number;
    HighBit: number;
    PhotometricInterpretation: string;
    PixelRepresentation: number;
    Modality: string;
    SeriesInstanceUID?: string;
    ImageOrientationPatient: Array<number>;
    PixelSpacing: Array<number>;
    FrameOfReferenceUID: string;
    Columns: number;
    Rows: number;
    voiLut: Array<VOI>;
    VOILUTFunction: string;
};

// @public (undocumented)
enum MetadataModules {
    // (undocumented)
    CINE = "cineModule",
    // (undocumented)
    GENERAL_SERIES = "generalSeriesModule",
    // (undocumented)
    IMAGE_PIXEL = "imagePixelModule",
    // (undocumented)
    IMAGE_PLANE = "imagePlaneModule",
    // (undocumented)
    IMAGE_URL = "imageUrlModule",
    // (undocumented)
    MULTIFRAME = "multiframeModule",
    // (undocumented)
    NM_MULTIFRAME_GEOMETRY = "nmMultiframeGeometryModule",
    // (undocumented)
    PATIENT_STUDY = "patientStudyModule"
}

// @public (undocumented)
type NearbyFrames = {
    offset: number;
    imageQualityStatus?: ImageQualityStatus;
};

// @public (undocumented)
enum OrientationAxis {
    // (undocumented)
    ACQUISITION = "acquisition",
    // (undocumented)
    AXIAL = "axial",
    // (undocumented)
    CORONAL = "coronal",
    // (undocumented)
    SAGITTAL = "sagittal"
}

// @public (undocumented)
type OrientationVectors = {
    viewPlaneNormal: Point3;
    viewUp: Point3;
};

// @public (undocumented)
type PixelDataTypedArray = Float32Array | Int16Array | Uint16Array | Uint8Array | Int8Array | Uint8ClampedArray;

// @public (undocumented)
type Plane = [number, number, number, number];

// @public (undocumented)
type Point2 = [number, number];

// @public (undocumented)
type Point3 = [number, number, number];

// @public (undocumented)
type Point4 = [number, number, number, number];

// @public (undocumented)
type PreStackNewImageEvent = CustomEvent_2<PreStackNewImageEventDetail>;

// @public (undocumented)
type PreStackNewImageEventDetail = {
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type PTScaling = {
    suvbwToSuvlbm?: number;
    suvbwToSuvbsa?: number;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
type PublicContourSetData = ContourSetData;

// @public (undocumented)
type PublicSurfaceData = {
    id: string;
    data: SurfaceData;
    frameOfReferenceUID: string;
    color?: Point3;
};

// @public (undocumented)
type PublicViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions?: ViewportInputOptions;
};

// @public (undocumented)
type RangeRetrieveOptions = BaseRetrieveOptions & {
    rangeIndex: number;
    chunkSize?: number | ((metadata: any) => number);
};

// @public (undocumented)
function registerImageLoader(scheme: string, imageLoader: ImageLoaderFn): void;

// @public (undocumented)
function registerUnknownImageLoader(imageLoader: ImageLoaderFn): ImageLoaderFn;

// @public (undocumented)
enum RequestType {
    // (undocumented)
    Interaction = "interaction",
    // (undocumented)
    Prefetch = "prefetch",
    // (undocumented)
    Thumbnail = "thumbnail"
}

// @public (undocumented)
type RetrieveOptions = BaseRetrieveOptions | StreamingRetrieveOptions | RangeRetrieveOptions;

// @public (undocumented)
interface RetrieveStage {
    // (undocumented)
    decimate?: number;
    // (undocumented)
    id: string;
    // (undocumented)
    nearbyFrames?: NearbyFrames[];
    // (undocumented)
    offset?: number;
    // (undocumented)
    positions?: number[];
    // (undocumented)
    priority?: number;
    // (undocumented)
    requestType?: RequestType;
    // (undocumented)
    retrieveType?: string;
}

// @public (undocumented)
type RGB = [number, number, number];

// @public (undocumented)
type Scaling = {
    PT?: PTScaling;
};

// @public (undocumented)
type ScalingParameters = {
    rescaleSlope: number;
    rescaleIntercept: number;
    modality: string;
    suvbw?: number;
    suvlbm?: number;
    suvbsa?: number;
};

// @public (undocumented)
enum SharedArrayBufferModes {
    // (undocumented)
    AUTO = "auto",
    // (undocumented)
    FALSE = "false",
    // (undocumented)
    TRUE = "true"
}

// @public (undocumented)
enum SpeedUnit {
    // (undocumented)
    FRAME = "f",
    // (undocumented)
    SECOND = "s"
}

// @public (undocumented)
type StackInputCallback = (params: {
    imageActor: ImageActor;
    imageId: string;
}) => unknown;

// @public (undocumented)
type StackNewImageEvent = CustomEvent_2<StackNewImageEventDetail>;

// @public (undocumented)
type StackNewImageEventDetail = {
    image: IImage;
    imageId: string;
    imageIdIndex: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type StackViewportNewStackEvent = CustomEvent_2<StackViewportNewStackEventDetail>;

// @public (undocumented)
type StackViewportNewStackEventDetail = {
    imageIds: string[];
    viewportId: string;
    element: HTMLDivElement;
    currentImageIdIndex: number;
};

// @public (undocumented)
type StackViewportProperties = ViewportProperties & {
    interpolationType?: InterpolationType;
    rotation?: number;
    suppressEvents?: boolean;
    isComputedVOI?: boolean;
};

// @public (undocumented)
type StackViewportScrollEvent = CustomEvent_2<StackViewportScrollEventDetail>;

// @public (undocumented)
type StackViewportScrollEventDetail = {
    newImageIdIndex: number;
    imageId: string;
    direction: number;
};

// @public (undocumented)
export class StreamingDynamicImageVolume extends BaseStreamingImageVolume implements Types.IDynamicImageVolume {
    constructor(imageVolumeProperties: Types.IVolume, streamingProperties: Types.IStreamingVolumeProperties);
    // (undocumented)
    getImageIdsToLoad(): string[];
    // (undocumented)
    getImageLoadRequests: (priority: number) => any[];
    // (undocumented)
    getScalarData(): Types.VolumeScalarData;
    // (undocumented)
    isDynamicVolume(): boolean;
    // (undocumented)
    get numTimePoints(): number;
    // (undocumented)
    get timePointIndex(): number;
    set timePointIndex(newTimePointIndex: number);
}

// @public (undocumented)
export class StreamingImageVolume extends BaseStreamingImageVolume {
    constructor(imageVolumeProperties: Types.IVolume, streamingProperties: Types.IStreamingVolumeProperties);
    // (undocumented)
    getImageIdsToLoad: () => string[];
    // (undocumented)
    getImageLoadRequests(priority: number): ImageLoadRequests[];
    // (undocumented)
    getScalarData(): Types.VolumeScalarData;
}

// @public (undocumented)
type StreamingRetrieveOptions = BaseRetrieveOptions & {
    streaming: boolean;
};

// @public (undocumented)
type SurfaceData = {
    points: number[];
    polys: number[];
};

// @public (undocumented)
type TransformMatrix2D = [number, number, number, number, number, number];

// @public (undocumented)
function unregisterAllImageLoaders(): void;

declare namespace VideoViewport {
    export {
        SpeedUnit
    }
}

// @public (undocumented)
type VideoViewportInput = {
    id: string;
    renderingEngineId: string;
    type: ViewportType;
    element: HTMLDivElement;
    sx: number;
    sy: number;
    sWidth: number;
    sHeight: number;
    defaultOptions: any;
    canvas: HTMLCanvasElement;
};

// @public (undocumented)
type VideoViewportProperties = ViewportProperties & {
    loop?: boolean;
    muted?: boolean;
    pan?: Point2;
    playbackRate?: number;
    scrollSpeed?: number;
};

// @public (undocumented)
type ViewportInputOptions = {
    background?: RGB;
    orientation?: OrientationAxis | OrientationVectors;
    displayArea?: DisplayArea;
    suppressEvents?: boolean;
    parallelProjection?: boolean;
};

// @public (undocumented)
interface ViewportPreset {
    // (undocumented)
    ambient: string;
    // (undocumented)
    colorTransfer: string;
    // (undocumented)
    diffuse: string;
    // (undocumented)
    gradientOpacity: string;
    // (undocumented)
    interpolation: string;
    // (undocumented)
    name: string;
    // (undocumented)
    scalarOpacity: string;
    // (undocumented)
    shade: string;
    // (undocumented)
    specular: string;
    // (undocumented)
    specularPower: string;
}

// @public (undocumented)
type ViewportProperties = {
    voiRange?: VOIRange;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
    colormap?: ColormapPublic;
    interpolationType?: InterpolationType;
};

// @public (undocumented)
enum ViewportStatus {
    // (undocumented)
    LOADING = "loading",
    // (undocumented)
    NO_DATA = "noData",
    // (undocumented)
    PRE_RENDER = "preRender",
    // (undocumented)
    RENDERED = "rendered",
    // (undocumented)
    RESIZE = "resize"
}

// @public (undocumented)
enum ViewportType {
    // (undocumented)
    ORTHOGRAPHIC = "orthographic",
    // (undocumented)
    PERSPECTIVE = "perspective",
    // (undocumented)
    STACK = "stack",
    // (undocumented)
    VIDEO = "video",
    // (undocumented)
    VOLUME_3D = "volume3d"
}

// @public (undocumented)
type VOI = {
    windowWidth: number;
    windowCenter: number;
};

// @public (undocumented)
enum VOILUTFunctionType {
    // (undocumented)
    LINEAR = "LINEAR",
    // (undocumented)
    SAMPLED_SIGMOID = "SIGMOID"
}

// @public (undocumented)
type VoiModifiedEvent = CustomEvent_2<VoiModifiedEventDetail>;

// @public (undocumented)
type VoiModifiedEventDetail = {
    viewportId: string;
    range: VOIRange;
    volumeId?: string;
    VOILUTFunction?: VOILUTFunctionType;
    invert?: boolean;
    invertStateChanged?: boolean;
};

// @public (undocumented)
type VOIRange = {
    upper: number;
    lower: number;
};

// @public (undocumented)
type VolumeActor = vtkVolume;

// @public (undocumented)
type VolumeCacheVolumeAddedEvent = CustomEvent_2<VolumeCacheVolumeAddedEventDetail>;

// @public (undocumented)
type VolumeCacheVolumeAddedEventDetail = {
    volume: ICachedVolume;
};

// @public (undocumented)
type VolumeCacheVolumeRemovedEvent = CustomEvent_2<VolumeCacheVolumeRemovedEventDetail>;

// @public (undocumented)
type VolumeCacheVolumeRemovedEventDetail = {
    volumeId: string;
};

// @public (undocumented)
type VolumeInputCallback = (params: {
    volumeActor: VolumeActor;
    volumeId: string;
}) => unknown;

// @public (undocumented)
type VolumeLoadedEvent = CustomEvent_2<VolumeLoadedEventDetail>;

// @public (undocumented)
type VolumeLoadedEventDetail = {
    volume: IImageVolume;
};

// @public (undocumented)
type VolumeLoadedFailedEvent = CustomEvent_2<VolumeLoadedFailedEventDetail>;

// @public (undocumented)
type VolumeLoadedFailedEventDetail = {
    volumeId: string;
    error: unknown;
};

// @public (undocumented)
type VolumeLoaderFn = (volumeId: string, options?: Record<string, any>) => {
    promise: Promise<Record<string, any>>;
    cancelFn?: () => void | undefined;
    decache?: () => void | undefined;
};

// @public (undocumented)
type VolumeNewImageEvent = CustomEvent_2<VolumeNewImageEventDetail>;

// @public (undocumented)
type VolumeNewImageEventDetail = {
    imageIndex: number;
    numberOfSlices: number;
    viewportId: string;
    renderingEngineId: string;
};

// @public (undocumented)
type VolumeScalarData = Float32Array | Uint8Array | Uint16Array | Int16Array;

// @public (undocumented)
type VolumeViewportProperties = ViewportProperties & {
    preset?: string;
    slabThickness?: number;
};

// (No @packageDocumentation comment for this package)

```
